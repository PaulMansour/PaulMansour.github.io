<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/dont-trap-when-you-can-verify">Don't Trap When
            You Can Verify</a>
          </h1>
          <h2>May 11, 2023</h2>
        </header>
        <p>The other day I turned trapping off:</p>
        <pre><code>      600⌶1
2 
</code></pre>
        <p>And attempted to run a user command:</p>
        <pre><code>      ]display ⍳10
VALUE ERROR: Undefined name: exact
findCmdPos[1] exact←{6::⍵ ⋄ exact}~ASN ⍝ exact match?
</code></pre>
        <p>...which fails due to a <strong>micro trap</strong>.</p>
        <p>I'm not picking on user commands here, my apps do this all over the place and it's a bad idea. With trap control set to 1, virtually no aspect of my apps will run. I don't think that should be. Error guards are seductive because they are terse. It's a little annoying to write: </p>
        <pre><code>      {0=⎕NC 'exact':⍵ ⋄ exact}
</code></pre>
        <p>But the explicit test is a better practice. Sure, we can turn trap control on and off, we can put a stop flag in a function to get us to the point where we can safely turn trapping off to proceed to the error we are looking for, but it's all messy.</p>
        <p>There is virtually no scenario during development where we want a micro trap like this to not work. We are abusing the error guard. </p>
        <p>Many times we can avoid micro traps and even guards by refactoring.  Micro traps are often a sign of technical debt: we have no idea how or why a certain state arises, but it does, so we trap around it. Regardless, if we must handle the case instead of finding and eliminating the root cause, it is better to explicitly test for it.</p>
        <p>So this proscription is now added to the <a href="/donts">Dyalog APL Dont's</a> </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/excel-column-names">Excel Column Names</a>
          </h1>
          <h2>May 8, 2023</h2>
        </header>
        <p>Phase I, problem 3, of the 2020 Dyalog Programming Contest, <strong>Excel-lent Columns</strong> is stated thus:</p>
        <blockquote>
          <p>A Microsoft Excel spreadsheet numbers its rows counting up from 1. However Excel's columns are labelled alphabetically — beginning with A–Z, then AA–AZ, BA– BZ, up to ZA–ZZ, then AAA–AAZ and so on. Write a function that, given a right argument which is a character scalar or nonempty vector representing a valid character Excel column identifier between A and XFD, returns the corresponding column number</p>
          <p>Hint: The Decode function <code>X⊥Y</code>.</p>
          <p>Examples:</p>
          <pre><code>      (fn) 'A'
1
      (fn) 'APL'
1104
</code></pre>
        </blockquote>
        <p>The solution is concise:</p>
        <pre><code>      N2I←{26⊥⎕A⍳⍵}
      N2I¨'A' 'Z' 'AA' 'AZ' 'BA'
1 26 27 52 53
</code></pre>
        <p>With such a simple solution, one would think the inverse would be fairly easy. That is, given an integer, return the corresponding column name. If <code>decode</code> solves it one way, certainly <code>encode</code> should solve it the other way:</p>
        <pre><code>      {(' ',⎕A)[1+26 26⊤⍵]}¨1 26 27 52 53 
 A  A   AA  B   BA 
</code></pre>
        <p>Clearly not correct. The problem is that the column names are not plain old base-26, but rather bijective base-26, as a recent August 22, 2022 answer to an <a href="https://stackoverflow.com/questions/181596/how-to-convert-a-column-number-e-g-127-into-an-excel-column-e-g-aa">old question on Stack Overflow makes clear.</a></p>
        <p>This is not handled well by <code>encode</code>. While it may be possible to post-process the result of <code>encode</code> to make this work, I have not found a solution in this direction. From the referenced question and answer we can use recursion to compute the correct answer: </p>
        <pre><code>      I2N←{
           ⍺←⎕A
           n←≢⍺
           i←{q←¯1+⌈⍵÷n
              a←⍵-n×q
              q=0:,a
              a,⍨∇ q}⍵
           ⍺[i]
       }
       I2N¨1 26 27 52 53
 A  Z  AA  AZ  BA  
</code></pre>
        <p>Both of these functions are fairly easy to convert to work on vectors, but it does get a little messy.</p>
        <p>The function <code>I2N</code> works for any number of digits, which is nice. But this being APL for the practical programmer, we note that Excel columns don't exceed ZZZ (in fact much less) so it is easy to generate all possible Excel column names:</p>
        <pre><code>      n←⊃,/,¨∘.,\3⍴⊂,¨⎕A
      10↑n
 A  B  C  D  E  F  G  H  I  J 
      ¯10↑n
 ZZQ  ZZR  ZZS  ZZT  ZZU  ZZV  ZZW  ZZX  ZZY  ZZZ 
</code></pre>
        <p>With this in hand, and precomputed if we are worried about performance, we can trivially solve both the original problem and its inverse, with a single self-inverse function:</p>
        <pre><code>      ColumnLookup←{
          ⍝ ⍵ ←→ Column Index or Name
          ⍝ ← ←→ Column Name or Index
          ⍺←⊃,/,¨∘.,\3⍴⊂,¨⎕A
          2=≡⍵:⍺⍳⍵
          ⍺[⍵]
          }   
       ColumnLookup 1 26 27 52 53
 A  Z  AA  AZ  BA 
       ColumnLookup ColumnLookup 1 26 27 52 53
1 26 27 52 53
</code></pre>
        <p>If we precompute the column names, this will be the fastest and the simplest solution, though all the solutions are petty fast, even with an <code>each</code>. </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/dom-via-json-performance">DOM via JSON Performance</a>
          </h1>
          <h2>April 12, 2023</h2>
        </header>
        <p>In the <a href="/posts/the-dom-via-json">previous post</a> we looked at building an APL DOM from a <code>⎕XML</code>-style matrix using <code>⎕JSON</code> rather than recursively creating namespaces by hand. Now let's look at some performance characteristics.</p>
        <p>First let's create a relatively large document and convert it to HTML:</p>
        <pre><code>      A←#.Abacus.Main
  
      LargeDoc←{
            v←25000 20⍴⍕¨⍳500000
            t←A.NewTable v
            c←A.Cells t
            c.class←⊂'cell'
            c.id←v
            t
       }
      
      d←LargeDoc 0
      h←A.DOM2HTML d 
      ≢h
20127817
</code></pre>
        <p>Now let's convert the HTML to a <code>⎕XML</code> matrix, and test the performance of the two techniques from the previous post for converting a <code>⎕XML</code> matrix to a ⎕JSON matrix: </p>
        <pre><code>  xm←⎕XML h
      cmpx 'XM2JM_NoLoop xm' 'XM2JM_Loop xm'
  XM2JM_NoLoop xm → 5.2E¯1 |    0% ⎕⎕⎕⎕⎕⎕⎕⎕                                
  XM2JM_Loop xm   → 2.4E0  | +372% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕
</code></pre>
        <p>While it's no surprise that the non-looping algorithm is faster, it is remarkable that the looping technique is not that bad. In addition no attempt has been made to sqeeze any more performance out of the non-looping function, other than the initial act of removing the loop, so there may be more speed to be had.   </p>
        <p>Of more interest is the relative performance of the complete task of using <code>⎕JSON</code> verses recursion to build the DOM:</p>
        <pre><code>      HTML2DOMviaJSON←{
                ⎕JSON(⎕JSON⍠'M')XM2JM ⎕XML ⍵
            }
      
      
      cmpx 'HTML2DOMviaJSON h'  'A.HTML2DOM h'
  HTML2DOMviaJSON h → 9.4E0  |   0% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕                   
* A.HTML2DOM h      → 1.8E1  | +91% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕
</code></pre>
        <p>Note that the results of these two functions don't match as they are namespaces not arrays. Note further that <code>⎕JSON</code> creates a tree where the child namespaces are true children of the parent, as opposed to the (this particular) recursive technique:  </p>
        <pre><code>        d1←HTML2DOMviaJSON h
        d2←A.HTML2DOM h 
        ⊃⊃⊃d1.Content.Content.Content
#.[JSON object].[JSON object].[JSON object].[JSON object]
        ⊃⊃⊃d2.Content.Content.Content
#.Abacus.Main.[Namespace]
</code></pre>
        <p>Recursion is clearly slower, but more testing should be done on reasonably sized and more realistic documents, especially docs with more depth.</p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2023 Paul S. Mansour</p>
    </footer>
  </body>
</html>
