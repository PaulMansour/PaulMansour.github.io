<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/leetcode-185">LeetCode 185</a>
          </h1>
          <h2>June 25, 2022</h2>
        </header>
        <p>
          Let's solve LeetCode 185, the
          <a href="https://leetcode.com/problems/department-top-three-salaries/">Department
          Top Three Salaries</a>
          problem, in FlipDB, our array-oriented, APL-based DSL. We will
          use FlipDB directly in the APL session.
        </p>
        <p>We are given two tables, a department table and an employee
        table:</p>
        <pre>
          <code>      d←s.Get '/Databases/LeetCode185'
      d.Display 0
 ── LeetCode185.Department                       
  ┌ID──┐  ┌Name───┐                            
  ↓1   │  ↓IT     │                            
  │2   │  │Sales  │                            
  └Int8┘  └Char(5)┘                            
 ── 2 rows by 2 columns                        
                                               
 ── LeetCode185.Employee ───────────────────── 
  ┌ID──┐  ┌Name───┐  ┌Salary┐  ┌DepartmentID┐  
  ↓1   │  ↓Joe    │  ↓85,000│  ↓1           │  
  │2   │  │Henry  │  │80,000│  │2           │  
  │3   │  │Sam    │  │60,000│  │2           │  
  │4   │  │Max    │  │90,000│  │1           │  
  │5   │  │Janet  │  │69,000│  │1           │  
  │6   │  │Randy  │  │85,000│  │1           │  
  │7   │  │Will   │  │70,000│  │1           │  
  └Int8┘  └Char(5)┘  └Int32─┘  └Int8────────┘  
 ── 7 rows by 4 columns ────────────────────── 
</code>
        </pre>
        <p>The problem is:</p>
        <blockquote>
          <p>A company's executives are interested in seeing who earns
          the most money in each of the company's departments. A high earner
          in a department is an employee who has a salary in the top three
          unique salaries for that department. Write an SQL query to find
          the employees who are high earners in each of the departments.</p>
        </blockquote>
        <p>The Department table does not add anything to the problem. It
        simply gives a nice description for each department, and we can
        dispense with it.</p>
        <p>We create a new query on the Employee table:</p>
        <pre>
          <code>      t←d.GetTable 'Employee'
      q←t.Query '' 
</code>
        </pre>
        <p>
          The task is simply to select some rows. There is no computation
          or aggregation required in the result, so the only thing we need
          to specify is a where clause, making use of the
          <strong>rankDown</strong>
          function:
        </p>
        <pre>
          <code>      q.Where←'3 &gt; 1 rankDown by Salary (group DepartmentID)'
      r←q.Execute 0
      r.Display 0
── Key:ID ───────────────────────────────────
 ┌ID──┐  ┌Name───┐  ┌Salary┐  ┌DepartmentID┐ 
 ↓1   │  ↓Joe    │  ↓85,000│  ↓1           │ 
 │2   │  │Henry  │  │80,000│  │2           │ 
 │3   │  │Sam    │  │60,000│  │2           │ 
 │4   │  │Max    │  │90,000│  │1           │ 
 │6   │  │Randy  │  │85,000│  │1           │ 
 │7   │  │Will   │  │70,000│  │1           │ 
 └Int8┘  └Char(5)┘  └Int32─┘  └Int8────────┘ 
── 6 rows by 4 columns ──────────────────────
</code>
        </pre>
        <p>
          Note first that the
          <code>rankDown</code>
          function is in
          <code>⎕IO←0</code>
          , so we are selecting salaries ranked 0, 1, or 2. Note further
          that
          <code>rankDown</code>
          takes a left argument of 0 1 or 2, for rank, dense rank, and
          average rank, respectively, so in this case we are applying dense
          rank. Finally note that
          <code>rankDown</code>
          is passed to the
          <code>by</code>
          operator to apply it within each department.
        </p>
        <p>We can pick apart this where clause expression and see how it
        works, right in the APL session:</p>
        <pre>
          <code>        disp←{⍵.Display 0}
        Salary←85 80 60 90 69 85 70
        Department←1 2 2 1 1 1 1
</code>
        </pre>
        <p>
          The
          <code>group</code>
          function returns the indices for each unique value:
        </p>
        <pre>
          <code>        disp group Department
┌───────────┐
↓[0,3,4,5,6]│
│[1,2]      │
└Int8───────┘
</code>
        </pre>
        <p>
          The
          <code>rankDown</code>
          function, with a left argument of 1 for dense, applied to Salary
          directly:
        </p>
        <pre>
          <code>       disp 1 rankDown Salary
┌────┐
↓1   │
│2   │
│5   │
│0   │
│4   │
│1   │
│3   │
└Int8┘
</code>
        </pre>
        <p>
          And now applied via the
          <code>by</code>
          operator, so that we rank within each group:
        </p>
        <pre>
          <code>        disp 1 rankDown by Salary (group Department)
┌────┐
↓1   │
│0   │
│1   │
│0   │
│3   │
│1   │
│2   │
└Int8┘
</code>
        </pre>
        <p>
          The
          <code>by</code>
          operator groups the data and applies its operand function to
          each group, and then ungroups the data, restoring it to its original
          order. It is particularly useful with uniform functions like
          <code>rankDown</code>
          , but it is also useful with aggregate and structural functions.
        </p>
        <p>Finally we flag the top 3 ranks:</p>
        <pre>
          <code>      disp 3 gt 1 rankDown by Salary(group Department)
┌───────┐
↓1      │
│1      │
│1      │
│1      │
│0      │
│1      │
│1      │
└Boolean┘
</code>
        </pre>
        <h3>Design Issue</h3>
        <p>
          There is a tradeoff when designing a DSL, between more functions
          with fewer arguments, and fewer functions with more arguments.
          In the case of rank, FlipDB currently has two functions,
          <code>rankUp</code>
          and
          <code>rankDown</code>
          , each taking three potential values as a left argument for an
          effective total combination of 6 functions:
        </p>
        <pre>
          <code>rankUp
rankDown
denseRankUp
denseRankDown
averageRankUp
averageRankDown
</code>
        </pre>
        <p>
          We could of course have only one function,
          <code>rank</code>
          , and provide yet another argument for the direction. The idea
          behind building in the ordering into the name was to make it
          similar to the related APL primitives
          <code>grade up</code>
          and
          <code>grade down</code>
          . Two functions seemed good, 6 functions seemed overkill at the
          time, but I'm reconsidering. It would be easier to read
          <code>denseRankDown Salary</code>
          than
          <code>1 rankDown Salary</code>
          . The latter requires a trip to the documentation, while the
          former is discoverable with autocomplete.
        </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/operators-in-a-dsl">Operators in a DSL</a>
          </h1>
          <h2>May 28, 2022</h2>
        </header>
        <p>When designing a number-crunching domain specific language (DSL)
        in Dyalog APL we have the luxury of using operators. This immediately
        presents many design issues. Operators decrease the number of functions
        in the DSL, reducing overall size and complexity. At the same time,
        operators increase the complexity of composing an individual expression
        by introducing more moving parts.</p>
        <blockquote>
          <p>
            Note
            <code>⎕IO←0</code>
            and
            <code>⎕ML←1</code>
            throughout. In addition, all functions and operators defined
            below are simplified and unoptimized versions of production
            code.
          </p>
        </blockquote>
        <p>
          Consider providing a
          <code>maximum</code>
          function and a
          <code>reduce</code>
          operator in the DSL as direct covers of their APL counterparts:
        </p>
        <pre>
          <code>      maximum←{⍺⌈⍵}
      reduce←{⍺⍺/⍵}
</code>
        </pre>
        <p>No end-user wants to think or type:</p>
        <pre>
          <code>      maximum reduce StockPrice
</code>
        </pre>
        <p>when he could type:</p>
        <pre>
          <code>      max StockPrice
</code>
        </pre>
        <p>
          which one can do in say, SQL. So instead we provide the aggregate
          functions like
          <code>sum</code>
          and
          <code>max</code>
          in addition to their scalar counterparts:
        </p>
        <pre>
          <code>      sum←{+/⍵}
      max←{⌈/⍵}
</code>
        </pre>
        <p>As noted, fewer operators make more functions. However, many
        if not most of the primitive arithmetic and boolean reductions
        are so commonly used that they have useful and well-known names
        like sum, min, max, any, all, etc. In addition, there are many
        more common aggregate functions like average and variance that
        are not primitive scalar reductions and these would need to be
        provided directly as functions anyway. So this is an easy decision;
        the trade-off of more functions and fewer operators in this case
        is well worth it.</p>
        <p>
          Now let's take the next step: running aggregates. Again, we have
          the option of providing a single operator or an additional set
          of functions. In APL we use the scan operator with a scalar function
          for this. However, in our DSL, once we have named aggregate functions
          like
          <code>sum</code>
          and
          <code>max</code>
          , it makes sense to use the aggregate function as the operand
          rather than the scalar function on which the aggregate is based,
          so we might define a
          <code>running</code>
          operator as:
        </p>
        <pre>
          <code>      running←{
          h←⊃61 ⎕ATX'⍺⍺'
          f←{⍵↑⍨⍵⍳'←'}1↓h
          f≡'sum':+\⍵
          f≡'max':⌈\⍵
          ⍺⍺¨,\⍵
      }
</code>
        </pre>
        <p>
          Here the choice is more open for debate, but I think it is still
          clearly in favor of the operator, especially considering that
          moving statistics could be handled by just giving a left argument
          to the running operator. Now a single operator is reducing the
          need for a lot of functions that will have awkward names and
          that will not get called very often. Kx Systems took the opposite
          approach with q, but I can only imagine there was no choice,
          as k does not support user-defined operators. The proliferation
          of functions and the difficulty naming them
          <a href="https://code.kx.com/q/ref/sum/">is immediately apparent.</a>
        </p>
        <p>
          The derived function
          <code>sum running</code>
          is an example of a
          <strong>uniform</strong>
          function - a function that returns a result that is the same
          shape as its argument. The result of a uniform function generally
          depends on the totality of the items in the array - both the
          existence and the ordering of the items. This feature distinguishes
          them from scalar functions. There are many uniform functions
          that are not derived functions. Prime examples in APL are grade
          up (
          <code>⍋</code>
          ) and grade down
          <code>(⍒)</code>
          , rotate
          <code>(⌽)</code>
          and first occurrence (monadic
          <code>≠</code>
          ). A DSL may have many more like
          <code>lag</code>
          and
          <code>lead</code>
          :
        </p>
        <pre>
          <code>      lag←{
           ¯1↓0,⍵
       }
      lead←{
          1↓⍵,0
       } 
</code>
        </pre>
        <p>
          Uniform functions lend themselves to being applied to an argument
          that is conceptually grouped and or ordered. Yet again we are
          faced with the choice of an operator or a plethora of additional
          functions- functions that are even more awkward to name, and
          that require a lot of arguments. In this case there is simply
          no contest. Going the route of additional functions is
          <a href="https://docs.1010data.com/1010dataReferenceManual/Functions/GroupFunctions/Group.html">not
          pretty.</a>
          Let's define an operator
          <code>by</code>
          with the following syntax:
        </p>
        <pre>
          <code>      R←[X] F by Y I [B]     
</code>
        </pre>
        <p>
          Here
          <code>F</code>
          is any uniform (or aggregate - more on this later) function.
          <code>Y</code>
          is a suitable right argument for
          <code>F</code>
          , and
          <code>X</code>
          is an optional left argument for
          <code>F</code>
          .
          <code>I</code>
          is a grade vector that orders
          <code>Y</code>
          , or a set of grade vectors that groups and optionally orders
          <code>Y</code>
          .
          <code>B</code>
          is an optional boolean selection vector that flags items to include
          and exclude in the computation.
        </p>
        <p>
          The
          <code>by</code>
          operator sorts and groups
          <code>Y</code>
          according to
          <code>I</code>
          , (optionally selecting by
          <code>B</code>
          ), applies
          <code>F</code>
          to each group, and then ungroups and reorders the results to
          correspond to the original argument
          <code>Y</code>
          . This is similar to the under
          <a href="https://aplwiki.com/wiki/Under">operator</a>
          , but I don't think it can handle this particular case.
        </p>
        <p>Sorting and grouping is provided by grade vectors rather than
        providing corresponding values on which to sort and group for the
        same reason sorting in APL is a two-step process with grade up
        and grade down. In addition we extract some complexity from the
        by operator by computing I beforehand using grouping and sorting
        functions.</p>
        <p>
          Let's define
          <code>by</code>
          as follows:
        </p>
        <pre>
          <code>by←{
     ⍺←⊣
     a i b←3↑⍵,⊂1⍴⍨≢⊃⍵
     g←{⍺{⍵⌷⍨⊂⍺}¨⊂⍵}
     (pa pb)←(⊆i)∘g¨a b
     sa←pb/¨pa
     r←⍺ ⍺⍺¨sa
     af←1=≡r
     ua←2=≢61 ⎕ATX'⍺⍺'
     ff←af∨ua
     z←(~⊃¨pb)∧~af
     (⊃¨pb)←1
     e←({|2-/⍸⍵,1}¨⍣ff)pb
     v←∊e\¨r,¨⍨z/¨0
     v[⍋∊i]
 }
</code>
        </pre>
        <p>Now we can do a running sum from lowest to highest:</p>
        <pre>
          <code>      A←100 2 1 8 12
      sum running by A (⍋A)
123 3 1 11 23
</code>
        </pre>
        <p>In other words, for each item, find the sum of it and all items
        less than it. Let's also define a grouping function that can optionally
        take a grade vector as its left argument:</p>
        <pre>
          <code>group←{
     ⍺←⍳≢⍵
     i←{↓⍵}⌸⍵[⍺]
     ⍺∘{⍺[⍵]}¨i
 }
</code>
        </pre>
        <p>And some more data to play around with:</p>
        <pre>
          <code>      RowId←1+⍳10
      Account←1 2 3 3 1 2 1 1 1 2
      Payment←8 3 5 4 2 7 1 9 6 10
      Day←31 1 9 5 14 27 22 17 3 11
      M←⍉↑RowId Account Payment Day
      M
 1 1  8 31
 2 2  3  1
 3 3  5  9
 4 3  4  5
 5 1  2 14
 6 2  7 27
 7 1  1 22
 8 1  9 17
 9 1  6  3
10 2 10 11
</code>
        </pre>
        <p>To round out our little DSL, let's also cover grade up:</p>
        <pre>
          <code>orderUp←{
     ⍋⍵
 }
</code>
        </pre>
        <p>Now we can compute a running sum of payments by account:</p>
        <pre>
          <code>      M,sum running by Payment (group Account)
 1 1  8 31  8
 2 2  3  1  3
 3 3  5  9  5
 4 3  4  5  9
 5 1  2 14 10
 6 2  7 27 10
 7 1  1 22 11
 8 1  9 17 20
 9 1  6  3 26
10 2 10 11 20
</code>
        </pre>
        <p>It is often useful to compute and save the ordering and grouping.
        So to find the ordered running sum of payments by account:</p>
        <pre>
          <code>      G←(orderUp Day) group Account
      M,sum running by Payment G
 1 1  8 31 26
 2 2  3  1  3
 3 3  5  9  9
 4 3  4  5  4
 5 1  2 14  8
 6 2  7 27 20
 7 1  1 22 18
 8 1  9 17 17
 9 1  6  3  6
10 2 10 11 13
</code>
        </pre>
        <p>And to find the previous payment for each day by account:</p>
        <pre>
          <code>      M,lag by Payment G
 1 1  8 31  1
 2 2  3  1  0
 3 3  5  9  4
 4 3  4  5  0
 5 1  2 14  6
 6 2  7 27 10
 7 1  1 22  9
 8 1  9 17  2
 9 1  6  3  0
10 2 10 11  3
</code>
        </pre>
        <p>
          The
          <code>by</code>
          operator is useful not only with uniform functions, but with
          aggregate functions as well. The result of the aggregate function
          on each group is replicated to line up with the original argument:
        </p>
        <pre>
          <code>      M,sum by Payment (group Account)
 1 1  8 31 26
 2 2  3  1 20
 3 3  5  9  9
 4 3  4  5  9
 5 1  2 14 26
 6 2  7 27 20
 7 1  1 22 26
 8 1  9 17 26
 9 1  6  3 26
10 2 10 11 20
</code>
        </pre>
        <p>And we can apply a boolean selection as well:</p>
        <pre>
          <code>      M,sum by Payment (group Account) (Day&lt;15)
 1 1  8 31  8
 2 2  3  1 13
 3 3  5  9  9
 4 3  4  5  9
 5 1  2 14  8
 6 2  7 27 13
 7 1  1 22  8
 8 1  9 17  8
 9 1  6  3  8
10 2 10 11 13
</code>
        </pre>
        <p>There is a balancing act with respect to operators and functions.
        This is similar to the balancing act of fewer functions with more
        arguments, versus more functions and fewer arguments. Overuse of
        operators can make individual expressions and discovery difficult.
        Underuse can lead to a proliferation of badly named and rarely
        used functions that have too many arguments.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/session-configuration">Session Configuration</a>
          </h1>
          <h2>March 6, 2022</h2>
        </header>
        <p>When I get a new version of Dyalog (Windows), I go to the configuration
        dialog box and manually set some options. This is painful, error
        prone and a general waste of time. In addition, I increase the
        session font size, and save the session file. This is even worse,
        as saving the session file can have other deleterious effects.
        It has never been clear to me why it is necessary to save the session
        file simply to remember session font size. Anyway, it is way past
        time to change this entire routine.</p>
        <p>Dyalog 18.0 introduced some new features, techniques, and options
        for session configuration. The most important is the introduction
        of configuration files. Dyalog 18.2 brings some enhancments to
        these features. There is now a plethora of ways to intialize settings,
        configure things, and run code on starting the interpreter.</p>
        <p>
          When a new version of Dyalog is installed, I want to specify
          at most one thing: The UserConfigFile parameter. This parameter
          will point to my confuration file and, indirectly, its parent
          folder. This parent folder is my
          <strong>user configuration folder</strong>
          ; it contains the configuration file itself, as well as any other
          assets for configuring the sesssion like custom user commands
          and code that execute on startup.
        </p>
        <p>The user config file, and its encompassing user config folder,
        should be completely portable, which means that any file or path
        specified inside the config file should be relative to the location
        of the config file itself.</p>
        <p>
          Currently it looks like some parameters that take file names
          or paths as values will accept relative paths, but not all. The
          most important one for me that does not accept relative paths
          is the SALT/CommandFolder that specifies where to look for user
          commands. (I could probably hack this, but if I start looking
          at the APL code in
          <code>⎕SE</code>
          , the urge to rewrite the entire user command framework will
          be overwhelming - must not do that!) Thus I am stuck with a unportable
          configuration file that looks something like:
        </p>
        <pre>
          <code>{ 
  Settings: {
             Default_IO: 0,
             Default_ML: 3, 
             ClassicMode: 1,
             ClassicModeSavePosition: 1,
             SingleTrace: 1,
             AutoPW: 1, 
             SessionOnTop: 1,                          
             Log_Size: "8M",
             MaxWS: "8G",
             PropertyExposeRoot: 1,
             Load: "startup.apln",   
             SALT: {
                    CommandFolder: "c:/APLStartup/;[dyalog]/SALT/spice",                 
                   },
             Colours: {
                       SchemeName: "Back in Black",  
                      },
            }
}
</code>
        </pre>
        <p>We should be able to write something like:</p>
        <pre>
          <code>  SALT: {
            CommandFolder: "[configfolder];[dyalog]/SALT/spice",                 
        },
</code>
        </pre>
        <h2>Fixing and Executing Code on Startup</h2>
        <p>There are at least four ways to fix and excute code on startup:</p>
        <p>
          1. The user command framework using a
          <strong>setup.dyalog</strong>
          file.
        </p>
        <p>
          2. The
          <strong>DyalogStartup</strong>
          parameter.
        </p>
        <p>
          3. The
          <strong>DyalogStartupSE</strong>
          parameter.
        </p>
        <p>
          4. The
          <strong>Load</strong>
          (and
          <strong>LX</strong>
          ) configuration parameter.
        </p>
        <p>
          Option 1 requires placing setup.dyalog in a specific place, this
          is a no go. Option 2 requires highjacking LINK, and the DyalogStartupSE
          parameter which we probably don't want to do. Option 3 requires
          either putting code in some specific place that dyalog knows
          about or specifying a fully qualified path. Furthermore, there
          is a heirarchy of folders that are searched, which may be too
          clever by half, and lead to a lot of confusion. That leaves Option
          4, the
          <code>Load</code>
          parameter. Luckily it respects relative paths, and will look
          in the same location as the config file. The code can expunge
          itself after executing, and not clutter the root or introduce
          a name conflict. Here, for example, is a very simple startup
          routine that increases the font size, and specifies that the
          session window should be maximized:
        </p>
        <pre>
          <code>:Namespace startup
     ⎕SE.FontObj[1]←28
     ⎕SE.State←2
     Run←{
         #.⎕EX 'startup'
     }
:EndNamespace
</code>
        </pre>
        <p>Of course we could do much more here, like set PFKeys, load
        code into ⎕SE, mess around with menus, etc.</p>
        <p>
          It is not clear to me what precisely Dyalog envisioned as use-cases
          for the
          <code>Load</code>
          parameter. It accepts, workspaces, functions, namespace and class
          scripts and even, new in 18.2, a folder that is then automatically
          LINKed. For developement purposes, it seems ideal to use
          <code>Load</code>
          for session configuration.
        </p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2022 Paul S. Mansour</p>
    </footer>
  </body>
</html>
