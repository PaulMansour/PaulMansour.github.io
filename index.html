<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/anatomy-of-a-query-ii">Anatomy of a Query,
            Part 2</a>
          </h1>
          <h2>December 20, 2022</h2>
        </header>
        <p>
          In the first part of this series,
          <a href="/posts/anatomy-of-a-query">Anatomy of a Query</a>
          , we looked at how a query is an ordered collection of names
          and expressions, divided into various sections. For simplicity,
          we assumed all of the data was in a single table. Of course data
          may be in multiple tables, or even multiple databases, and perhaps
          in a CSV file hanging around on the disk, not even in the database.
          To explore how FlipDB handles multiple tables, we will refer
          to CJ Date's classic
          <strong>Suppliers and Parts</strong>
          database:
        </p>
        <pre>
          <code> ── SandP.S ──────────────────────────────────            
  ┌SNO────┐  ┌STATUS┐  ┌CITY────┐  ┌SNAME───┐             
  ↓S1     │  ↓20    │  ↓London  │  ↓Smith   │             
  │S2     │  │10    │  │Paris   │  │Jones   │             
  │S3     │  │30    │  │Paris   │  │Blake   │             
  │S4     │  │20    │  │London  │  │Clark   │             
  │S5     │  │30    │  │Athens  │  │Adams   │             
  └Char(2)┘  └Int8──┘  └Char(10)┘  └Char(10)┘             
 ── 5 rows by 4 columns ──────────────────────            
                                                          
 ── SandP.P ────────────────────────────────────────────  
  ┌PNO────┐  ┌PNAME──┐  ┌COLOR──┐  ┌WEIGHT┐  ┌CITY────┐   
  ↓P1     │  ↓Nut    │  ↓Red    │  ↓12    │  ↓London  │   
  │P2     │  │Bolt   │  │Green  │  │17    │  │Paris   │   
  │P3     │  │Screw  │  │Blue   │  │17    │  │Oslo    │   
  │P4     │  │Screw  │  │Red    │  │14    │  │London  │   
  │P5     │  │Cam    │  │Blue   │  │12    │  │Paris   │   
  │P6     │  │Cog    │  │Red    │  │19    │  │London  │   
  └Char(2)┘  └Char(5)┘  └Char(5)┘  └Int8──┘  └Char(10)┘   
 ── 6 rows by 5 columns ────────────────────────────────  
                                                          
 ── SandP.SP ──────────────────────────────────────────── 
  ┌AUTOKEY┐  ┌QTY──┐  ┌SDATE─────┐  ┌SNO────┐  ┌PNO────┐  
  ↓1      │  ↓300  │  ↓2008-10-27│  ↓S1     │  ↓P1     │  
  │2      │  │200  │  │2008-08-19│  │S1     │  │P2     │  
  │3      │  │400  │  │2008-05-18│  │S1     │  │P3     │  
  │4      │  │200  │  │2007-08-18│  │S1     │  │P4     │  
  │5      │  │100  │  │2007-08-17│  │S1     │  │P5     │  
  │6      │  │100  │  │2009-12-16│  │S1     │  │P6     │  
  │7      │  │300  │  │2009-07-31│  │S2     │  │P1     │  
  │8      │  │400  │  │2009-12-17│  │S2     │  │P2     │  
  │9      │  │200  │  │2009-07-24│  │S3     │  │P2     │  
  │10     │  │200  │  │2009-10-03│  │S4     │  │P2     │  
  │11     │  │300  │  │2009-06-28│  │S4     │  │P4     │  
  │12     │  │400  │  │2009-11-04│  │S4     │  │P5     │  
  └Int8───┘  └Int16┘  └Date──────┘  └Char(2)┘  └Char(2)┘  
 ── 12 rows by 5 columns ──────────────────────────────── 
</code>
        </pre>
        <p>
          A FlipDB query generally starts with a certain table, called
          the
          <em>starting table</em>
          . Column names in this table are specified directly; there is
          no need to qualify them. If starting in the
          <code>SP</code>
          table, for example, we may specify the quantity column simply
          as:
        </p>
        <pre>
          <code>QTY
</code>
        </pre>
        <p>In SQL, in order to query data across multiple tables, the tables
        must be joined in some way. Then columns and rows are selected
        from this combined table or view. For example:</p>
        <pre>
          <code>select distinct sp.pno,sname from
supplier inner join sp using (sno)
where supplier.city = 'London';
</code>
        </pre>
        <p>This gets complicated very quickly.</p>
        <p>Because a FlipDB query is an ordered set of names and expressions,
        we may directly specify a column from another table in an expression,
        using a number of different syntaxes and special functions.</p>
        <p>
          If we are lucky enough to have a formal database set up, with
          primary, alternate, and foreign keys, we can use a simple dot
          syntax to specify a column in a different table via a foreign
          key. Starting with the
          <code>SP</code>
          table, we can reach into the
          <code>P</code>
          table and get the
          <code>PNAME</code>
          column:
        </p>
        <pre>
          <code>PNO.PNAME
</code>
        </pre>
        <p>
          This is called a
          <em>simple join</em>
          . Note there is no explicit reference to the foreign table
          <code>P</code>
          . The foreign key column PNO implies it. The result is a simple
          column, as by definition there is a one-to-many relationship
          between tables
          <code>S</code>
          and
          <code>SP</code>
          . The column
          <code>PNAME</code>
          will be sorted and replicated to line up up with the
          <code>SP</code>
          table. A simple join can link through multiple tables, by specifying
          multiple foreign keys:
        </p>
        <pre>
          <code>FK1.FK2.FK3.Col 
</code>
        </pre>
        <p>
          We can use foreign keys to go the other way as well. Starting
          in the
          <code>P</code>
          table we can reference a column in the
          <code>SP</code>
          table as follows:
        </p>
        <pre>
          <code>SP[PNO].QTY
</code>
        </pre>
        <p>
          Here we make specific refence to the SP table, indicate in brackets
          the foreign key column in SP that points back to our primary
          table P, and finally after the dot, the name of the column in
          SP to materialize. By definition, this value is a partitioned
          column, as there is a many-to-one relationship between tables
          <code>SP</code>
          and
          <code>P</code>
          . This is called a
          <em>partition join</em>
          .
        </p>
        <p>Simple and partition joins may be combined to link through multiple
        tables:</p>
        <pre>
          <code>SP[PNO].SNO.CITY
</code>
        </pre>
        <p>If we don't have a foreign key specified, we can do explicit
        look-ups:</p>
        <pre>
          <code>Table2[ColA;ColB].ColC
</code>
        </pre>
        <p>
          This materializes ColC from Table2, by looking up the values
          of ColA from the starting table in ColB from table 2. If the
          ColA-ColB relationship is one-to-one, or many to one, the result
          is simple, while if the relationship is one-to-many or many-to-many,
          the result is partitioned. This is called a
          <em>general join</em>
          .
        </p>
        <p>Sometimes we want to access a column in another table without
        regard to any key:</p>
        <pre>
          <code>SP[].QTY                                         `
</code>
        </pre>
        <p>
          Here the result is enclosed as it is non-conforming; there is
          no correlation between the starting table and this column. This
          is useful as the
          <code>where</code>
          clause has no effect. We can reach out of the context we are
          in and grab an entire column from another table, or even the
          current table. This is called an
          <em>enclosed join</em>
          .
        </p>
        <p>
          Directly accessing data from other tables is supremely useful
          because we want to apply APL-style solutions directly in our
          queries, avoiding the headache of SQL. Consider a query starting
          in the parts table
          <code>P</code>
          , with the following select clause:
        </p>
        <table>
          <thead>
            <tr>
              <th class="left">Name</th>
              <th class="left">Expression</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="left">
                <code>PNO</code>
              </td>
              <td class="left">
                <code>PNO</code>
              </td>
            </tr>
            <tr>
              <td class="left">
                <code>SupplierIn</code>
              </td>
              <td class="left">
                <code>SP[PNO].SNO.CITY</code>
              </td>
            </tr>
            <tr>
              <td class="left">
                <code>InParis</code>
              </td>
              <td class="left">
                <code>any 'Paris' eq SupplierIn</code>
              </td>
            </tr>
            <tr>
              <td class="left">
                <code>IsCompetition</code>
              </td>
              <td class="left">
                <code>not unique SupplierIn</code>
              </td>
            </tr>
          </tbody>
        </table>
        <p>
          Since we are starting in the parts table, we can access the part
          number PNO directly. We then foreign-key hop, first in the reverse,
          one-to-many direction into the suppliers and parts table
          <code>SP</code>
          , and then in the many-to-one direction into the suppliers table
          to get the CITY column. This yields a partitioned column showing
          the city for each supplier that supplies that part. We can then
          use this to answer a myriad of questions. For example, what parts
          are supplied by suppliers located in Paris? Or what parts a supplied
          competitively, that is by two or more suppliers in the same city?
          This gives us the following table:
        </p>
        <table>
          <thead>
            <tr>
              <th class="left">PNO</th>
              <th class="left">SupplierIn</th>
              <th class="right">InParis</th>
              <th class="right">IsCompetition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="left">P1</td>
              <td class="left">[London,Paris]</td>
              <td class="right">1</td>
              <td class="right">0</td>
            </tr>
            <tr>
              <td class="left">P2</td>
              <td class="left">[London,Paris,Paris,London]</td>
              <td class="right">1</td>
              <td class="right">1</td>
            </tr>
            <tr>
              <td class="left">P3</td>
              <td class="left">[London]</td>
              <td class="right">0</td>
              <td class="right">0</td>
            </tr>
            <tr>
              <td class="left">P4</td>
              <td class="left">[London,London]</td>
              <td class="right">0</td>
              <td class="right">1</td>
            </tr>
            <tr>
              <td class="left">P5</td>
              <td class="left">[London,London]</td>
              <td class="right">0</td>
              <td class="right">1</td>
            </tr>
            <tr>
              <td class="left">P6</td>
              <td class="left">[London]</td>
              <td class="right">0</td>
              <td class="right">0</td>
            </tr>
          </tbody>
        </table>
        <p>
          Of course these last two Boolean expressions would most likely
          be placed in the
          <code>where</code>
          or
          <code>having</code>
          clause, we just show them here in the
          <code>select</code>
          clause for explanatory purposes.
        </p>
        <p>In Part 3 of this series we will look at additional ways to
        get data from other tables, using functions rather than column
        join syntax, that avoid the need to have formally specified keys.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/secret-santa">Secret Santa</a>
          </h1>
          <h2>December 12, 2022</h2>
        </header>
        <p>Every year I'm tasked with organizing a Secret Santa for the
        family. There is a very simple, manual technique for doing this
        by hand, with no need for a computer program and no need for a
        third party. The technique allows for the organizer to be a participant.
        However I can never remember what the technique is. Then I google
        it, and there are million hits for web sites that will do it, and
        a million techniques that require a trusted third party, or simple
        draw from a hat where you have to repeat if you draw your own name.
        If you toss a fancy word in the search like "algorithm", you will
        also get a bunch of technical articles on graph theory. Interesting,
        but not what I want.</p>
        <p>Here, then, is the easy way to do it, for Christmases future.</p>
        <p>First, take a sheet of paper and a pair of scissors and make
        up cards for each participant, where n is the number of people:</p>
        <pre>
          <code>          n←6
          c←'You are ' 'You get '∘.,⍕¨1+⍳n
          ]disp   ↑¨↓⍉c
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│You are 1│You are 2│You are 3│You are 4│You are 5│You are 6│
│You get 1│You get 2│You get 3│You get 4│You get 5│You get 6│
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
</code>
        </pre>
        <p>Then, shuffle the cards, keeping them face down, so you can't
        see them, and place them face down in a row on the table:</p>
        <pre>
          <code>        s←c[;n?n]
 ]disp   ↑¨↓⍉s
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│You are 6│You are 2│You are 5│You are 3│You are 1│You are 4│
│You get 6│You get 2│You get 5│You get 3│You get 1│You get 4│
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
</code>
        </pre>
        <p>Next, cut each card in half, shift the bottom halfs each to
        the right or left one position, and then tape the newly formed
        cards back together:</p>
        <pre>
          <code>      ]disp ↑¨↓⍉0 1⌽s
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│You are 6│You are 2│You are 5│You are 3│You are 1│You are 4│
│You get 2│You get 5│You get 3│You get 1│You get 4│You get 6│
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
</code>
        </pre>
        <p>Finally, throw the cards in a hat and have the participants
        each pick one. On a sheet of of paper with lines numbered 1 to
        n, have the participants write their names next to their numbers.
        Now the participants can see who they get.</p>
        <p>The only downside to this technique is that there is no possiblity
        of reciprocal giving; if you are giving to person #1, you know
        that person #1 is not giving to you. However, we may add back in
        one or more reciprocal pairs by simply removing two (or four, or
        six) cards and swapping the top and bottom parts of each pair.
        The remaining cards are then constructed using the above technique.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/parsing-markdown">Parsing Markdown</a>
          </h1>
          <h2>October 24, 2022</h2>
        </header>
        <p>
          Once we have an
          <a href="/posts/a-document-object-model-in-apl">APL document
          object model</a>
          , it is natural to want a Markdown to DOM function. While there
          are a zillion third party markdown libraries, none of them will
          create an APLDOM directly, and, more importantly, there are advantages
          to having an easily modified, pure APL, no-dependency solution.
        </p>
        <p>
          This
          <code>Parse</code>
          function takes an array of Markdown lines and returns an array
          of HTML elements:
        </p>
        <pre>
          <code>Parse←{
     ⍝ ⍵ ←→ MarkDown
     ⍝   ←→ Array of HTML obs
     ⍝ f ←→ Paragraph|Table|Code|Header
     0=≢⍵:''
     ⎕THIS.H←##.Main
     s←InitState ⍵
     t b←↓⍉↑s ProcessLine¨⍳≢⍵
     ~1∊b:''
     p←b⊆⍵
     f←(b&gt;¯1↓0,b)/t
     f{(⍎⍺)⍵}¨p
 }
</code>
        </pre>
        <p>It first initializes a namespace to hold the state as we step
        through each line:</p>
        <pre>
          <code>InitState←{
     s←⎕NS''
     s.Lines←⍵
     s.InParagraph←0
     s.InTable←0
     s.InCode←0
     s.InList←0
     s.InBlockQuote←0
     s.InPullQuote←0
     s
 }
</code>
        </pre>
        <p>We toss the entire set of lines in there as well, so we can
        inspect a subsequent line if necessary (for lists , if nothing
        else, it appears this is needed). Then we process each line, to
        determine the type and location of top-level objects or blocks:</p>
        <pre>
          <code>ProcessLine←{
     ⍝ ⍵ ←→ Line Number
     ⍝ ⍺ ←→ State
     ⍝   ←→ Partition Vector
     l←⍵⊃⍺.Lines
     ⍺.InParagraph:''(⍺.InParagraph←l≢'')
     ⍺.InCode:''(1⊣⍺.InCode←'~~~'≢3↑l)
     ⍺.InTable:''(⍺.InTable←'|'=⊃l)
     ⍺.InBlockQuote:''(⍺.InBlockQuote←'&gt; '≡2↑l)
     ⍺.InPullQuote:''(⍺.InPullQuote←'^ '≡2↑l)
     ⍺.InList:''(⍺.InList←⍺ StillInList ⍵)
     ''≡l:'' 0
     '~~~'≡3↑l:'Code'(⍺.InCode←1)
     '|'=⊃l:'Table'(⍺.InTable←1)
     '&gt; '≡2↑l:'BlockQuote'(⍺.InBlockQuote←1)
     '∧ '≡2↑l:'PullQuote'(⍺.InPullQuote←1)
     '#'=⊃l:'Header' 1
     '!'=⊃l:'Image' 1
     IsListItem l:'List'(⍺.InList←1)
     1:'Paragraph'(⍺.InParagraph←1)
 }
</code>
        </pre>
        <p>For each line, if we are not in an object already, we find out
        what object is starting, and return the type of the object and
        a 1 to indicate it is starting. If we are already in an object,
        then we determine whether the line being processed is still a member
        of that object. The object type is also the name of a function
        that will be called to convert the block of lines into an array
        of HTML element objects.</p>
        <p>Consider the following Markdown:</p>
        <pre>
          <code># MarkDown List                                         
                                                        
A list follows:                                         
                                                        
- Item 1                                                
    This is detail on item 1.                           
- Item 2                                                
    This is detail on item 2,                           
    and note there is no detail on the following item 3.
- Item 3                                                
                                                        
This is a trailing paragraph,                           
it should not be lost       
</code>
        </pre>
        <p>
          The result of
          <code>ProcessLine</code>
          tells us the type of object and flags the locations with 1-maps:
        </p>
        <pre>
          <code>      ↑s ProcessLine¨⍳≢⍵
 Header     1
            0
 Paragraph  1
            0
 List       1
            1
            1
            1
            1
            1
            0
 Paragraph  1
            1
</code>
        </pre>
        <p>
          Note that this partition technique requires a blank line between
          objects. Now we can apply the appropriate function to each partition.
          For example, the
          <code>Paragraph</code>
          function creates a new paragraph element object, and sets its
          content after adding any in-line markup:
        </p>
        <pre>
          <code>Paragraph←{
     l←1↓⊃,/' ',¨⍵
     H.New'p'(InLine l)
 }
</code>
        </pre>
        <p>
          While the
          <code>List</code>
          function, and its subfunction
          <code>ListItem</code>
          , creates a list element and must recursively parse the content:
        </p>
        <pre>
          <code>List←{
     t←↑⍵
     p←(' '≠t[;0])⊂⍵
     l←('-'∊t[;0])⊃'ol' 'ul'
     H.New l(ListItem¨p)
 }
ListItem←{
     t←{⍵↓⍨1+⍵⍳' '}⊃⍵
     i←H.New'li't
     1=≢⍵:i
     i.Content,←Parse 4↓¨1↓⍵
     i
 }
</code>
        </pre>
        <p>The code above is by no means a comprehensive markdown processor.
        Many features can and will be easily added, but we are generally
        not concerned with handling every little issue or variation that
        may be present in Markdown files out in the wild.</p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2022 Paul S. Mansour</p>
    </footer>
  </body>
</html>
