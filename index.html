<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/leetcode-262-trips-and-users">LeetCode 262:
            Trips and Users</a>
          </h1>
          <h2>June 26, 2022</h2>
        </header>
        <p>
          After
          <code>weightedAverage</code>
          , the single most import function contributing to the success
          of
          <em>The Carlisle Group</em>
          is
          <code>percentAcross</code>
          . Like
          <code>weightedAverage</code>
          , it is an aggregate function. Like
          <code>weightedAverage</code>
          , it is not complicated mathematically or difficult to implement.
          And like
          <code>weightedAverage</code>
          , you won't find it in Excel or SQL.
        </p>
        <p>It takes 2 to 3 arguments. The first argument is the primary
        numeric vector on which we are computing the percentage. The second
        argument is the boolean mask to abe applied to the numerator. The
        optional third argument is the denominator mask, which defaults
        to 1. The result is simply the quotient of the sums of the primary
        vector masked by the two booleans.</p>
        <p>A simple implementation might look like:</p>
        <pre>
          <code>percentAcross←{
     v n d←3↑⍵,1
     (+/v×n)÷+/v×d
 }
</code>
        </pre>
        <p>We call it "percentAcross" because in the context of a grouped
        query, its typical usage, it can produces percentages that are
        additive across the result table, as opposed to down the result
        table. Repeated calls with mutually exclusive booleans restricting
        the numerator are a poor man's cross-tab.</p>
        <p>Consider:</p>
        <pre>
          <code>      percentAcross (20 30 10 40) (0 1 0 1)
0.7
</code>
        </pre>
        <p>The 2nd and 4th item of the vector represent 70 percent of the
        total. We can restrict the denominator as well:</p>
        <pre>
          <code>      percentAcross (20 30 10 40) (0 1 0 1) (0 1 1 1)
0.875
</code>
        </pre>
        <p>The 2nd and 4th item represent 87.5% of the 2nd, 3rd, and 4th
        items.</p>
        <p>
          With this function in hand, let's tackle LeetCode 262:
          <a href="https://leetcode.com/problems/trips-and-users/">Trips
          and Users</a>
          . We are given two tables:
        </p>
        <pre>
          <code>      d←s.Get '/Databases/LeetCode262'
      d.Display 0
 ── LeetCode262.Users ────────────                                               
  ┌UsersID┐  ┌Banned─┐  ┌Roll───┐                                                
  ↓1      │  ↓No     │  ↓client │                                                
  │2      │  │Yes    │  │client │                                                
  │3      │  │No     │  │client │                                                
  │4      │  │No     │  │client │                                                
  │10     │  │No     │  │driver │                                                
  │11     │  │No     │  │driver │                                                
  │12     │  │No     │  │driver │                                                
  │13     │  │No     │  │driver │                                                
  └Int8───┘  └Char(3)┘  └Char(6)┘                                                
 ── 8 rows by 3 columns ──────────                                               
                                                                                 
 ── LeetCode262.Trips ────────────────────────────────────────────────────────── 
  ┌ID──┐  ┌ClientID┐  ┌DriverID┐  ┌CityID┐  ┌Status─────────────┐  ┌RequestAt─┐  
  ↓1   │  ↓1       │  ↓10      │  ↓1     │  ↓completed          │  ↓2013-10-01│  
  │2   │  │2       │  │11      │  │1     │  │cancelled by driver│  │2013-10-01│  
  │3   │  │3       │  │12      │  │6     │  │completed          │  │2013-10-01│  
  │4   │  │4       │  │13      │  │6     │  │cancelled by client│  │2013-10-01│  
  │5   │  │1       │  │10      │  │1     │  │completed          │  │2013-10-02│  
  │6   │  │2       │  │11      │  │6     │  │completed          │  │2013-10-02│  
  │7   │  │3       │  │12      │  │6     │  │completed          │  │2013-10-02│  
  │8   │  │2       │  │12      │  │12    │  │completed          │  │2013-10-03│  
  │9   │  │3       │  │10      │  │12    │  │completed          │  │2013-10-03│  
  │10  │  │4       │  │13      │  │12    │  │cancelled by client│  │2013-10-03│  
  └Int8┘  └Int8────┘  └Int8────┘  └Int8──┘  └Char(19)───────────┘  └Date──────┘  
 ── 10 rows by 6 columns ─────────────────────────────────────────────────────── 
</code>
        </pre>
        <p>The problem is:</p>
        <blockquote>
          <p>The cancellation rate is computed by dividing the number of
          canceled (by client or driver) requests with unbanned users by
          the total number of requests with unbanned users on that day.
          Write a SQL query to find the cancellation rate of requests with
          unbanned users (both client and driver must not be banned) each
          day between "2013-10-01" and "2013-10-03". Round Cancellation
          Rate to two decimal points. Return the result table in any order.</p>
        </blockquote>
        <p>Note that CityID and Roll columns of the given tables are not
        needed. Furthermore, the final restriction of the explicit dates
        does not add anything material to the problem in this particular
        case, or anything intesting in any case.</p>
        <p>Our query begins with the Trips table, selecting only those
        rows where neither the driver nor the client are banned:</p>
        <pre>
          <code>      t←d.GetTable 'Trips'
      q←t.Query''
      q.Where←'(ClientID.Banned in "No") and (DriverID.Banned in "No")'
</code>
        </pre>
        <p>ClientID and DriverID are foreign keys in the Trips table pointing
        to the Users table. Then we group and specify the cancellation
        rate adding a column to the select clause:</p>
        <pre>
          <code>      q.GroupBy←'RequestAt'
      _←q.AddColumn'CancellationRate' '2 round .01 * percentAcross Status (not Status in "completed")'
</code>
        </pre>
        <p>
          A production verison of
          <code>percentAcross</code>
          should operate on a character column, as it does here, to compute
          a percentage based on the row count. We need to move the decimal
          over because in FlipDB the
          <code>percentAcross</code>
          function naturally returns a percentage, not a ratio. And of
          course round it to 2 decmimal places. And now the result:
        </p>
        <pre>
          <code>     r←q.Execute 0                                                                        
     r.Display 0 
────────────────────────────────────────
 ┌RequestAt───────┐  ┌CancellationRate┐ 
 ↓2013-10-01      │  ↓0.33            │ 
 │2013-10-02      │  │0.00            │ 
 │2013-10-03      │  │0.50            │ 
 └Date────────────┘  └Dec(2)──────────┘ 
── 3 rows by 2 columns ─────────────────
</code>
        </pre>
        <p>
          An issue with this solution, however, is that the where clause
          might reduce the number of unique dates in the result, and will
          almost certainly, as it does in this case, reduce the rows processed
          by the grouping clause. We can move the where clause into the
          select clause by taking advantage of the
          <code>percentAcross</code>
          function's ability to restrict the data in both the numerator
          and the denominator. We use a couple of temporay results to keep
          it clear and clean:
        </p>
        <pre>
          <code>      q←t.Query''
      q.GroupBy←'RequestAt'
      _←q.AddColumn'Unbanned' '(ClientID.Banned in "No") and (DriverID.Banned in "No")' 1
      _←q.AddColumn'Cancelled' 'not Status in "completed"' 1
      _←q.AddColumn'CancellationRate' '2 round .01 * percentAcross Status (Unbanned and Cancelled) Unbanned'
      r←q.Execute 0
      r.Display 0
────────────────────────────────────────
 ┌RequestAt───────┐  ┌CancellationRate┐ 
 ↓2013-10-01      │  ↓0.33            │ 
 │2013-10-02      │  │0.00            │ 
 │2013-10-03      │  │0.50            │ 
 └Date────────────┘  └Dec(2)──────────┘ 
── 3 rows by 2 columns ─────────────────
</code>
        </pre>
        <p>
          The
          <code>percentAcross</code>
          function is simple yet extremely useful. For grouped queries,
          it answers the question, what percentage of X is in group Y.
          It's more general than a cross-tab, because the boolean statements
          may refer to any number of columns and group the horizontal axis
          in arbitrary ways.
        </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/leetcode-185">LeetCode 185: Department Top
            Three Salaries</a>
          </h1>
          <h2>June 25, 2022</h2>
        </header>
        <p>
          Let's solve LeetCode 185, the
          <a href="https://leetcode.com/problems/department-top-three-salaries/">Department
          Top Three Salaries</a>
          problem, in FlipDB, our array-oriented, APL-based DSL. We will
          use FlipDB directly in the APL session.
        </p>
        <p>We are given two tables, a department table and an employee
        table:</p>
        <pre>
          <code>      d←s.Get '/Databases/LeetCode185'
      d.Display 0
 ── LeetCode185.Department                       
  ┌ID──┐  ┌Name───┐                            
  ↓1   │  ↓IT     │                            
  │2   │  │Sales  │                            
  └Int8┘  └Char(5)┘                            
 ── 2 rows by 2 columns                        
                                               
 ── LeetCode185.Employee ───────────────────── 
  ┌ID──┐  ┌Name───┐  ┌Salary┐  ┌DepartmentID┐  
  ↓1   │  ↓Joe    │  ↓85,000│  ↓1           │  
  │2   │  │Henry  │  │80,000│  │2           │  
  │3   │  │Sam    │  │60,000│  │2           │  
  │4   │  │Max    │  │90,000│  │1           │  
  │5   │  │Janet  │  │69,000│  │1           │  
  │6   │  │Randy  │  │85,000│  │1           │  
  │7   │  │Will   │  │70,000│  │1           │  
  └Int8┘  └Char(5)┘  └Int32─┘  └Int8────────┘  
 ── 7 rows by 4 columns ────────────────────── 
</code>
        </pre>
        <p>The problem is:</p>
        <blockquote>
          <p>A company's executives are interested in seeing who earns
          the most money in each of the company's departments. A high earner
          in a department is an employee who has a salary in the top three
          unique salaries for that department. Write an SQL query to find
          the employees who are high earners in each of the departments.</p>
        </blockquote>
        <p>The Department table does not add anything to the problem. It
        simply gives a nice description for each department, and we can
        dispense with it.</p>
        <p>We create a new query on the Employee table:</p>
        <pre>
          <code>      t←d.GetTable 'Employee'
      q←t.Query '' 
</code>
        </pre>
        <p>
          The task is simply to select some rows. There is no computation
          or aggregation required in the result, so the only thing we need
          to specify is a where clause, making use of the
          <strong>rankDown</strong>
          function:
        </p>
        <pre>
          <code>      q.Where←'3 &gt; 1 rankDown by Salary (group DepartmentID)'
      r←q.Execute 0
      r.Display 0
── Key:ID ───────────────────────────────────
 ┌ID──┐  ┌Name───┐  ┌Salary┐  ┌DepartmentID┐ 
 ↓1   │  ↓Joe    │  ↓85,000│  ↓1           │ 
 │2   │  │Henry  │  │80,000│  │2           │ 
 │3   │  │Sam    │  │60,000│  │2           │ 
 │4   │  │Max    │  │90,000│  │1           │ 
 │6   │  │Randy  │  │85,000│  │1           │ 
 │7   │  │Will   │  │70,000│  │1           │ 
 └Int8┘  └Char(5)┘  └Int32─┘  └Int8────────┘ 
── 6 rows by 4 columns ──────────────────────
</code>
        </pre>
        <p>
          Note first that the
          <code>rankDown</code>
          function is in
          <code>⎕IO←0</code>
          , so we are selecting salaries ranked 0, 1, or 2. Note further
          that
          <code>rankDown</code>
          takes a left argument of 0 1 or 2, for rank, dense rank, and
          average rank, respectively, so in this case we are applying dense
          rank. Finally note that
          <code>rankDown</code>
          is passed to the
          <code>by</code>
          operator to apply it within each department.
        </p>
        <p>We can pick apart this where clause expression and see how it
        works, right in the APL session:</p>
        <pre>
          <code>        disp←{⍵.Display 0}
        Salary←85 80 60 90 69 85 70
        Department←1 2 2 1 1 1 1
</code>
        </pre>
        <p>
          The
          <code>group</code>
          function returns the indices for each unique value:
        </p>
        <pre>
          <code>        disp group Department
┌───────────┐
↓[0,3,4,5,6]│
│[1,2]      │
└Int8───────┘
</code>
        </pre>
        <p>
          The
          <code>rankDown</code>
          function, with a left argument of 1 for dense, applied to Salary
          directly:
        </p>
        <pre>
          <code>       disp 1 rankDown Salary
┌────┐
↓1   │
│2   │
│5   │
│0   │
│4   │
│1   │
│3   │
└Int8┘
</code>
        </pre>
        <p>
          And now applied via the
          <code>by</code>
          operator, so that we rank within each group:
        </p>
        <pre>
          <code>        disp 1 rankDown by Salary (group Department)
┌────┐
↓1   │
│0   │
│1   │
│0   │
│3   │
│1   │
│2   │
└Int8┘
</code>
        </pre>
        <p>
          The
          <code>by</code>
          operator groups the data and applies its operand function to
          each group, and then ungroups the data, restoring it to its original
          order. It is particularly useful with uniform functions like
          <code>rankDown</code>
          , but it is also useful with aggregate and structural functions.
        </p>
        <p>Finally we flag the top 3 ranks:</p>
        <pre>
          <code>      disp 3 gt 1 rankDown by Salary(group Department)
┌───────┐
↓1      │
│1      │
│1      │
│1      │
│0      │
│1      │
│1      │
└Boolean┘
</code>
        </pre>
        <h3>Design Issue</h3>
        <p>
          There is a tradeoff when designing a DSL, between more functions
          with fewer arguments, and fewer functions with more arguments.
          In the case of rank, FlipDB currently has two functions,
          <code>rankUp</code>
          and
          <code>rankDown</code>
          , each taking three potential values as a left argument for an
          effective total combination of 6 functions:
        </p>
        <pre>
          <code>rankUp
rankDown
denseRankUp
denseRankDown
averageRankUp
averageRankDown
</code>
        </pre>
        <p>
          We could of course have only one function,
          <code>rank</code>
          , and provide yet another argument for the direction. The idea
          behind building in the ordering into the name was to make it
          similar to the related APL primitives
          <code>grade up</code>
          and
          <code>grade down</code>
          . Two functions seemed good, 6 functions seemed overkill at the
          time, but I'm reconsidering. It would be easier to read
          <code>denseRankDown Salary</code>
          than
          <code>1 rankDown Salary</code>
          . The latter requires a trip to the documentation, while the
          former is discoverable with autocomplete.
        </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/operators-in-a-dsl">Operators in a DSL</a>
          </h1>
          <h2>May 28, 2022</h2>
        </header>
        <p>When designing a number-crunching domain specific language (DSL)
        in Dyalog APL we have the luxury of using operators. This immediately
        presents many design issues. Operators decrease the number of functions
        in the DSL, reducing overall size and complexity. At the same time,
        operators increase the complexity of composing an individual expression
        by introducing more moving parts.</p>
        <blockquote>
          <p>
            Note
            <code>⎕IO←0</code>
            and
            <code>⎕ML←1</code>
            throughout. In addition, all functions and operators defined
            below are simplified and unoptimized versions of production
            code.
          </p>
        </blockquote>
        <p>
          Consider providing a
          <code>maximum</code>
          function and a
          <code>reduce</code>
          operator in the DSL as direct covers of their APL counterparts:
        </p>
        <pre>
          <code>      maximum←{⍺⌈⍵}
      reduce←{⍺⍺/⍵}
</code>
        </pre>
        <p>No end-user wants to think or type:</p>
        <pre>
          <code>      maximum reduce StockPrice
</code>
        </pre>
        <p>when he could type:</p>
        <pre>
          <code>      max StockPrice
</code>
        </pre>
        <p>
          which one can do in say, SQL. So instead we provide the aggregate
          functions like
          <code>sum</code>
          and
          <code>max</code>
          in addition to their scalar counterparts:
        </p>
        <pre>
          <code>      sum←{+/⍵}
      max←{⌈/⍵}
</code>
        </pre>
        <p>As noted, fewer operators make more functions. However, many
        if not most of the primitive arithmetic and boolean reductions
        are so commonly used that they have useful and well-known names
        like sum, min, max, any, all, etc. In addition, there are many
        more common aggregate functions like average and variance that
        are not primitive scalar reductions and these would need to be
        provided directly as functions anyway. So this is an easy decision;
        the trade-off of more functions and fewer operators in this case
        is well worth it.</p>
        <p>
          Now let's take the next step: running aggregates. Again, we have
          the option of providing a single operator or an additional set
          of functions. In APL we use the scan operator with a scalar function
          for this. However, in our DSL, once we have named aggregate functions
          like
          <code>sum</code>
          and
          <code>max</code>
          , it makes sense to use the aggregate function as the operand
          rather than the scalar function on which the aggregate is based,
          so we might define a
          <code>running</code>
          operator as:
        </p>
        <pre>
          <code>      running←{
          h←⊃61 ⎕ATX'⍺⍺'
          f←{⍵↑⍨⍵⍳'←'}1↓h
          f≡'sum':+\⍵
          f≡'max':⌈\⍵
          ⍺⍺¨,\⍵
      }
</code>
        </pre>
        <p>
          Here the choice is more open for debate, but I think it is still
          clearly in favor of the operator, especially considering that
          moving statistics could be handled by just giving a left argument
          to the running operator. Now a single operator is reducing the
          need for a lot of functions that will have awkward names and
          that will not get called very often. Kx Systems took the opposite
          approach with q, but I can only imagine there was no choice,
          as k does not support user-defined operators. The proliferation
          of functions and the difficulty naming them
          <a href="https://code.kx.com/q/ref/sum/">is immediately apparent.</a>
        </p>
        <p>
          The derived function
          <code>sum running</code>
          is an example of a
          <strong>uniform</strong>
          function - a function that returns a result that is the same
          shape as its argument. The result of a uniform function generally
          depends on the totality of the items in the array - both the
          existence and the ordering of the items. This feature distinguishes
          them from scalar functions. There are many uniform functions
          that are not derived functions. Prime examples in APL are grade
          up (
          <code>⍋</code>
          ) and grade down
          <code>(⍒)</code>
          , rotate
          <code>(⌽)</code>
          and first occurrence (monadic
          <code>≠</code>
          ). A DSL may have many more like
          <code>lag</code>
          and
          <code>lead</code>
          :
        </p>
        <pre>
          <code>      lag←{
           ¯1↓0,⍵
       }
      lead←{
          1↓⍵,0
       } 
</code>
        </pre>
        <p>
          Uniform functions lend themselves to being applied to an argument
          that is conceptually grouped and or ordered. Yet again we are
          faced with the choice of an operator or a plethora of additional
          functions- functions that are even more awkward to name, and
          that require a lot of arguments. In this case there is simply
          no contest. Going the route of additional functions is
          <a href="https://docs.1010data.com/1010dataReferenceManual/Functions/GroupFunctions/Group.html">not
          pretty.</a>
          Let's define an operator
          <code>by</code>
          with the following syntax:
        </p>
        <pre>
          <code>      R←[X] F by Y I [B]     
</code>
        </pre>
        <p>
          Here
          <code>F</code>
          is any uniform (or aggregate - more on this later) function.
          <code>Y</code>
          is a suitable right argument for
          <code>F</code>
          , and
          <code>X</code>
          is an optional left argument for
          <code>F</code>
          .
          <code>I</code>
          is a grade vector that orders
          <code>Y</code>
          , or a set of grade vectors that groups and optionally orders
          <code>Y</code>
          .
          <code>B</code>
          is an optional boolean selection vector that flags items to include
          and exclude in the computation.
        </p>
        <p>
          The
          <code>by</code>
          operator sorts and groups
          <code>Y</code>
          according to
          <code>I</code>
          , (optionally selecting by
          <code>B</code>
          ), applies
          <code>F</code>
          to each group, and then ungroups and reorders the results to
          correspond to the original argument
          <code>Y</code>
          . This is similar to the under
          <a href="https://aplwiki.com/wiki/Under">operator</a>
          , but I don't think it can handle this particular case.
        </p>
        <p>Sorting and grouping is provided by grade vectors rather than
        providing corresponding values on which to sort and group for the
        same reason sorting in APL is a two-step process with grade up
        and grade down. In addition we extract some complexity from the
        by operator by computing I beforehand using grouping and sorting
        functions.</p>
        <p>
          Let's define
          <code>by</code>
          as follows:
        </p>
        <pre>
          <code>by←{
     ⍺←⊣
     a i b←3↑⍵,⊂1⍴⍨≢⊃⍵
     g←{⍺{⍵⌷⍨⊂⍺}¨⊂⍵}
     (pa pb)←(⊆i)∘g¨a b
     sa←pb/¨pa
     r←⍺ ⍺⍺¨sa
     af←1=≡r
     ua←2=≢61 ⎕ATX'⍺⍺'
     ff←af∨ua
     z←(~⊃¨pb)∧~af
     (⊃¨pb)←1
     e←({|2-/⍸⍵,1}¨⍣ff)pb
     v←∊e\¨r,¨⍨z/¨0
     v[⍋∊i]
 }
</code>
        </pre>
        <p>Now we can do a running sum from lowest to highest:</p>
        <pre>
          <code>      A←100 2 1 8 12
      sum running by A (⍋A)
123 3 1 11 23
</code>
        </pre>
        <p>In other words, for each item, find the sum of it and all items
        less than it. Let's also define a grouping function that can optionally
        take a grade vector as its left argument:</p>
        <pre>
          <code>group←{
     ⍺←⍳≢⍵
     i←{↓⍵}⌸⍵[⍺]
     ⍺∘{⍺[⍵]}¨i
 }
</code>
        </pre>
        <p>And some more data to play around with:</p>
        <pre>
          <code>      RowId←1+⍳10
      Account←1 2 3 3 1 2 1 1 1 2
      Payment←8 3 5 4 2 7 1 9 6 10
      Day←31 1 9 5 14 27 22 17 3 11
      M←⍉↑RowId Account Payment Day
      M
 1 1  8 31
 2 2  3  1
 3 3  5  9
 4 3  4  5
 5 1  2 14
 6 2  7 27
 7 1  1 22
 8 1  9 17
 9 1  6  3
10 2 10 11
</code>
        </pre>
        <p>To round out our little DSL, let's also cover grade up:</p>
        <pre>
          <code>orderUp←{
     ⍋⍵
 }
</code>
        </pre>
        <p>Now we can compute a running sum of payments by account:</p>
        <pre>
          <code>      M,sum running by Payment (group Account)
 1 1  8 31  8
 2 2  3  1  3
 3 3  5  9  5
 4 3  4  5  9
 5 1  2 14 10
 6 2  7 27 10
 7 1  1 22 11
 8 1  9 17 20
 9 1  6  3 26
10 2 10 11 20
</code>
        </pre>
        <p>It is often useful to compute and save the ordering and grouping.
        So to find the ordered running sum of payments by account:</p>
        <pre>
          <code>      G←(orderUp Day) group Account
      M,sum running by Payment G
 1 1  8 31 26
 2 2  3  1  3
 3 3  5  9  9
 4 3  4  5  4
 5 1  2 14  8
 6 2  7 27 20
 7 1  1 22 18
 8 1  9 17 17
 9 1  6  3  6
10 2 10 11 13
</code>
        </pre>
        <p>And to find the previous payment for each day by account:</p>
        <pre>
          <code>      M,lag by Payment G
 1 1  8 31  1
 2 2  3  1  0
 3 3  5  9  4
 4 3  4  5  0
 5 1  2 14  6
 6 2  7 27 10
 7 1  1 22  9
 8 1  9 17  2
 9 1  6  3  0
10 2 10 11  3
</code>
        </pre>
        <p>
          The
          <code>by</code>
          operator is useful not only with uniform functions, but with
          aggregate functions as well. The result of the aggregate function
          on each group is replicated to line up with the original argument:
        </p>
        <pre>
          <code>      M,sum by Payment (group Account)
 1 1  8 31 26
 2 2  3  1 20
 3 3  5  9  9
 4 3  4  5  9
 5 1  2 14 26
 6 2  7 27 20
 7 1  1 22 26
 8 1  9 17 26
 9 1  6  3 26
10 2 10 11 20
</code>
        </pre>
        <p>And we can apply a boolean selection as well:</p>
        <pre>
          <code>      M,sum by Payment (group Account) (Day&lt;15)
 1 1  8 31  8
 2 2  3  1 13
 3 3  5  9  9
 4 3  4  5  9
 5 1  2 14  8
 6 2  7 27 13
 7 1  1 22  8
 8 1  9 17  8
 9 1  6  3  8
10 2 10 11 13
</code>
        </pre>
        <p>There is a balancing act with respect to operators and functions.
        This is similar to the balancing act of fewer functions with more
        arguments, versus more functions and fewer arguments. Overuse of
        operators can make individual expressions and discovery difficult.
        Underuse can lead to a proliferation of badly named and rarely
        used functions that have too many arguments.</p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2022 Paul S. Mansour</p>
    </footer>
  </body>
</html>
