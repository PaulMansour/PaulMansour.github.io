<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <h3>"You don't know how bad your code is until you write about it."</h3>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/modal-dialog-boxes-progressbar">Modal Dialog
            Boxes 4: ProgressBar</a>
          </h1>
          <h2>May 14, 2024</h2>
        </header>
        <p>Implementing a general purpose, easy-to-use progress bar presents some challenges. Let's look at an attempt. The Abacus <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/ProgressBar">ProgressBar</a> is designed to handle  iterative processes where the number of iterations may or may not be known ahead of time. In either case, we want to provide some feedback on each iteration as well as the ability to cancel the process.</p>
        <p>Rather than providing a <em>Cancel</em> button on the progess bar element, which would arguably require an "are-you-sure" confirmation, we provide a <em>Pause</em> button, which  pauses the operation between two iterations. This gives us the opportunity to add a bit more functionality, without additional complexity in the UI.  When <em>Pause</em> is clicked, the user is then offered two choices, <em>Cancel</em> and <em>Resume</em>, and optionally a 3rd choice: <em>Truncate</em>.  The <em>Cancel</em> option cancels the entire operation without further ado. The <em>Resume</em> option restarts the process at the next iteration. The <em>Truncate</em> option treats the last completed iteration as the final iteration and continues the operation. It simply ignores and does not process the remaining iterations. This option is only relevant for certain types of operations. For example, when importing a CSV file, the user may decide that reading a few million rows from a large file is sufficient for his purposes.</p>
        <p>The progress bar is implemented with a monadic operator, <code>Run</code>. This operator  puts up a progress element with a <em>Pause</em> button, runs the iterations, allows the user to cancel the operation, and provides a useful result when control returns to the calling function. Here is the syntax:  </p>
        <pre><code>      R←Y F ProgressBar.Run X
</code></pre>
        <p>The left argument <code>Y</code> is the document object. The left operand <code>F</code> is a function that implements the looping task at hand. <code>X</code> is a namespace provided as a right argument to <code>F</code>. </p>
        <p>The namespace <code>X</code> must contain 3 properties: <code>Caption</code>, <code>Iterator</code> and <code>Status</code>. The <code>Caption</code> is a string specifying the title of the progress bar dialog box. The <code>Iterator</code> property is a vector. If the iteration vector is empty, the process is deemed <em>indeterminate</em>. We don't know how many iterations there may be. Otherwise the length of <code>Iterator</code> is the number of iterations, known ahead of time, and the process is deemed <em>determinate</em>. In the determinate case, the <code>Status</code> property is a vector of char vectors the same length as <code>Iterator</code>. In the indeterminate case, <code>Status</code> is a simple vector that should be reset inside <code>F</code> on every iteration.   </p>
        <p>The namespace <code>X</code> may, and often will, contain all sorts of other variables and references that are needed to support the execution of <code>F</code>. </p>
        <p>The iteration vector may be an array of any type of values. Associated with the iteration values are iterations numbers, given by <code>⍳≢X.Iterator</code>. For the determinate case, the iteration <em>number</em> (not the value) is provided as the left argument to <code>F</code>. </p>
        <p>In the indeterminate case the result of <code>F</code> is a return code of <code>0</code> if another iteration is required, or <code>1</code> if it is not. There is no other return value. Data accumulation is accomplished by either writing to file or by accumulating an array inside <code>X</code>. In the determinate case, the result of <code>F</code> may be any useful value. </p>
        <p>The result <code>R</code> (of <code>ProgressBar.Run</code>) is a scaler for the indeterminate case, and a two item vector for the determinate case. In both cases the first element of <code>R</code> is <code>0</code> if all itererations are executed, <code>1</code> if cancelled, and <code>2</code> if truncated. For determinate processes, the second element is an array of the result of each call to <code>F</code>.</p>
        <p>Let's go to the code:</p>
        <pre><code>Run←{
     p←New ⍵.Caption ⍵.Iterator
     _←⍺ A.ShowModal p
     op←⍎(0=≢⍵.Iterator)⊃'Determinate' 'Indeterminate'
     r←p ⍺⍺ op ⍵
     r⊣A.DeleteElement p
 }
</code></pre>
        <p>In the <code>Run</code> operator, the first thing we do is create the dialog element (<code>New</code>) and display it (<code>ShowModal</code>). Next we have to pick the appropriate sub-operator. The techniques are different for the two cases. For the determinate case, we use the <code>each</code> operator (<code>¨</code>) to execute iteration:</p>
        <pre><code>Determinate←{
     b r←↓⍉↑(⊂⍺ ⍵)⍺⍺{
         p w←⍺
         p.Cancel:1 0
         c←p Pause 0
         c≡'Cancel':1 0⊣p.Cancel←1
         c≡'Truncate':2 0⊣p.Cancel←1
         _←p Update ⍵⊃w.Status
         r←⍵ ⍺⍺ w
         0 r
     }¨⍳≢⍺.Iterator
     (⌈/b)(r/⍨b=0)
 }
</code></pre>
        <p>First we check if <em>Cancel</em> has been previously pressed. If so, there is nothing to do, and we get out. (Note that we always run the inner function N times if there are N iterations, even if the user has canceled). Next we run the <code>Pause</code> function to see if the user has pressed <em>Pause</em>:</p>
        <pre><code>Pause←{
     ~⍺.Pause:'Resume'
     ⍺.Pause←0
     t←'Process paused'
     c←''
     b←'Cancel' 'Resume' 'Truncate'
     ⍺.Document A.ConfirmBox.Show t c b
 }
</code></pre>
        <p>If the user has not clicked <em>Pause</em>, we exit, resuming the iterations. If the user has pressed Pause, we put a confirmation box and wait. Back in the <code>Determinate</code> operator we inspect what the user has selected in the confirmation box, exiting if <em>Cancel</em> or <em>Truncate</em>. Otherwise we update the status and execute the iteration function, the left operand of <code>Run</code>.</p>
        <p>The indeterminate operator is a bit simpler (hmm, why is that?):</p>
        <pre><code>Indeterminate←{
     _←⍺ Update ⍵.Status
     c←⍺ Pause ⍵
     c≡'Cancel':1
     c≡'Truncate':2
     ⍺⍺ ⍵:0
     ⍺ ∇ ⍵
 }
</code></pre>
        <p>Here we update the status before checking if the user clicked <em>Pause</em>. This is because in the indeterminate case, the status of an iteration is known after the iteration completes, while in the determinate case the status is known before the iteration is executed - usually. We check for `<em>Pause</em> etc., just as in the determinate case. We then run the iteration function, exiting if it returns a <code>1</code>, and continuing on to the next iteration via recursion otherwise.</p>
        <p>Regardless of the iteration technique, be it looping, recursion, or the each operator, the fact that the argument to <code>F</code> is a namespace allows us to easily maintain and update state, and accumulate results, between iterations.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/uncle-bob-and-the-primeagen">Uncle Bob and
            The Primeagen</a>
          </h1>
          <h2>May 7, 2024</h2>
        </header>
        <p>Recently the genial Robert "Uncle Bob" Martin sat down with the always entertaining Primeagen for an <a href="https://www.youtube.com/watch?v=UBXXw2JSloo">interview</a>.  Given The Primeagen's well-known aversion to TDD and short functions, it was bound to be a spirited conversation, and indeed it was.</p>
        <p>I'm fully sympathetic to the idea that it's hard and often counterproductive (if not impossible) to do full TDD on a new project.  What I don't get is The Primeagen's gripe about 100% code coverage. He asks Uncle Bob about testing the summing of the elements of an array. Uncle Bob explains that he would not write a specific test for that, but that the code would be tested indirectly; there would be a test on a method or function that  has the line that sums the array. Or even a test higher up the stack. But the line would get executed in the test suite somewhere. In the interview, the Primeagen doesn't seem to understand that.  </p>
        <p>In response to The Primeagen's repeated questions about "what to test", Uncle Bob brings up Kent Beck: test anything and everything that can break. In APL, that's pretty much every line of every function. I assume a similar situation in any interpreted language.</p>
        <p>Consider the line: </p>
        <pre><code>      c←a+b
</code></pre>
        <p>This can fail in at least 5 different ways, including <code>VALUE ERROR</code>, <code>DOMAIN ERROR</code>, <code>RANK ERROR</code>, and <code>LENGTH ERROR</code>.  Heck, consider:</p>
        <pre><code>      v←1   
</code></pre>
        <p>This line can fail!</p>
        <p>Now, as Uncle Bob points out, it would be silly to write a test for every line of code. But every line of code should be executed in the tests, because every line of code can break. There is no excuse for less than 100% code coverage. </p>
        <p>Please note that I have written a lot of code that has a lot less than 100% coverage, even 0% coverage, and I have no excuse.  </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/modal-dialog-boxes-prompt">Modal Dialog Boxes
            3: Prompt</a>
          </h1>
          <h2>May 6, 2024</h2>
        </header>
        <p>The Abacus <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/PromptBox">PromptBox</a>  component allows the user to enter a string, and then select <code>OK</code> or <code>Cancel</code>. This dialog behaves like the  <code>AlertBox</code> dialog as opposed to the <code>ConfirmBox</code> dialog; it does not suspend or wait. It takes action via a handler function attached to the <code>OK</code> button. Let's go to the code:</p>
        <pre><code>Show←{
     ⍺ ##.ShowModal New ⍵
 }
  New←{
     ⍝ ⍵ ←→ Title, Label, Value, OKHandler
     ⍝ ← ←→ new dialog element
     tv lv iv cb←⍵
     d←A.New'dialog'
     d.class←'prompt-box'
     d.OnOK←cb
     h1←d A.New'h1'tv
     l←d A.New'label'lv
     i←d A.New'input'
     i.id←'Prompt'
     i.value←iv
     i.Oninput←A.FQP'OnInput'
     m←d A.New'menu'
     b←m A.New¨{'button'⍵}¨'OK' 'Cancel'
     b.id←'OK' 'Cancel'
     b.Onclick←A.FQP¨'OnOK' 'OnCancel'
     d
 }
 OnInput←{
     i←⍵.CurrentTarget
     i.value←⍵.Value
     0
 }
 OnOK←{
     t←⍵.CurrentTarget
     d←t A.GetNearest'dialog'
     i←d A.ElementByTag'input'
     v←i.value
     f←⍎d.OnOK
     r←⍵.Document f v
     r:0
     A.DeleteElement d
 }
 OnCancel←{
     d←⍵.CurrentTarget A.GetNearest'dialog'
     ##.DeleteElement d
 }
</code></pre>
        <p>The <code>OnOK</code> function covers the handler supplied as an argument to <code>Show</code>. If the supplied handler returns  a <code>0</code>, it is considered a success, and the prompt box is deleted. If it returns a <code>1</code>, it is considered a failure and the prompt box is left up for the user to interact with.</p>
        <p>The prompt box functionality could be implemented to wait and suspend the calling APL function, just like we do with <code>ConfirmBox</code>, but there is generally no need to maintain state, and suspending the calling function is more complex and makes testing more difficult. The same is true for more general dialog boxes, with many more controls. It is better to have callback or handler functions to take action rather than inspecting the result of a <code>Show</code> function to see what action to take.  </p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2024 Paul S. Mansour</p>
    </footer>
  </body>
</html>
