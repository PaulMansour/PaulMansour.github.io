<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><link href="/ThorntonMelon.css" rel="stylesheet"></link></head><body><header><h1>Tool of Thought</h1><h2>APL for the Practical Man</h2><h3>"Don't chase tech. Chase fun." - Gunpei Yokoi</h3><nav><a href="/">Home</a><a href="/posts">Posts</a><a href="/projects">Projects</a><a href="/donts">Don'ts</a><a href="/links">Links</a><a href="/about">About</a></nav></header><main><article><header><h1><a href="/posts/the-panels-component">The Panels Component</a></h1><h2>November 14, 2025</h2></header><p>The Abacus <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/Panels">Panels component</a> provides a way to layout content. We have two main goals for this component. First, we want to easily layout multiple components or elements with a minimum of fuss. For example, we may want to neatly place 3 components, one on the top and two below. Second, we may want to have a primary component (or two) that is always visible and then a side panel (or two, or three) that can be visible or invisble. Most UI frameworks that have a panels component allow only two panels, but each panel can of course be divided again into two panels. This is sort of the way splitters work in <code>⎕WC</code>. We have taken a different approach.</p><p>We use <a href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/CSS_layout/Grids">CSS grid</a> and one look at the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/grid-template-areas">grid-template-areas</a> property should tell you how nice a fit it is for the new <a href="https://docs.dyalog.com/20.0/programming-reference-guide/introduction/arrays/array-notation/">array notation</a> in Dyalog v20.</p><p>For example: </p><pre><code>     ...
     l←[
         0 0
         1 2
         3 3
     ]
     p←A.Panels.New ('Content' c) ('GridTemplateRows' l)        
</code></pre><p>There are four components or elements in the content <code>c</code>. This instructs Abacus to layout the first element across the entire parent component, the place the next two elements below that, in equal proportion, and finally the last component all the way across the bottom.</p><p>The values in <code>l</code> are simply indices into <code>c</code>, but we could use HTML ids as well. We can change the proportions of the components by changing <code>l</code>:</p><pre><code>     l←[
         0 0 0 0
         1 1 1 2
         3 3 3 3
     ]
</code></pre><p>Consider a case of two components, a main component and a right-hand sidebar that should only be visible on demand.  On startup the <code>GridTemplateAreas</code> is:</p><pre><code>      [
        0
      ]
</code></pre><p>(or simply <code>⍪0</code>) a 1 by 1 matrix. This indicates that the main component should take up all of the space. When the side bar is reqested we reset it to:</p><pre><code>      [
        0 0 0 1
      ]
</code></pre><p>This makes the sidebar visible, and gives it 25% of the available space, shrinking the main component to 75% of the available space.</p><p>Panels can be resized, if desired and applicable, using keyboard shortcuts for now. At some point we will allow resizing via the mouse.</p></article><article><header><h1><a href="/posts/variation-on-iota">Variation on Iota</a></h1><h2>November 12, 2025</h2></header><blockquote><p>Several updates below!</p></blockquote><p>We just encountered the following real-life problem, which oddly, if memory serves, we have never encountered before: Given a list of items, find the location of each item in a list of lists of items. An example will make it clear:</p><pre><code>      a← 'abc' 'de' '' 'fgha'
      w←'hafxd'
      a {...} w
3 0 3 4 1
</code></pre><p>So, it's just like <a href="https://docs.dyalog.com/20.0/language-reference-guide/primitive-functions/index-of/">Index Of</a> (<code>⍳</code>), only we are looking a level deeper on the left for the  existence of an item on the right. We are not concerned where in the sublist on the left the item on the right is found. It is simply the location of the sublist (where the item is found) within the main list.   </p><p>Our first inclination is to flatten out <code>a</code>, and then lookup items in <code>w</code> in the new flat array:</p><pre><code>      ⊃,/a
abcdefgha
      (⊃,/a)⍳w
7 0 5 9 3
</code></pre><blockquote><p>Update: We should have noted that the items that we are dealing with might not be scaler, thus we must use <code>⊃,/</code> rather than simply <code>∊</code>.    </p></blockquote><p>Then we need to map these indices, which index into the flattened array, back to indices apropriate for the original nested array, which are given by:</p><pre><code>        ⍳≢a
0 1 2 3
</code></pre><p>We can do this by counting the items in each sublist:</p><pre><code>      ≢¨a
3 2 0 4
</code></pre><p>And then replicating:</p><pre><code>      (≢¨a)/⍳≢a
0 0 0 1 1 3 3 3 3
</code></pre><p>Now we can map the first set of indices into the second set of indices to get the desired indices:</p><pre><code>      (⊂(⊃,/a)⍳w)⌷(≢¨a)/⍳≢a
INDEX ERROR
</code></pre><p>Oops, we need one more index for things not found:</p><pre><code>      (1,⍨≢¨a)/⍳1+≢a
0 0 0 1 1 3 3 3 3 4
</code></pre><p>And now, with a little code golf to remove a set of parentheses:</p><pre><code>     (⊂w⍳⍨⊃,/a)⌷(1,⍨≢¨a)/⍳1+≢a
3 0 3 4 1
</code></pre><p>Bingo, we are done. Let's make it a dfn:</p><pre><code>      liota←{(⊂⍵⍳⍨⊃,/⍺)⌷(1,⍨≢¨⍺)/⍳1+≢⍺}
</code></pre><p>Now let's try a completely different approach. Consider the <a href="https://docs.dyalog.com/20.0/language-reference-guide/primitive-operators/outer-product/">outer product</a>  of <a href="https://docs.dyalog.com/20.0/language-reference-guide/primitive-functions/membership/">membership</a> (<code>∊</code>):</p><pre><code>      w∘.∊a
0 0 0 1
1 0 0 1
0 0 0 1
0 0 0 0
0 1 0 0
</code></pre><p>If we look for the first occurance of a <code>1</code> in each row we get our answer:</p><pre><code>      (↓w∘.∊a)⍳¨1
3 0 3 4 1
</code></pre><p>And a little golf:</p><pre><code>      1⍳⍨¨↓w∘.∊a
3 0 3 4 1
</code></pre><p>For what it is worth, we can get rid of nesting the Boolean matrix and the  <a href="https://docs.dyalog.com/20.0/language-reference-guide/primitive-operators/each/each-with-monadic-operand/">each operator</a> by using the <a href="https://docs.dyalog.com/20.0/language-reference-guide/primitive-operators/rank/">rank operator</a> , un-golfing in the process:  </p><pre><code>      1⍳⍨(⍤1)w∘.∊a
3 0 3 4 1
</code></pre><p>Maybe we can go tacit. It looks like we have a function between <code>a</code> and <code>w</code>, and then a function on the result, that is:</p><pre><code>   g a f w
</code></pre><p>Which can be rewritten as an <a href="https://docs.dyalog.com/20.0/programming-reference-guide/introduction/trains/#forks-and-atops">atop</a>:</p><pre><code>    a (g f) w
</code></pre><p>Where: </p><pre><code>      f←∘.∊⍨
      g←⍳∘1⍤1
</code></pre><p>Let's see if it works:</p><pre><code>      a (g f) w
3 0 3 4 1
</code></pre><p>Oh yeah! Now we can just combine into one function:</p><pre><code>    liota2←⍳∘1⍤1∘.∊⍨ 
    a liota2 w
3 0 3 4 1
</code></pre><p>We can guess that while the tacit version is short and sweet, it's going to be a dog in terms of time and space due to the outer product when both arguments get large, and indeed the flat version is almost infinitely faster. That being said, in our use case, neither argument will ever be very large.</p><h2>Update</h2><p>Josh David provides a much nicer flat array solution using <a href="https://docs.dyalog.com/20.0/language-reference-guide/primitive-functions/interval-index/">interval index</a> that is both shorter and faster:</p><pre><code>      {1+(+\≢¨⍺)⍸⍵⍳⍨⊃,/⍺}
</code></pre><p>It's amazing the various uses of <code>⍸</code>.</p><h2>Another Update</h2><p><a href="https://www.sacrideo.us/">Aaron Hsu</a> writes in with another solution using <code>⍸</code>, but in its monadic form <a href="https://docs.dyalog.com/20.0/language-reference-guide/primitive-functions/where/">Where</a>, which we had completely forgotten or maybe never knew can take an argument of non-negative integers, as well as the more typical Boolean: </p><pre><code>      {((⍸≢¨⍺),≢⍺)[(∊⍺)⍳⍵]}
</code></pre><p>The Dyalog docs state that the model for <code>Where</code> can be expressed as <code>{(,⍵)/,⍳⍴⍵}</code>, which is exactly what we where doing in our first solution above.</p><p>We should have mentioned in the original post that our use case is not scaler integer or character items,  but vectors of vectors representing names. So replacing <code>∊</code> with <code>⊃,/</code>, and a little golf yields:</p><pre><code>      {(⍸≢¨⍺,1)[⍵⍳⍨⊃,/⍺]} 
</code></pre><p>I was happy to discover that <code>(⍸≢¨⍺),≢⍺</code> can be replaced by <code>⍳≢¨⍺,1</code>.</p><p>Aaron also sent a tacit version (for scaler items only) with the new behind operator which is not even on my keyboard:</p><pre><code>      (⊂∊⍛⍳)⌷((⍸≢¨),≢)⍤⊣
</code></pre><p>I wonder if this can be simplified a bit, given the golf above.</p><h2>Yet Another Update</h2><p>No discussion of <code>⍸</code> should conclude without a thank you to the late Roger Hui. Thank you Roger! </p><p>We have a function, still in use, that is probably close to 40 years old, originally a trad fn, but now a dnf:</p><pre><code>ComputeRange←{                   ⍝ ⍺ breaks, ⍵ Values
     v←⍺,⍵                       ⍝ Gary Berquist Page 70
     g←⍋v                        ⍝ Sort
     l←⍴⍺                        ⍝ First
     s←⍴⍵
     f←+\((l⍴1),s⍴0)[g]          ⍝ Slighly faster than:  f←+\((⍴v)↑l⍴1)[g]
     i←(⍴f)⍴0                    ⍝ Init
     i[g]←f                      ⍝ Index
     s⍴l↓i                       ⍝ Drop breaks points, enforce vec/scalar
 }
</code></pre><p>Note the reference to the legendary Gary Berquist, from whom we probably stole the entire function. This was used for one purpose only: grouping a numeric database column.</p><p>This is equivalent to the atop:</p><pre><code>      1∘+⍸
</code></pre><p>It never would have occurred to us the many uses of this algorithm, and we never would have thought to apply this function in other situations.</p><p>Thank you Roger!</p></article><article><header><h1><a href="/posts/datagrid-sorting-and-filtering">DataGrid Sorting and Filtering</a></h1><h2>November 5, 2025</h2></header><p>Back when we first were designing the <a href="/posts/a-high-performance-data-grid-in-html">DataGrid</a>  we thought we would leave filtering and sorting up to the application. The problem with that approach is that it requires an extra copy of the data. For example, if we want the data sorted by a particular column or set of columns, we need to sort the data outside in the application and reset the DataGrid properties. This creates a whole new copy of the data. Same goes for basic filtering: if we want to select certain rows to display, we need to select the rows in the application and reset the DataGrid properties. This is not good.</p><p>It turns out the way we have implemented the grid makes it fairly easy to build in sorting and filtering. Assume the data is a matrix, <code>m</code>. Then at any given moment, the rows that are to be displayed in the available window space are given by a vector of (up till now) consecutive integers <code>i</code>:    </p><pre><code>      m[i;]
</code></pre><p>If the user is on the bottom visible row and scrolls down one, then <code>i</code> will be effectively set to <code>i+1</code>. But there is no reason that <code>i</code> needs to be consecutive integers. We can display certain rows in a certain order by simply messing around with <code>i</code>.</p><p>In the DataGrid we now track an internal property <code>RowIndices</code>. This defaults to  <code>⍳n</code> where <code>n</code> is the number of data rows. That is, the default is to show all rows in the order given. We can pick out a subset of indices and permute them, assign this to <code>RowIndices</code> and thus display a subset of data in a different order:</p><pre><code>      m[RowIndices[i];]
</code></pre><p>And that's all there is to built-in sorting and filtering. The entire dataset is never sorted, nor is it ever selected out or copied.    We limit built-in filtering to selecting where a column is equal to  a particular value, or set of values. We can of course filter on multiple columns. More sophisticated filtering, for example selecting rows where a column is greater than a certain value, is left up to the application.    There is a new <code>RowMask</code> property, a Boolean of the same length as the data. This allows the application to provide the entire dataset once to the DataGrid once, and then reset the visible rows. Built-in filtering can work on top of application filtering.</p><p>We only allow sorting and filtering if the property <code>InsertRows</code> is set to <code>0</code>, that is the total number of rows cannot be changed. We may relax this in the future.      </p><p>  </p><p>     </p></article><h2><a href="/posts">More posts...</a></h2></main><footer><p>Copyright 2021-2025 Paul S. Mansour</p></footer></body></html>
