<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/leetcode-571">LeetCode 571: Find Median Given
            Frequency of Numbers</a>
          </h1>
          <h2>July 6, 2022</h2>
        </header>
        <p>One of the most powerful aspects of FlipDB is that we can employ
        APL-style solutions directly in a query. We can take, drop, rotate,
        expand, replicate, grade (and much more!), doing all sorts of things
        with intermediate values and structures, and as long as as the
        final result is conforming (produces a table), we are good to go.
        This makes solving LeetCode 571 not just easy, but trival. We are
        given a table of observations and their frequencies:</p>
        <pre>
          <code>   t.Display 0
── LeetCode571.Numbers 
 ┌Num─┐  ┌Frequency┐   
 ↓0   │  ↓7        │   
 │1   │  │1        │   
 │2   │  │3        │   
 │3   │  │1        │   
 └Int8┘  └Int8─────┘   
── 4 rows by 2 columns 
</code>
        </pre>
        <p>and tasked with computing the median:</p>
        <pre>
          <code>     q←t.Query''
     _←q.AddColumn'Median' 'median Frequency replicate Num'
     r←q.Execute 0
     r.Display 0
───────────────────────
 ┌Median┐              
 │0     │              
 └Int8──┘              
── 1 row by 1 column ──
</code>
        </pre>
        <p>
          Of course FlipDB has a
          <code>median</code>
          function (as well as the more general
          <code>percentile</code>
          , like SQL), so we have abstracted away the problem of actually
          computing the median. The point here, though, is that we can
          easily transform the given data to construct the appropriate
          argument to
          <code>median</code>
          , using a common APL technique:
        </p>
        <pre>
          <code>      7 1 3 1/0 1 2 3
0 0 0 0 0 0 0 1 2 2 2 3
</code>
        </pre>
        <p>And the intermediate data structure, an array of lenght 12,
        is not directly related to the shape of any tables in the database.
        We have some serious computational freedom within a query, and
        can write direct solutions to complex problems.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/leetcode-262-trips-and-users">LeetCode 262:
            Trips and Users</a>
          </h1>
          <h2>June 26, 2022</h2>
        </header>
        <p>
          After
          <code>weightedAverage</code>
          , the single most import function contributing to the success
          of
          <em>The Carlisle Group</em>
          is
          <code>percentAcross</code>
          . Like
          <code>weightedAverage</code>
          , it is an aggregate function. Like
          <code>weightedAverage</code>
          , it is not complicated mathematically or difficult to implement.
          And like
          <code>weightedAverage</code>
          , you won't find it in Excel or SQL.
        </p>
        <p>It takes 2 to 3 arguments. The first argument is the primary
        numeric vector on which we are computing the percentage. The second
        argument is the boolean mask to abe applied to the numerator. The
        optional third argument is the denominator mask, which defaults
        to 1. The result is simply the quotient of the sums of the primary
        vector masked by the two booleans.</p>
        <p>A simple implementation might look like:</p>
        <pre>
          <code>percentAcross←{
     v n d←3↑⍵,1
     (+/v×n)÷+/v×d
 }
</code>
        </pre>
        <p>We call it "percentAcross" because in the context of a grouped
        query, its typical usage, it can produce percentages that are additive
        across the result table, as opposed to down the result table. Repeated
        calls with mutually exclusive booleans restricting the numerator
        are a poor man's cross-tab.</p>
        <p>Consider:</p>
        <pre>
          <code>      percentAcross (20 30 10 40) (0 1 0 1)
0.7
</code>
        </pre>
        <p>The 2nd and 4th item of the vector represent 70 percent of the
        total. We can restrict the denominator as well:</p>
        <pre>
          <code>      percentAcross (20 30 10 40) (0 1 0 1) (0 1 1 1)
0.875
</code>
        </pre>
        <p>The 2nd and 4th item represent 87.5% of the 2nd, 3rd, and 4th
        items.</p>
        <p>
          With this function in hand, let's tackle LeetCode 262:
          <a href="https://leetcode.com/problems/trips-and-users/">Trips
          and Users</a>
          . We are given two tables:
        </p>
        <pre>
          <code>      d←s.Get '/Databases/LeetCode262'
      d.Display 0
 ── LeetCode262.Users ────────────                                               
  ┌UsersID┐  ┌Banned─┐  ┌Roll───┐                                                
  ↓1      │  ↓No     │  ↓client │                                                
  │2      │  │Yes    │  │client │                                                
  │3      │  │No     │  │client │                                                
  │4      │  │No     │  │client │                                                
  │10     │  │No     │  │driver │                                                
  │11     │  │No     │  │driver │                                                
  │12     │  │No     │  │driver │                                                
  │13     │  │No     │  │driver │                                                
  └Int8───┘  └Char(3)┘  └Char(6)┘                                                
 ── 8 rows by 3 columns ──────────                                               
                                                                                 
 ── LeetCode262.Trips ────────────────────────────────────────────────────────── 
  ┌ID──┐  ┌ClientID┐  ┌DriverID┐  ┌CityID┐  ┌Status─────────────┐  ┌RequestAt─┐  
  ↓1   │  ↓1       │  ↓10      │  ↓1     │  ↓completed          │  ↓2013-10-01│  
  │2   │  │2       │  │11      │  │1     │  │cancelled by driver│  │2013-10-01│  
  │3   │  │3       │  │12      │  │6     │  │completed          │  │2013-10-01│  
  │4   │  │4       │  │13      │  │6     │  │cancelled by client│  │2013-10-01│  
  │5   │  │1       │  │10      │  │1     │  │completed          │  │2013-10-02│  
  │6   │  │2       │  │11      │  │6     │  │completed          │  │2013-10-02│  
  │7   │  │3       │  │12      │  │6     │  │completed          │  │2013-10-02│  
  │8   │  │2       │  │12      │  │12    │  │completed          │  │2013-10-03│  
  │9   │  │3       │  │10      │  │12    │  │completed          │  │2013-10-03│  
  │10  │  │4       │  │13      │  │12    │  │cancelled by client│  │2013-10-03│  
  └Int8┘  └Int8────┘  └Int8────┘  └Int8──┘  └Char(19)───────────┘  └Date──────┘  
 ── 10 rows by 6 columns ─────────────────────────────────────────────────────── 
</code>
        </pre>
        <p>The problem is:</p>
        <blockquote>
          <p>The cancellation rate is computed by dividing the number of
          canceled (by client or driver) requests with unbanned users by
          the total number of requests with unbanned users on that day.
          Write a SQL query to find the cancellation rate of requests with
          unbanned users (both client and driver must not be banned) each
          day between "2013-10-01" and "2013-10-03". Round Cancellation
          Rate to two decimal points. Return the result table in any order.</p>
        </blockquote>
        <p>Note that CityID and Roll columns of the given tables are not
        needed. Furthermore, the final restriction of the explicit dates
        does not add anything material to the problem in this particular
        case, or anything intesting in any case.</p>
        <p>Our query begins with the Trips table, selecting only those
        rows where neither the driver nor the client are banned:</p>
        <pre>
          <code>      t←d.GetTable 'Trips'
      q←t.Query''
      q.Where←'(ClientID.Banned in "No") and (DriverID.Banned in "No")'
</code>
        </pre>
        <p>ClientID and DriverID are foreign keys in the Trips table pointing
        to the Users table. Then we group and specify the cancellation
        rate adding a column to the select clause:</p>
        <pre>
          <code>      q.GroupBy←'RequestAt'
      _←q.AddColumn'CancellationRate' '2 round .01 * percentAcross Status (not Status in "completed")'
</code>
        </pre>
        <p>
          A production verison of
          <code>percentAcross</code>
          should operate on a character column, as it does here, to compute
          a percentage based on the row count. We need to move the decimal
          over because in FlipDB the
          <code>percentAcross</code>
          function naturally returns a percentage, not a ratio. And of
          course round it to 2 decmimal places. And now the result:
        </p>
        <pre>
          <code>     r←q.Execute 0                                                                        
     r.Display 0 
────────────────────────────────────────
 ┌RequestAt───────┐  ┌CancellationRate┐ 
 ↓2013-10-01      │  ↓0.33            │ 
 │2013-10-02      │  │0.00            │ 
 │2013-10-03      │  │0.50            │ 
 └Date────────────┘  └Dec(2)──────────┘ 
── 3 rows by 2 columns ─────────────────
</code>
        </pre>
        <p>
          An issue with this solution, however, is that the where clause
          might reduce the number of unique dates in the result, and will
          almost certainly, as it does in this case, reduce the rows processed
          by the grouping clause. We can move the where clause into the
          select clause by taking advantage of the
          <code>percentAcross</code>
          function's ability to restrict the data in both the numerator
          and the denominator. We use a couple of temporay results to keep
          it clear and clean:
        </p>
        <pre>
          <code>      q←t.Query''
      q.GroupBy←'RequestAt'
      _←q.AddColumn'Unbanned' '(ClientID.Banned in "No") and (DriverID.Banned in "No")' 1
      _←q.AddColumn'Cancelled' 'not Status in "completed"' 1
      _←q.AddColumn'CancellationRate' '2 round .01 * percentAcross Status (Unbanned and Cancelled) Unbanned'
      r←q.Execute 0
      r.Display 0
────────────────────────────────────────
 ┌RequestAt───────┐  ┌CancellationRate┐ 
 ↓2013-10-01      │  ↓0.33            │ 
 │2013-10-02      │  │0.00            │ 
 │2013-10-03      │  │0.50            │ 
 └Date────────────┘  └Dec(2)──────────┘ 
── 3 rows by 2 columns ─────────────────
</code>
        </pre>
        <p>
          The
          <code>percentAcross</code>
          function is simple yet extremely useful. For grouped queries,
          it answers the question, what percentage of X is in group Y.
          It's more general than a cross-tab, because the boolean statements
          may refer to any number of columns and group the horizontal axis
          in arbitrary ways.
        </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/leetcode-185">LeetCode 185: Department Top
            Three Salaries</a>
          </h1>
          <h2>June 25, 2022</h2>
        </header>
        <p>
          Let's solve LeetCode 185, the
          <a href="https://leetcode.com/problems/department-top-three-salaries/">Department
          Top Three Salaries</a>
          problem, in FlipDB, our array-oriented, APL-based DSL. We will
          use FlipDB directly in the APL session.
        </p>
        <p>We are given two tables, a department table and an employee
        table:</p>
        <pre>
          <code>      d←s.Get '/Databases/LeetCode185'
      d.Display 0
 ── LeetCode185.Department                       
  ┌ID──┐  ┌Name───┐                            
  ↓1   │  ↓IT     │                            
  │2   │  │Sales  │                            
  └Int8┘  └Char(5)┘                            
 ── 2 rows by 2 columns                        
                                               
 ── LeetCode185.Employee ───────────────────── 
  ┌ID──┐  ┌Name───┐  ┌Salary┐  ┌DepartmentID┐  
  ↓1   │  ↓Joe    │  ↓85,000│  ↓1           │  
  │2   │  │Henry  │  │80,000│  │2           │  
  │3   │  │Sam    │  │60,000│  │2           │  
  │4   │  │Max    │  │90,000│  │1           │  
  │5   │  │Janet  │  │69,000│  │1           │  
  │6   │  │Randy  │  │85,000│  │1           │  
  │7   │  │Will   │  │70,000│  │1           │  
  └Int8┘  └Char(5)┘  └Int32─┘  └Int8────────┘  
 ── 7 rows by 4 columns ────────────────────── 
</code>
        </pre>
        <p>The problem is:</p>
        <blockquote>
          <p>A company's executives are interested in seeing who earns
          the most money in each of the company's departments. A high earner
          in a department is an employee who has a salary in the top three
          unique salaries for that department. Write an SQL query to find
          the employees who are high earners in each of the departments.</p>
        </blockquote>
        <p>The Department table does not add anything to the problem. It
        simply gives a nice description for each department, and we can
        dispense with it.</p>
        <p>We create a new query on the Employee table:</p>
        <pre>
          <code>      t←d.GetTable 'Employee'
      q←t.Query '' 
</code>
        </pre>
        <p>
          The task is simply to select some rows. There is no computation
          or aggregation required in the result, so the only thing we need
          to specify is a where clause, making use of the
          <strong>rankDown</strong>
          function:
        </p>
        <pre>
          <code>      q.Where←'3 &gt; 1 rankDown by Salary (group DepartmentID)'
      r←q.Execute 0
      r.Display 0
── Key:ID ───────────────────────────────────
 ┌ID──┐  ┌Name───┐  ┌Salary┐  ┌DepartmentID┐ 
 ↓1   │  ↓Joe    │  ↓85,000│  ↓1           │ 
 │2   │  │Henry  │  │80,000│  │2           │ 
 │3   │  │Sam    │  │60,000│  │2           │ 
 │4   │  │Max    │  │90,000│  │1           │ 
 │6   │  │Randy  │  │85,000│  │1           │ 
 │7   │  │Will   │  │70,000│  │1           │ 
 └Int8┘  └Char(5)┘  └Int32─┘  └Int8────────┘ 
── 6 rows by 4 columns ──────────────────────
</code>
        </pre>
        <p>
          Note first that the
          <code>rankDown</code>
          function is in
          <code>⎕IO←0</code>
          , so we are selecting salaries ranked 0, 1, or 2. Note further
          that
          <code>rankDown</code>
          takes a left argument of 0 1 or 2, for rank, dense rank, and
          average rank, respectively, so in this case we are applying dense
          rank. Finally note that
          <code>rankDown</code>
          is passed to the
          <code>by</code>
          operator to apply it within each department.
        </p>
        <p>We can pick apart this where clause expression and see how it
        works, right in the APL session:</p>
        <pre>
          <code>        disp←{⍵.Display 0}
        Salary←85 80 60 90 69 85 70
        Department←1 2 2 1 1 1 1
</code>
        </pre>
        <p>
          The
          <code>group</code>
          function returns the indices for each unique value:
        </p>
        <pre>
          <code>        disp group Department
┌───────────┐
↓[0,3,4,5,6]│
│[1,2]      │
└Int8───────┘
</code>
        </pre>
        <p>
          The
          <code>rankDown</code>
          function, with a left argument of 1 for dense, applied to Salary
          directly:
        </p>
        <pre>
          <code>       disp 1 rankDown Salary
┌────┐
↓1   │
│2   │
│5   │
│0   │
│4   │
│1   │
│3   │
└Int8┘
</code>
        </pre>
        <p>
          And now applied via the
          <code>by</code>
          operator, so that we rank within each group:
        </p>
        <pre>
          <code>        disp 1 rankDown by Salary (group Department)
┌────┐
↓1   │
│0   │
│1   │
│0   │
│3   │
│1   │
│2   │
└Int8┘
</code>
        </pre>
        <p>
          The
          <code>by</code>
          operator groups the data and applies its operand function to
          each group, and then ungroups the data, restoring it to its original
          order. It is particularly useful with uniform functions like
          <code>rankDown</code>
          , but it is also useful with aggregate and structural functions.
        </p>
        <p>Finally we flag the top 3 ranks:</p>
        <pre>
          <code>      disp 3 gt 1 rankDown by Salary(group Department)
┌───────┐
↓1      │
│1      │
│1      │
│1      │
│0      │
│1      │
│1      │
└Boolean┘
</code>
        </pre>
        <h3>Design Issue</h3>
        <p>
          There is a tradeoff when designing a DSL, between more functions
          with fewer arguments, and fewer functions with more arguments.
          In the case of rank, FlipDB currently has two functions,
          <code>rankUp</code>
          and
          <code>rankDown</code>
          , each taking three potential values as a left argument for an
          effective total combination of 6 functions:
        </p>
        <pre>
          <code>rankUp
rankDown
denseRankUp
denseRankDown
averageRankUp
averageRankDown
</code>
        </pre>
        <p>
          We could of course have only one function,
          <code>rank</code>
          , and provide yet another argument for the direction. The idea
          behind building in the ordering into the name was to make it
          similar to the related APL primitives
          <code>grade up</code>
          and
          <code>grade down</code>
          . Two functions seemed good, 6 functions seemed overkill at the
          time, but I'm reconsidering. It would be easier to read
          <code>denseRankDown Salary</code>
          than
          <code>1 rankDown Salary</code>
          . The latter requires a trip to the documentation, while the
          former is discoverable with autocomplete.
        </p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2022 Paul S. Mansour</p>
    </footer>
  </body>
</html>
