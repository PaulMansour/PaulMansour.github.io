<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/error-trapping">Error Trapping</a>
          </h1>
          <h2>February 20, 2023</h2>
        </header>
        <p>Once we have written some nice, succinct APL code, it is disheartening to muck it all up with error trapping. There are many techniques, and often we just sling <code>⎕TRAP</code>, <code>:Trap</code>, <code>⎕SIGNAL</code> and error guards willy-nilly. It would be nice have to some tried and true patterns to apply, and extract as much messiness as possible.</p>
        <p>The best error trapping is none at all, or rather, left to functions further up the stack. But if we are providing a package to be used by others, and the API consists of more than utility functions like deleting extraneous blanks, we should provide some minimal distinction between a user error and a bug. This post explores one possible pattern, used in the <a href="https://github.com/the-carlisle-group/Text2Date">Text2Date</a> project.</p>
        <p>For some packages, there is no need to invent new error numbers and  event messages. However, we need a way to distinguish between, say, a length error that we anticipate, and one that we don't.  Two functions will suffice to extract all the needed logic:</p>
        <pre><code>Signal←{
     ⎕SIGNAL⊂('EN'(⍺+500))('Message'⍵)
 }
</code></pre>
        <p>and</p>
        <pre><code>f←ReSignal
f←⎕SIGNAL{
    ⊂('EN'(⍵.EN-500))('Message'⍵.Message)
}
</code></pre>
        <p>The <code>Signal</code> function wraps <code>⎕SIGNAL</code>, and specifies the <strong>error number</strong> and <strong>message</strong> for <code>⎕DMX</code>. The error number is bumped up by an arbitrary multiple of 100 (from 100 to 900), to distinguish it from an unexpected error. So, for example, if the left argument to an API function requires a 1 or 0, to signal a DOMAIN ERROR we might write:</p>
        <pre><code>~⍺∊0 1:11 Signal 'The left argument must be 0 or 1'
</code></pre>
        <p>Note that <code>Signal</code> reverses the arguments of <code>⎕SIGNAL</code>. This is because <code>⎕SIGNAL</code> is more often than not called with <code>⍨</code> as the right argument is almost always a literal scalar, while the left argument is often constructed. </p>
        <p>At the top of any API function we include the error guard:  </p>
        <pre><code>500+⍳100::ReSignal ⎕DMX
</code></pre>
        <p>This traps all errors in our arbitrary block of 100, and using <code>ReSignal</code> propagates expected errors to the calling function. Unexpected errors remain untrapped and fail where they are. <code>ReSignal</code> only specifies the event number <code>EN</code> and <code>Message</code> for <code>⎕DMX</code>. The event message <code>EM</code> is automatically provided. <code>ReSignal</code> is a niladic trad function that returns a function. The reason for this subterfuge is that we want to encapsulate the right side of this error guard:</p>
        <pre><code>300+⍳100::⎕SIGNAL ⊂('EN'(⎕DMX.EN-500))('Message'⎕DMX.Message)
</code></pre>
        <p>as this is far too much code to be copying and pasting all over the place. But <code>⎕SIGNAL</code> itself cannot be wrapped inside a function (trad or dfn) or it will not break out of the main function. It must signal in the scope of the main API function. The code to the right of <code>⎕SIGNAL</code> could easily be wrapped, but it would be nice to include the whole thing. Thus the trad function <code>ReSignal</code> returns a function that includes the whole thing, but keeps the <code>⎕SIGNAL</code> out of the subfunction.  This encapsulation technique is lifted from <a href="https://github.com/abrudz/dyalog_vision/blob/main/%E2%88%86SIGNAL.aplf">Adám Brudzewsky</a>.                                                             </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/provanto">Provanto: A Test Framework</a>
          </h1>
          <h2>February 13, 2023</h2>
        </header>
        <p>Framework is a big word for what is going on here. But testing <strong>utility</strong>, or testing <strong>application</strong> seem no better. Anyway, for years my testing "framework" has been more or less:</p>
        <pre><code>RunTests←{
     f←'T'⍵.⎕NL ¯3
     b←⍵{
        b←⍺⍎⍵,' 0'
        ⎕←⍵,': ',b⊃'Passed' '*** Failed ***'
        b}¨f
     tf←+/b
     r←⊂'Tests run: ',⍕≢b
     r,←⊂'Passed: ',⍕+/~b
     r,←⊂'Failed: ',⍕+/b
     ⊃r
 } 
</code></pre>
        <p>This runs on a namespace full of test functions that return a 1 or 0 for success and  failure respectively. I would just copy this snippet to each new project, making a little application specific modification here and there. This could use a little improvement, but I don't want it to become a huge, unwieldy framework with lots of options, classes, methods, etc. I don't really want to write tests for my test framework, or much documentation. But I do want it to report code coverage, to have an option for stopping on failure, and to handle broken tests and other conditions.  </p>
        <p>My new and improved "framework" is now its own Github repository <a href="https://github.com/the-carlisle-group/Provanto">Provanto</a>. Unfortunately, despite my best efforts, is has grown from  one function of a dozen lines to 8 functions nearing a total of 100 lines: </p>
        <pre><code>:Namespace Provanto
 ⎕IO ⎕ML←0 1
 Assert←{
     0⊣'TEST FAILED'⎕SIGNAL 789/⍨~⍵
 }
 Coverage←{
     ~⍵.Profile:¯1 ''
     s←Spaces⍕⍵.CodeSpace
     n←s.⎕NL⊂-3 4
     p←'.',¨⍨⍕¨s
     af←⊃,/p{⍺∘,¨⍵}¨n
     d←⎕PROFILE'data'
     b←d[;1]∊⊂⍬
     ef←b/d[;0]
     el←(+\b)⊆d[;1]
     nr←(⎕NR¨af)~¨⊂⊂' }'
     al←⍳¨≢¨nr
     ul←al~¨(el,⊂⍬)[ef⍳af]
     c←100×1-÷/≢¨∊¨ul al
     k←0&lt;≢¨ul
     uf←~af∊ef
     (uf/ul)←⊂⍬
     z←k/af{0=≢⍵:⍺ ⋄ ⍺,'[',(⍕⍵),']'}¨ul  ⍝
     c z
 }
 Display←{
     ⍵.Quiet&gt;1:0
     r←⍵.Result
     h←'Number of tests:'(≢r)
     ⎕←'*'⍪(⍕h⍪⍵.Status,⍪+⌿r∘.=⍳5)⍪'*'
     ~⍵.Profile:0
     ⎕←'Code coverage: ',,'Q&lt;%&gt;I4'⎕FMT ⍵.Coverage
     ⍵.Coverage=100:0
     ⎕←'Untested code:'
     ⎕←↑⍵.Untested
     0
 }
 Exe←{
     r←⍺{
         0/⍨~⍺.Stop::1+789≠⎕DMX.EN
         ⍺.TestSpace⍎⍵,' 0'
     }⍵
     ⍺.Quiet&gt;0:r
     r⊣⎕←(r⊃⍺.DecoratedStatus),' ',(⍕⍺.TestSpace),'.',⍵
 }
 Run←{
     ⍝ ⍺ ←→ [Stop 0|1 [Quiet 0|1|2]]
     ⍝ ⍵ ←→ Test space, [Code space]
     ⍝ ← ←→ Result space
     ⍺←0
     z←⎕NS''
     z.(Stop Quiet)←2↑⍺
     z.(TestSpace CodeSpace)←2↑⍵,0
     z.(Status DecoratedStatus)←Status''
     z.Profile←z.CodeSpace≠0
     _←z.TestSpace.⎕FX¨⎕NR¨'Assert' 'Try'
     z.Function←'T'z.TestSpace.⎕NL ¯3
     p←⎕PROFILE⍣z.Profile
     _←p¨'Clear'('Start' 'coverage')
     z.Result←z Exe¨z.Function
     _←p'stop'
     z.(Coverage Untested)←Coverage z
     _←p'clear'
     1:z←z⊣Display z
 }
 Spaces←{
     ⍵≢⍕⍎⍵:⍬
     s←⍵∘,¨'.',¨(⍎⍵).⎕NL ¯9
     0=≢s:,⍎⍵
     ∊(⍎⍵),∇¨s
 }
 Status←{
     s←'Passed' 'Failed' 'Broken' 'N/A' 'Disabled'
     d←↓(↑':',¨⍨s),' ',↑3/¨' !!--'
     s d
 }
 Try←{
     ⍺←⊢
     0::⎕DMX.EN
     0⊣⍺ ⍺⍺ ⍵
 }
:EndNamespace
</code></pre>
        <p>The API is limited to the <code>Run</code> function:</p>
        <pre><code>      {Z}←[X [Y]] Provanto.Run A [B]  
</code></pre>
        <p>Where <code>A</code> is a namespace full of test functions, <code>B</code> is an optional namespace full of code that triggers a code coverage feature, <code>X</code> is a flag for stopping on failing or broken tests and <code>Y</code> is a flag for suppressing session output.  <code>Z</code>, the shy result, is a namespace full of test results, if needed for further processing or reporting. </p>
        <p>The run function injects a function <code>Assert</code> and an operator <code>Try</code> into the test namespace. In a test, the Assert function is called to the left of a naked guard. I first saw this technique, and use of word <strong>assert</strong> in this context, from the late great Roger Hui. Like Roger's, the Provanto <code>Assert</code> function uses only a right argument and does not embed the <code>match</code> function inside <code>Assert</code>. Thus a line in a test function looks like:</p>
        <pre><code>      Assert 4=2+2:
</code></pre>
        <p>This reads a little better than putting a value to the left, and in addition it leaves open the option of applying other functions besides <code>match</code> to produce a boolean without additional logic. A test function is thus a gauntlet of assertions terminated by a <code>0</code>:</p>
        <pre><code>TestPlus←{
     Assert 4=2+2:
     Assert 2 3 4≡1 2 3+1:
     Assert 5 6≡2+3 4:
     Assert 5=2 3+Try 4 5 6:
     Assert 11=2+Try'A':
     0
 }
</code></pre>
        <p>The <code>Try</code> operator attempts to execute a function, trapping and returning any error:</p>
        <pre><code>       Assert 5=2 3+Try 4 5 6:
</code></pre>
        <p>If a code namespace is provided, code coverage is computed with <code>⎕PROFILE</code>, and functions (with an explicit list of lines) that are not executed by the  tests are displayed in the session.</p>
        <p>What more is needed? No doubt the <code>Profile</code> function could be cleaned up a bit. A large application might have multiple test namespaces, so we might want to have a cover function to run them all, or enhance <code>Run</code> to take multiple test namespaces.  </p>
        <p>The next step is to review Lars Stampe Villadsen's <a href="https://www.youtube.com/watch?v=2B7YE79DASY">presentation</a> from the Dyalog 2023 conference and get this stuff running automatically on Github.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/text-to-date">Converting Text to Date</a>
          </h1>
          <h2>January 23, 2023</h2>
        </header>
        <p>Problem #6 from <a href="https://www.dyalog.com/uploads/files/student_competition/2022_problems_phase2.pdf">Phase 2 of the Dyalog 2020 APL Problem Solving Comptetition</a> is titled <strong><em>Its a Date!</em></strong> The task was to write a function <code>DDN</code> which basically does the inverse of the date format function <code>1200⌶</code>. </p>
        <p>Apparently the problem as specified was quite difficult, and no complete or even nearly complete solutions were submitted.</p>
        <p>This being the <strong>APL for the Practical Man</strong> blog, we are interested in how the problem  should be framed to make the solution useful in a commercial application. And of course the general problem is encountered all the time. Dates are common data elements. Data are in files. Files are often text. So here we propose a function <code>Text2Date</code>, to compare and contrast with <code>DDN</code>.</p>
        <p>First and foremost, in the original specification, the function <code>DDN</code> is expected to operate on a single string  or character vector, converting one string to one date, one at a time. But it will not do to use the <code>each</code> operator on millions of dates.  <code>Text2Date</code> must operate on a character matrix where each row represents a date. This has the extra benefit of making the problem more array oriented - an issue that was noted  in the <a href="https://dyalog.tv/Dyalog22/?v=018ZUHrFSM8">presentation of the contest winners</a> at the recent conference in Portugal. </p>
        <p>Second, <code>DDN</code> is expected to handle strings that do not produce a unique Dyalog Date Number, like <code>'07'</code>, <code>'Thursday'</code>, and  <code>'Feb 29th'</code>, all potential outputs from <code>1200⌶</code>. This adds complexilty but provides little to no value. We can only elide consecutive trailing elements in <code>⎕TS</code>, which default to <code>1</code> or <code>0</code> as appropriate, and no one would reasonably expect otherwise:</p>
        <pre><code>       ¯1 1 ⎕DT⊂,2022 
44561
       ¯1 1 ⎕DT⊂2022 28 
DOMAIN ERROR: Invalid date-time
      ¯1 1 ⎕DT⊂2022 28
           ∧
      ¯1 1 ⎕DT⊂2022 ⍬ 28
DOMAIN ERROR: Invalid date-time
      ¯1 1 ⎕DT⊂2022 ⍬ 28
           ∧
      ¯1 1 ⎕DT⊂2022 0 28
DOMAIN ERROR: Invalid date-time
      ¯1 1 ⎕DT⊂2022 0 28
           ∧
</code></pre>
        <p>Thus <code>Text2Date</code> should only be required to handle strings that produce a unique Dyalog Date Number, with the exception that 2 digit years are resolved using a fixed or sliding century window, which  may be provided as an optional argument.</p>
        <p>Third, the spec for <code>DDN</code> states that:</p>
        <blockquote>
          <p>No variable length numeric fields will be placed immediately next to another numeric field.</p>
        </blockquote>
        <p>For example, <code>MDDYY</code>, <code>YYMD</code> and <code>MDY</code> would be disallowed. This is almost, but not quite, saying that variable length formats must be delimited. It allows, for example, <code>MMYY-D</code>. This constraint is both too restrictive and not restrictive enough.  Leading variable length elements should be allowed immediatly adjacent to a fixed element, but otherwise the elements in a variable length format must be strictly delimited.  Thus <code>Text2Date</code> should properly handle the string <code>'DMMYY'</code>, but should not handle <code>'YYMM-D'</code>.  The reason for the former is that undelimited dates in text files are often missing a leading zero due to type conversions somewhere upstream. The reason for the latter is that allowing  delimited variable length elements in the same format with undelimited fixed width elements  adds much complexity for very little if any practical gain. </p>
        <p>If we combine the restriction that any variable length format must be fully delimited, with the further <code>DDN</code> restriction that:</p>
        <blockquote>
          <p>the only alphanumeric characters will be formatted elements of the date/time</p>
        </blockquote>
        <p>then specifying a variable length format becomes merely a matter of specifying the order in which the elements occur. That is, there is no need to specify '<code>M-YY-D</code>' when simply <code>MYD</code> will do. The string must contain three separated numbers (leaving aside months as text like Jan, Feb, etc.). The particular separator or length of separator is immaterial. </p>
        <p>This brings up the question of whether the format specifier for <code>1200⌶</code> is really the best unformat specifier. Is a true inverse really what we need? Certainly they are related, but in a real application we would probably want <code>'12/31/2022'</code>, <code>'1-1-2023'</code>, and <code>'7/4/21'</code> to all convert properly with the same format string.</p>
        <p>Thus there are at least two issues that make to-and-from text fundamentally different from all the other date formats.  <code>1200⌶</code> will create "invalid" dates, that is, strings that cannot be converted back to a unique Dyalog Date Number. And conversely, there are multiple strings that could only be created using multiple formats, but that should all convert back to a Dyalog Date Number using a single format. This may be an argument to keep <code>1200⌶</code> out of <code>⎕DT</code>.</p>
        <p>A further complication is handling bad data. To be useful, <code>Text2Date</code> must not fail when it cannot yield a valid Dyalog Data Number for a string. There are then only two options: return a value that indicates failure, or take the route of <code>⎕VFI</code>, and return a Boolean mask indicating valid results. A zero might be useful for a failure value. If not, a zero is perfect for a fill value, with the Boolean mask indicating valid results, just like <code>⎕VFI</code>.  If <code>1200⌶</code> is folded in to <code>⎕DT</code>, perhaps a variant could be added that changes the result to a <code>⎕VFI</code> style result. This might be useful for numeric-to-numeric conversions as well.</p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2023 Paul S. Mansour</p>
    </footer>
  </body>
</html>
