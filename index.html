<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/trains">Trains</a>
          </h1>
          <h2>July 8, 2022</h2>
        </header>
        <p>
          In a
          <a href="/posts/leetcode-571">previous post</a>
          we computed the median on grouped data by replicating it and
          applying a
          <code>median</code>
          function that works on ungroued data. I assumed that there was
          a way to compute the median without replicating the data, and
          sure enough,
          <a href="http://tamstat.com">Brother Statistician Steve</a>
          sent me this old (pre-interval index) solution (slighly modified
          for explanatory purposes):
        </p>
        <pre>
          <code>median1←{
    ⍝ ⍺ ←→ Frequency
    ⍝ ⍵ ←→ Values
    c←(+\⍺)÷+/⍺
    i←(0.5≤c)⍳1
    ⍵[i+0,0.5∊c]+.÷2
}
</code>
        </pre>
        <p>Looking at:</p>
        <pre>
          <code>      (+\⍺)÷+/⍺
</code>
        </pre>
        <p>the function train jumps right off the monitor:</p>
        <pre>
          <code>      +\÷+/
</code>
        </pre>
        <p>
          As an aside, trains come in two styles. First is the
          <strong>Orange Blossom Special</strong>
          style, of which this is a prime example. These trains are elegant,
          a great pleasure to ride. Then we have the
          <strong>Amtrak</strong>
          style, which is a mess of tacks, jots, and tildes diaeresis.
          (I'm guessing that is the proper plural form, and not tilde diaereses.)
          These trains are all glue and duct tape. A terrible travel experience.
          One is better off taking the dfn.
        </p>
        <p>But the point of this post is that it never occurred to me that
        trains work in FlipDB. And why wouldn't they?! In the FlipDB session:</p>
        <pre>
          <code>      (sum running / sum) 7 1 3 1
┌────────────┐
↓0.5833333333│
│0.6666666667│
│0.9166666667│
│1           │
└Float───────┘
</code>
        </pre>
        <p>So we can use trains anywhere, in a where clause, a select clause,
        a having clause, anywhere a FlipDB expression is called for.</p>
        <p>Ten minutes after Steve sent over the solution above he sent
        a new one using interval index, and catching the train too.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/leetcode-569">LeetCode 569: Median Employee
            Salary</a>
          </h1>
          <h2>July 7, 2022</h2>
        </header>
        <p>This problem is poorly constructed and annoying for multiple
        reasons. It's also hard to solve - and that makes it even more
        annoying. We are given the following table:</p>
        <pre>
          <code>      t.Display 0
── LeetCode569.Employee ─────
 ┌ID──┐  ┌Company┐  ┌Salary┐ 
 ↓1   │  ↓A      │  ↓2,341 │ 
 │2   │  │A      │  │341   │ 
 │3   │  │A      │  │15    │ 
 │4   │  │A      │  │15,314│ 
 │5   │  │A      │  │451   │ 
 │6   │  │A      │  │513   │ 
 │7   │  │B      │  │15    │ 
 │8   │  │B      │  │13    │ 
 │9   │  │B      │  │1,154 │ 
 │10  │  │B      │  │1,345 │ 
 │11  │  │B      │  │1,221 │ 
 │12  │  │B      │  │234   │ 
 │13  │  │C      │  │2,345 │ 
 │14  │  │C      │  │2,645 │ 
 │15  │  │C      │  │2,645 │ 
 │16  │  │C      │  │2,652 │ 
 │17  │  │C      │  │65    │ 
 └Int8┘  └Char(1)┘  └Int16─┘ 
── 17 rows by 3 columns ─────
</code>
        </pre>
        <p>And tasked with:</p>
        <blockquote>
          <p>Each row of this table indicates the company and the salary
          of one employee. Write an SQL query to find the median salary
          of each company.</p>
        </blockquote>
        <p>
          If we did not have an example to the contrary, and we wanted
          to
          <em>find the median salary of each company</em>
          as the instructions say, then this is an easy query, first grouping
          by company, and then applying the aggregate expression
          <code>median Salary</code>
          in the select clause.
        </p>
        <p>But the desired result is:</p>
        <pre>
          <code>      r.Display 0
── Key:ID ───────────────────
 ┌ID──┐  ┌Company┐  ┌Salary┐ 
 ↓5   │  ↓A      │  ↓451   │ 
 │6   │  │A      │  │513   │ 
 │9   │  │B      │  │1,154 │ 
 │12  │  │B      │  │234   │ 
 │14  │  │C      │  │2,645 │ 
 └Int8┘  └Char(1)┘  └Int16─┘ 
── 5 rows by 3 columns ──────
</code>
        </pre>
        <p>By inspection we see that the actual instructions should read
        something more like:</p>
        <blockquote>
          <p>Write an SQL query that returns the employees that earn the
          median salary if the median is not an interpolated value, or
          the two salaries that are averaged to compute the median, for
          their respective companies. Remove employees that duplicate company/salary
          combinations from the result set.</p>
        </blockquote>
        <p>Yuck.</p>
        <p>
          Assume for moment we had a built-in structural function named
          <code>medians</code>
          that returned a one-item array or a two-item array containing
          the values that go into constructing the median. Then we could
          simply write the select clause:
        </p>
        <pre>
          <code>      Salary in medians each by Salary (group Company)
</code>
        </pre>
        <p>
          using the
          <code>each</code>
          and
          <code>by</code>
          operators which does everything we need except the final removal
          of duplicates. (I am resisting the urge to implement
          <code>medians</code>
          in FlipDB). Note that the
          <code>each</code>
          operator is necessary as
          <code>medians</code>
          is a structural function, not an aggregate, or scalar, or uniform
          function. (More on this in a future post). However, in FlipDB
          we can do in-line anonymous functions just like dfns in APL,
          so we can replace
          <code>medians</code>
          above with this mess of a one-liner:
        </p>
        <pre>
          <code>     {(floor (shape z) / 2)index each enclose(sortUp z)(sortDown z)}
</code>
        </pre>
        <p>
          There is probably a much neater way to get the medians. FlipDB
          uses
          <code>z</code>
          as the right argument, in place of
          <code>⍵</code>
          in APL. The
          <code>enclose</code>
          function in FlipDB converts a set of simple columns into a single
          nested column. If there are an odd-number of items, we will get
          the same item twice, but it does not matter for the problem.
        </p>
        <p>With this in hand we can solve the problem:</p>
        <pre>
          <code>~~~ 
      q←t.Query''
      q.Where←'Salary in {(floor (shape z) / 2)index each enclose(sortUp z)(sortDown z)} each by Salary (group Company)'
      q.Having←'firstOccurrence Company laminate toChar Salary'
      r←q.Execute 0
      r.Display 0
── Key:ID ───────────────────
 ┌ID──┐  ┌Company┐  ┌Salary┐ 
 ↓5   │  ↓A      │  ↓451   │ 
 │6   │  │A      │  │513   │ 
 │9   │  │B      │  │1,154 │ 
 │12  │  │B      │  │234   │ 
 │14  │  │C      │  │2,645 │ 
 └Int8┘  └Char(1)┘  └Int16─┘ 
── 5 rows by 3 columns ──────
</code>
        </pre>
        <p>The having clause should probably be able to be written as:</p>
        <pre>
          <code>      firstOccurrence Company Salary
</code>
        </pre>
        <p>
          The
          <code>firstOccurrence</code>
          function is a cover for APL's unique mask function (monadic
          <code>≠</code>
          ). I don't think there is any reason it should not accept multiple
          columns. It could also take a table or datatable as an argument
          - on the todo list!
        </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/leetcode-571">LeetCode 571: Find Median Given
            Frequency of Numbers</a>
          </h1>
          <h2>July 6, 2022</h2>
        </header>
        <p>One of the most powerful aspects of FlipDB is that we can employ
        APL-style solutions directly in a query. We can take, drop, rotate,
        expand, replicate, grade (and much more!), doing all sorts of things
        with intermediate values and structures, and as long as as the
        final result is conforming in particular context, we are good to
        go. This makes solving LeetCode 571 not just easy, but trival.
        We are given a table of observations and their frequencies:</p>
        <pre>
          <code>      t.Display 0
── LeetCode571.Numbers 
 ┌Num─┐  ┌Frequency┐   
 ↓0   │  ↓7        │   
 │1   │  │1        │   
 │2   │  │3        │   
 │3   │  │1        │   
 └Int8┘  └Int8─────┘   
── 4 rows by 2 columns 
</code>
        </pre>
        <p>and tasked with computing the median:</p>
        <pre>
          <code>     q←t.Query''
     _←q.AddColumn'Median' 'median Frequency replicate Num'
     r←q.Execute 0
     r.Display 0
───────────────────────
 ┌Median┐              
 │0     │              
 └Int8──┘              
── 1 row by 1 column ──
</code>
        </pre>
        <p>Of course FlipDB has a median function (as well as the more
        general percentile , like SQL), so we have abstracted away the
        problem of actually computing the median. The point here, though,
        is that we can easily transform the given data to construct the
        appropriate argument to median, using a common APL technique:</p>
        <pre>
          <code>      7 1 3 1/0 1 2 3
0 0 0 0 0 0 0 1 2 2 2 3
</code>
        </pre>
        <p>And the intermediate data structure, an array of lenght 12,
        is not directly related to the shape of any tables in the database.
        We have some serious computational freedom within a query, and
        can write direct solutions to complex problems.</p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2022 Paul S. Mansour</p>
    </footer>
  </body>
</html>
