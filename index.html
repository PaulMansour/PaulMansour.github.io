<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <h3>"You don't know how bad your code is until you write about it."</h3>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/how-to-center-a-dialog-element">How to Center
            a Dialog Element</a>
          </h1>
          <h2>May 29, 2024</h2>
        </header>
        <p>How to center a <em>modal</em> dialog box to be precise.</p>
        <p>TL;DR:</p>
        <pre><code>     
</code></pre>
        <p>Yes, that's right. Nothing. Nada. Zero. Zilch.</p>
        <p>Now for the full story.</p>
        <p>I have been using a <a href="https://www.toolofthought.com/posts/beware-the-blur">ubiquitous but archaic and problematic technique</a> to center a modal dialog box in the viewport. On this morning's drive listening to the <a href="https://syntax.fm/show/775/components-we-need-on-every-project">current episode</a> of the excellent web dev podcast <a href="https://syntax.fm/">Syntax</a>, the hosts hinted at another method for centering using the CSS <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/inset">inset</a> property, which I was unfamiliar with. It turns out this property is just shorthand for top, right, bottom and left. Looking for more information, I stumbled on this <a href="https://www.youtube.com/shorts/9cSL5dP4rgM">video short</a>. Could it be that simple? All we need is <code>inset:0</code> and <code>margin:auto</code>? It turns out it is even simpler!</p>
        <p>It is useful to inspect the user-agent styling for <code>&lt;dialog&gt;</code> (in Chrome):</p>
        <pre><code>  dialog:-internal-modal {
    position: fixed;
    top: 0px;
    bottom: 0px;
    max-width: calc((100% - 6px) - 2em);
    max-height: calc((100% - 6px) - 2em);
    overflow: auto;
}    
  dialog {
    display: block;
    position: absolute;
    left: 0px;
    right: 0px;
    width: fit-content;
    height: fit-content;
    color: -internal-light-dark(black, white);
    margin: auto;
    border-width: initial;
    border-style: solid;
    border-color: initial;
    border-image: initial;
    padding: 1em;
    background: -internal-light-dark(white, black);
}
</code></pre>
        <p>Note the default values for the <code>&lt;dialog&gt;</code> element properties <code>position</code>, <code>left</code>, <code>right</code>, and <code>margin</code>. Further note that that when the <code>&lt;dialog&gt;</code> element is opened in a modal state, additional properties are defaulted, and some are overridden. The net result is that for a modal dialog box, the default value of <code>inset</code> is <code>0</code>, and the default value of <code>margin</code> is <code>auto</code>. Therefore, to center a modal dialog, <strong><em>nothing needs to be done</em></strong>.    But it is likely you have a CSS reset that sets all margins to <code>0</code>. In that case you will need: </p>
        <pre><code>    margin:auto;
</code></pre>
        <p>I don't think it likely that <code>inset</code> will have a different value than <code>0</code>, so no need to explicitly set it. </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/beware-the-blur">Beware the Blur, and More</a>
          </h1>
          <h2>May 24, 2024</h2>
        </header>
        <p>Modal dialog boxes are trivial now with the <code>&lt;dialog&gt;</code> element and the JavaScript <code>showModal</code> method. Almost all of the demos and introductions to this functionality love to show off the associated CSS <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/::backdrop">backdrop pseudo-element</a>, which allows us to style the background of the dyalog when it is being shown in a modal state.                Usually we see some CSS like:</p>
        <pre><code>dialog::backdrop {
  backdrop-filter: blur(2px);
}
</code></pre>
        <p>Which blurs out the background. This looks really nice. However, it turns out that it is a <a href="https://github.com/thirdweb-dev/dashboard/issues/703">ridiculously expensive effect</a>. If you have any changes to the dialog while it is open, the repaint is very slow. In our app, we have modal dialogs that contain small tables for editing. A background blur makes them unusable. </p>
        <p>Another thing to watch out for is using <code>transform</code> to center a dialog element. It's a cute technique: put the upper left corner in the center, and then move it back and to the left by 50 percent. In Abacus-style CSS:</p>
        <pre><code>     s.position←'fixed'
     s.left←'50%'
     s.top←'50%'
     s.transform←'translate(-50%, -50%)'
</code></pre>
        <p>All well and good, but there is a side-effect of using <code>transform</code> that affects positioning. Elements with fixed position on a dialog box that is centered this way will be <a href="https://dev.to/salilnaik/the-uncanny-relationship-between-position-fixed-and-transform-property-32f6">fixed relative to the dialog, not the viewport</a>, which is what you would normally expect. We have autocomplete elements that pop up on dialogs, and this makes positioning them much harder. For now I have taken to fixing the size of the dialog, so I can center it directly with using <code>transform</code>.</p>
        <p>To sum up, on &lt;dialog&gt; elements:</p>
        <blockquote>
          <p>Don't use <code>backdrop-filter: blur</code></p>
        </blockquote>
        <blockquote>
          <p>Don't use <code>transform</code>. </p>
        </blockquote>
        <p>Time to start a CSS Don'ts page perhaps.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/a-high-performance-data-grid-in-html">A High
            Performance Data Grid in HTML</a>
          </h1>
          <h2>May 20, 2024</h2>
        </header>
        <p>A first-rate data grid control is essential for many business applications. For decades we have relied on the venerable <code>⎕WC</code> grid, but we need to look at <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/DataGrid">something new</a> for the browser. There are many data grid controls out there: free ones, expensive ones, headless, full-featured, stripped down, open source, closed source, you name it. Most of them are way too complicated, trying to be all things to all people. We have APL, so we don't need a grid that implements calculations and formulas, or sorting, or a bunch of other things we can easily do ourselves. We are specifically <em>not</em> trying to implement a spreadsheet. We also don't need to support different data types in the same column. Nor do we need nested column titles, nor do we need different row heights; we don't need or want the data grid to be a reporting vehicle.  Our data grid will be designed for the efficient display, manipulation, and editing of tables, large and small. We can simplify, simplify, simplify.</p>
        <p>Let's look at what we <em>do</em> need:</p>
        <ol>
          <li>Fast, Excel-like scrolling. There should be no partial cell on the left when we scroll right, and no partial cell on the top when we scroll down.</li>
          <li>Relatively large capacity; millions of rows with hundreds of columns should be no problem. If the table can fit in the workspace, the data grid should be able to handle it. </li>
          <li>Sticky column headers.</li>
          <li>Optional row numbers.</li>
          <li>Optional freeze panes for columns (we don't care about freezing rows).</li>
          <li>Editing</li>
          <li>Selection, cut, copy and paste </li>
        </ol>
        <p>There are many different ways to tackle this problem. Everything from using a <code>&lt;div&gt;</code> for every cell, to drawing cells and borders on <code>&lt;canvas&gt;</code>. One thing you can't do is naively create a <code>&lt;table&gt;</code> with millions of rows, or even hyndreds of rows, and expect to efficiently render it or scroll around in it. However, the <code>&lt;table&gt;</code> element is, in the end, the right way go. It's for tabular data, and we have tabular data. It does a lot for us. Any other approach is going to require much more work and much more code. And, for what it's worth, which may not be much in an SPA, it is also semantically correct.</p>
        <p>We must also completely take over scrolling from the browser. </p>
        <p>How then do we make it work? Let's assume we have a table that fits comfortably in our APL workspace (our grid should handle both inverted and non-inverted data). At any one time, we are only going to display as much data as fits on the screen or window. Actually, a little more... we want the data to overflow a little bit down and to the right. This is not to make scrolling faster (as we shall see) by pre-drawing some out-of-sight content, but rather for two other reasons. There will almost always be a partial row on the bottom and a partial column on the right, so we certainly need at least one extra row and column. We also want to be able to resize the grid's container exposing more rows and columns, within reasonable limits, without having to resize the <code>&lt;table&gt;</code>, get more data, etc. Resizing a grid always results in more or less rows and columns at the bottom and right, never top and left. So given our screen size, and general limits to the size of the parent container, we can compute these dimensions. We will call this <strong><code>TableOverSize</code></strong>. This is a fairly fudgeable value. There is no precise way to compute it. If we make it too big, performance will suffer, if we make it too small, then the act of resizing will expose empty space, to be filled only when the resize is complete, which looks a little hokey.</p>
        <p>On the APL side, in the APL DOM, we will want to create a <code>&lt;table&gt;</code> element and all of its children elements once and only once. It will be the size specified by <code>TableOverSize</code>. We also need custom code to set the content and generate the innerHTML as this will be done repeatedly as we scroll around the grid. It must be as fast as possible. If a user is holding down a cursor key, scrolling through the grid, on every key press event we will be getting some data from the data source, constructing the innerHTML, and then sending it back to the browser.</p>
        <p>Next, we need to know exactly how many full rows and columns can be displayed at any given moment. This we call this the <strong><code>WindowSize</code></strong>, which is always smaller than <code>TableOverSize</code>.  If we scroll outside the <code>WindowSize</code> in any direction, we reset the <code>innerHTML</code> of the entire <code>&lt;table&gt;</code>, headers and all.  Resetting the headers very time we scroll solves the problem of  sticky headers, which you would think CSS <code>position: sticky;</code> solves, but it does really doesn't.</p>
        <p>Complicating <code>WindowSize</code> are optional row numbers and frozen columns. Let's define the scalar Boolean <strong><code>RowNumbers</code></strong> to be row numbers on or off, and the scalar integer <strong><code>FreezeColumns</code></strong> to be the number of frozen columns. Let's call the sum of these two properties <strong><code>FixedColumns</code></strong>. When computing <code>WindowSize</code>, which is only the scrollable area, we need to leave room for these fixed columns. We define <strong><code>TableSize</code></strong> to be the number of rows and columns we can display  including fixed columns, while <code>WindowSize</code> is the number of rows and columns we can display that will scroll. The relationship between the two is: </p>
        <pre><code>      TableSize ←→ WindowSize+0,FixedColumns
</code></pre>
        <p>If row numbers are off, and there are no frozen columns, then <code>TableSize</code> equals <code>WindowSize</code>.</p>
        <p>How do we compute <code>WindowSize</code>? The number of rows is easy. We know the height of our element, we know the height of our rows, we do the division. This value is fixed as long as there is not a resize event. Columns are another story. Each column can have a different width, so the number of columns we can display varies with the column that is currently displayed on the far left.  Let's first define ar few more names: </p>
        <p> <strong><code>Values</code></strong> is the data, like the <code>⎕WC</code> grid more or less.    <strong><code>DataSize</code></strong> is the shape of <code>Values</code>.</p>
        <p> <strong><code>DataCell</code></strong> is analogous to <code>⎕WC</code>'s <code>CurCell</code> - an index into <code>Values</code>, representing the current cell. </p>
        <p> <strong><code>WindowCell</code></strong> is the index of the current cell in the window.  </p>
        <p> <strong><code>TableCell</code></strong> is the index of the current cell in the table, which is just the window plus the number of fixed columns.</p>
        <p> <strong><code>WindowIndex</code></strong> is the location of upper left corner of the window in <code>Values</code>, similar to <code>⎕WC</code>'s <code>Grid.Index</code>.   </p>
        <p>In our DataGrid, we insist that the current cell is visible. This is unlike Excel or the <code>⎕WC</code> grid.  This means the following relationship holds:</p>
        <pre><code>      DataCell ←→ WindowIndex+WindowCell
</code></pre>
        <p>The number of columns that can be displayed at any given time is a function of the <code>WindowIndex</code>, the width of all the columns, and the available space. For each column, when it is in the left-most position, we need to know how many columns we can display. We call this vector <strong><code>ColumnsPerIndex</code></strong>, and it can be computed with:</p>
        <pre><code>  ComputeColumnsPerIndex←{
     s←+\¨(⍳≢⍵)↓¨⊂⍵
     1+s⍸¨⍺
 }   
</code></pre>
        <p>Where <code>⍵</code> is vector of column widths, and <code>⍺</code> is the available space. This value is useful when scrolling left. We know the column that will be the left-most column, and can then easily pick out the number of columns that can be displayd. By definition, when scrolling left, one new column comes into view on the left. A slightly different problem arises scrolling right. In order to get one new column  to come into view on the right, one or more columns may move off on the left, which in turn may actually bring more than one column in on the right. To make this easy it would be nice to know what column should be the left-most column when a given column is being scrolled into view on the right. We call this the <strong><code>ScrollIntoViewIndex</code></strong> given by:   </p>
        <pre><code>   ComputeScrollIntoViewIndex←{
     n←⍳≢⍵
     (⍵/n)[n⍳⍨∊n+⍳¨⍵]
 }
</code></pre>
        <p>where <code>⍵</code> is the <code>ColumnsPerIndex</code> vector. With these two vectors in hand, we can scroll left and right with ease. </p>
        <p>When are grid is created, or anytime a grid is resized, most of these values must be recomputed. This is done with the <code>Resize</code> function:</p>
        <pre><code> Resize←{
     t←⍺
     p←t.Parent
     t.AvailableWidth←p.Width-+/t.FixedColumns↑t.FullWidths
     t.ColumnsPerIndex←t.AvailableWidth ComputeColumnsPerIndex t.RowNumbers↓t.FullWidths
     0∊t.ColumnsPerIndex:0
     t.ScrollIntoViewIndex←ComputeScrollIntoViewIndex t.ColumnsPerIndex
     t.RowsToDisplay←p.Height ComputeRowsToDisplay 0
     t.WindowSize←t.RowsToDisplay,(1⊃t.WindowIndex)⊃t.ColumnsPerIndex
     ∨/t.WindowSize&lt;1:0
     t.WindowCell←t.WindowCell⌊t.WindowSize-1
     t.DataCell←t.WindowIndex+t.WindowCell
     t.TableCell←t.WindowCell+0,t.FixedColumns
     Refresh t
 } 
</code></pre>
        <p>With these values in hand, scrolling around is straight forward. For example, scrolling to the right is done as follows:</p>
        <pre><code>MoveWindowRight←{
     t←⍵
     c←1⊃t.DataCell
     i←c⊃t.ScrollIntoViewIndex
     t.WindowIndex[1]←i
     t.WindowSize[1]←i⊃t.ColumnsPerIndex
     t.WindowCell[1]←c-i    
     t.TableCell←t.WindowCell+0,t.FixedColumns
     _←Refresh t
     0
 }
</code></pre>
        <p>Once we have mastered scrolling one row or column at a time, up or down, left or right, then Page Up, Page Down, Home, End, etc., are all easy. </p>
        <p>In a future post we will look at editing, and various edit modes that mimic Excel behavior. We are also going to have to figure out how to put scroll bars on this thing.</p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2024 Paul S. Mansour</p>
    </footer>
  </body>
</html>
