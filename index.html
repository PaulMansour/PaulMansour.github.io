<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <h3>"You don't know how bad your design is until you write about
      it."</h3>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/an-abacus-application">An Abacus Application</a>
          </h1>
          <h2>June 30, 2024</h2>
        </header>
        <p>To figure out and demonstrate how to write an application in Abacus, we need a useful test application. At this point, we don't even know what we need to know, we don't know the tools we need, how the tools should be structured and fit together. We need a test app to help us find out.    The app must be simple enough to easily understand, but complex enough to explore all the major functionality of the framework. A CSV file viewer and editor will fit the bill. This will require a high-performance, editable datagrid, menus, progress bars, message boxes, confirmation boxes, dialog boxes for properties and settings and more. Furthermore, we want to be be able to run the application locally, as a desktop app, or remotely as a single page web app (SPA). Let's imaginatively name it the "Abacus CSV Editor". It might even be a useful app!</p>
        <p>What follows is a first pass at structuring a framework for building apps in Abacus.</p>
        <p>We will need a <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/CSVEditor">namepace</a> to encapsulate the code for the app. This will be a relatively simple app, so a single namespace will hold all the code. A complex app will generally require splitting things up into more namespaces. This namespace (let's call it the <strong>application namespace</strong>) will contain a <strong>build function</strong> that builds an APL DOM for the app. Here is the build function for the CSV Editor:</p>
        <pre><code>Build←{
     d←A.NewDocument''
     b←A.GetBody d
     a←b A.AutoComplete.New''
     d.AutoCompleteElement←a
     h←b A.New'header'
     h1←h A.New'h1' 'filename'
     mb←b BuildMenu''
     m←b A.New'main'
     g←m A.DataGrid.New''
     f←b A.New'footer'
     h2←f A.New'h2' 'x rows by n columns'
     d.Theme←##.Themes.Dark 0
     d.Layout←##.Layouts.Doric d.Theme
     d.Style←CSS d.Theme
     d
 }  
</code></pre>
        <p>The build function creates and returns a document. It will generally have calls to the  main Abacus API (<code>A</code>), and of course it can call custom sub functions (like <code>BuildMenu</code> above) to keep things manageable. This is the heart of the app. It defines the UI, and all the callbacks to events on the UI. For a single user desktop app, the function will be run once. For a multi-user web app, this function will be run everytime a user logs in, returning the rendered document to their browser. All state is managed in the document in APL. For a multi-user app, the document is a <strong>session</strong>.</p>
        <p>The application workspace will also have a something like this <code>CreateApplication</code> function:  </p>
        <pre><code>CreateApplication←{
     a←A.NewApplication 0
     a.Name←'Abacus CSV Editor'
     a.BuildFunction←'#.Abacus.CSVEditor.Build'
     a
 }
</code></pre>
        <p>This formally creates and returns an Abacus application object. At a minimum it will specify the name of the application and the build function. Let's take a look at the internals of <code>NewApplication</code>: </p>
        <pre><code>NewApplication←{
     a←⎕NS''
     s←#.Rumba.Core.NewServer 0
     s.Trap←0
     s.UseCongaHTTP←1
     s.Context←⎕THIS
     s.OnRequest←'OnRequestRumba'
     s.OnWebSocketUpgrade←'OnWSUpgradeRumba'
     s.OnWebSocketReceive←'OnWSReceiveRumba'
     s.Application←a
     a.Name←'[Application]'
     a.Server←s
     a.Sessions←⍬
     a.BuildFunction←''
     a
 }
</code></pre>
        <p>The first thing it does is create a Rumba server. The server is not needed if the app is to be run as a desktop app, but it costs nothing to create, so we throw it in regardless. The server knows the application, and the application knows the server. The application requires a name and a build function. The application will track sessions (an array of documents) if it is run as a multi-user web app. </p>
        <p>So, we have created an Abacus application object and provided it our build function. With the application object in hand, we can start up a web app using the Abacus API function <code>StartWebApplication</code>: </p>
        <pre><code>StartWebApplication←{
     s←⍺.Server
     s #.Rumba.Core.Start 0
 }
</code></pre>
        <p>The Rumba server is now listening for new connections, will run the build function and deliver a document to the client, establish a websocket, and respond to user actions on the client.</p>
        <p>Alternatively, we can start up a desktop app with the API function <code>StartDesktopApplication</code>:</p>
        <pre><code>StartDesktopApplication←{
     d←(⍎⍺.BuildFunction)0
     d.Style←CollectCSS d
     d.Caption←⍺.Name
     NewForm d
 }
</code></pre>
        <p>This runs the build function to create the document, then, in <code>NewForm</code>, creates an HTMLRenderer object and returns it.   </p>
        <p>In a future post we will look at styles, themes and layouts, which we are still trying to figure out, and bring some order to the chaos.  </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/a-fair-mutex">A Fair Mutex</a>
          </h1>
          <h2>June 24, 2024</h2>
        </header>
        <p>A mutex may be <em>fair</em> or <em>unfair</em>. A fair mutex lets threads into the  critical section in the order in which they request the lock. That is, FIFO; the thread waiting the longest, will be serviced first. That certainly seems fair.</p>
        <p>An unfair mutex provides no such guarantee. This means that a thread can be starved - it may  never be allowed to proceed into the critical section. That certainly seems unfair.</p>
        <p>In Dyalog:</p>
        <pre><code>:Hold TokenString
    ...
    critical section
    ...
:EndHold
</code></pre>
        <p>implements an unfair mutex. And it <strong>will</strong> starve threads. A newly created thread that hits the <code>:Hold</code> will be serviced before any existing threads that may be waiting. The same is true for:</p>
        <pre><code>⎕TGET TokenInt
...
critical section
...
⎕TPUT TokenInt
</code></pre>
        <p>No doubt the interpreter uses the same algorithm for servicing waiting threads in both cases. Unfair mutex implementations are the norm in the industry, for reasons I don't fully understand. A cursory glance at the literature indicates that unfair mutexes are more efficient in some way.  Presumably if it matters not in what order waiting threads are serviced, the interpreter has less to keep track of. One example often given is when a thread releases a mutex and then tries to reaquire it (not a good pattern I think anyway), a fair mutex will put it at the end of the line, whereas  an unfair mutex can put it at the head the line, and avoid some thread switching. It is not clear to me if these efficiency arguments hold for the type of threads that the Dyalog interpreter implements.     </p>
        <p>Anyway, the question arises, can we implement a fair mutex in Dyalog? Let's look at a very simple implementation. Using the token pool we can create a new mutex object:</p>
        <pre><code>NewMutex←{
     m←⎕NS''
     m.Key←{}&amp;0
     m⊣⎕TPUT m.Key
 }
</code></pre>
        <p>The mutex has a key, which must be aquired to gain access. At the same time, the key must be changed for the next thread. Any unique key value per thread could be used. We use the thread ID for convenience.</p>
        <p>To initialize the mutex, we burn a thread and then put the key into the token pool.                                                       </p>
        <p>To enter the critical section, a thread has to wait for the current mutex key, and then create a new key using the <code>Lock</code> function, which takes the mutex as the right argument:                                                      </p>
        <pre><code>Lock←{
     k←⍵.Key
     ⍵.Key←⎕TID
     ⎕TGET k
 }
</code></pre>
        <p>When it exits the critical section, the thread has to unlock the mutex by putting the key into the token pool:                                                      </p>
        <pre><code>Unlock←{
     ⊢⎕TPUT ⎕TID
}
</code></pre>
        <blockquote>
          <p>the <code>⊢</code> is needed only because I think there is a bug in the intepreter. In test code, I use <code>⎕TSYNC ⎕TNUMS~0</code>  to know when all the threads have completed. Without the <code>⊢</code>,  the <code>⎕TSYNC</code> fails because "VALUE ERROR: No result was provided when the context expected one." This does not seem right. Must have something to do with the fact the result of <code>⎕TPUT</code> is shy.</p>
        </blockquote>
        <p>The <code>Unlock</code> function does not really need to know about the particular mutex instance, as the key is simply the thread id.</p>
        <p>I don't think it is as simple to implement a fair mutex using <code>:Hold</code>, as it is not natural construct for waiting on one token and then releasing a different token.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/how-to-center-a-dialog-element">How to Center
            a Dialog Element</a>
          </h1>
          <h2>May 29, 2024</h2>
        </header>
        <p>How to center a <em>modal</em> dialog box to be precise.</p>
        <p>TL;DR:</p>
        <pre><code>     
</code></pre>
        <p>Yes, that's right. Nothing. Nada. Zero. Zilch.</p>
        <p>Now for the full story.</p>
        <p>I have been using a <a href="https://www.toolofthought.com/posts/beware-the-blur">ubiquitous but archaic and problematic technique</a> to center a modal dialog box in the viewport. On this morning's drive listening to the <a href="https://syntax.fm/show/775/components-we-need-on-every-project">current episode</a> of the excellent web dev podcast <a href="https://syntax.fm/">Syntax</a>, the hosts hinted at another method for centering using the CSS <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/inset">inset</a> property, which I was unfamiliar with. It turns out this property is just shorthand for top, right, bottom and left. Looking for more information, I stumbled on this <a href="https://www.youtube.com/shorts/9cSL5dP4rgM">video short</a>. Could it be that simple? All we need is <code>inset:0</code> and <code>margin:auto</code>? It turns out it is even simpler!</p>
        <p>It is useful to inspect the user-agent styling for <code>&lt;dialog&gt;</code> (in Chrome):</p>
        <pre><code>  dialog:-internal-modal {
    position: fixed;
    top: 0px;
    bottom: 0px;
    max-width: calc((100% - 6px) - 2em);
    max-height: calc((100% - 6px) - 2em);
    overflow: auto;
}    
  dialog {
    display: block;
    position: absolute;
    left: 0px;
    right: 0px;
    width: fit-content;
    height: fit-content;
    color: -internal-light-dark(black, white);
    margin: auto;
    border-width: initial;
    border-style: solid;
    border-color: initial;
    border-image: initial;
    padding: 1em;
    background: -internal-light-dark(white, black);
}
</code></pre>
        <p>Note the default values for the <code>&lt;dialog&gt;</code> element properties <code>position</code>, <code>left</code>, <code>right</code>, and <code>margin</code>. Further note that that when the <code>&lt;dialog&gt;</code> element is opened in a modal state, additional properties are defaulted, and some are overridden. The net result is that for a modal dialog box, the default value of <code>inset</code> is <code>0</code>, and the default value of <code>margin</code> is <code>auto</code>. Therefore, to center a modal dialog, <strong><em>nothing needs to be done</em></strong>.    But it is likely you have a CSS reset that sets all margins to <code>0</code>. In that case you will need: </p>
        <pre><code>    margin:auto;
</code></pre>
        <p>I don't think it likely that <code>inset</code> will have a different value than <code>0</code>, so no need to explicitly set it. </p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2024 Paul S. Mansour</p>
    </footer>
  </body>
</html>
