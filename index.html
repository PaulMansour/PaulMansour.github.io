<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/anatomy-of-a-query">Anatomy of a Query</a>
          </h1>
          <h2>October 23, 2022</h2>
        </header>
        <p>A FlipDB query is essentially a highly structured dfn or collection
        of dfns; it is an ordered set of names and expressions. It is thus
        much less sophisticated than an SQL query. This simplicity, however,
        brings certain benefits. It means that we can step through the
        query line by line (one name and expression at a time), and evaluate,
        inspect, or even change the code. In other words, the query may
        be traced just like a function in the Dyalog session, and in fact
        the FlipDB UI has its own tracer. This is not possible with SQL
        - an SQL query is not made up of individual, executable, traceable
        steps.</p>
        <p>A FlipDB query usually starts with a specific table, for a default
        context, and is then composed of the following ordered sections
        or clauses:</p>
        <ol>
          <li>Precomputed expressions</li>
          <li>Where statements</li>
          <li>Where-not statements</li>
          <li>Group-by expressions</li>
          <li>Select expressions</li>
          <li>Order-By clause</li>
          <li>Having statements</li>
        </ol>
        <p>Each section (except #6) is an ordered set of names and expressions,
        and may be thought of as a dfn.</p>
        <h2>Precomputed Expressions</h2>
        <p>
          Precomputed expressions are evaluated before any
          <em>where</em>
          statements are applied, and thus operate on the entire table.
          These may be used to specify constants, computed columns and
          aggregate values. (These latter two are especially valuable for
          expressions that may be row dependent, and thus change after
          the where clause is applied.) For example:
        </p>
        <table>
          <thead>
            <tr>
              <th class="left">Name</th>
              <th class="left">Expression</th>
              <th class="center"></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="left">
                <code>YearEndTarget</code>
              </td>
              <td class="left">
                <code>2000000</code>
              </td>
              <td class="center"></td>
            </tr>
            <tr>
              <td class="left">
                <code>GrandTotalBalance</code>
              </td>
              <td class="left">
                <code>sum Balance</code>
              </td>
              <td class="center"></td>
            </tr>
            <tr>
              <td class="left">
                <code>ComputedInterest</code>
              </td>
              <td class="left">
                <code>Balance * Rate / 1200</code>
              </td>
              <td class="center"></td>
            </tr>
            <tr>
              <td class="left">
                <code>TotalComputedInterest</code>
              </td>
              <td class="left">
                <code>sum ComputedInterest</code>
              </td>
              <td class="center"></td>
            </tr>
          </tbody>
        </table>
        <p>The FlipDB tracer steps through these lines just like the Dyalog
        APL tracer steps through a function. At each line variables may
        be inspected and played around with. Also like a dfn, a defined
        name may be referenced in the following lines of the section. The
        defined names may then be referenced in subsequent sections or
        clauses, which is of course the whole point of this clause.</p>
        <h2>Where and Where-Not Statements</h2>
        <p>
          Next comes
          <em>where</em>
          statements, a set of zero or more Boolean valued expressions:
        </p>
        <table>
          <thead>
            <tr>
              <th class="left">Expression</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="left">
                <code>Balance &gt; 100000</code>
              </td>
            </tr>
            <tr>
              <td class="left">
                <code>State in 'NY,NJ,CT'</code>
              </td>
            </tr>
            <tr>
              <td class="left">
                <code>LTV &gt; 80</code>
              </td>
            </tr>
          </tbody>
        </table>
        <p>
          These expression are not named by the user, but for tracing purposes
          the system assigns them names
          <code>Where1</code>
          ,
          <code>Where2</code>
          ,
          <code>Where3</code>
          , etc. These statements could be packed into a one-liner, but
          there are significant advantages for the user in keeping the
          expressions as simple and short as possible, for tracing, debugging,
          and performance.
        </p>
        <p>
          The tracer steps through these line by line, allowing the user
          to see exactly how many rows are restricted by each statement,
          and the net effect of each statement. At the end, the statements
          are
          <em>and'ed</em>
          together:
        </p>
        <pre>
          <code>      Where←∧/Where1 Where2 Where3 ... 
</code>
        </pre>
        <p>
          Where not statements are similar to where statements, except
          they are
          <em>or'ed</em>
          together:
        </p>
        <pre>
          <code>      WhereNot←∨/WhereNot1 WhereNot2 WhereNot3... 
</code>
        </pre>
        <p>The tracer steps through these as well. The final boolean restriction
        is then simply:</p>
        <pre>
          <code>      Where∧~WhereNot
</code>
        </pre>
        <h2>Group-By Expressions</h2>
        <p>If the query is to be grouped, then one or more group expressions
        may be applied. For example:</p>
        <table>
          <thead>
            <tr>
              <th class="left">Name</th>
              <th class="left">Expression</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="left">
                <code>GeographicDistribtion</code>
              </td>
              <td class="left">
                <code>State</code>
              </td>
            </tr>
            <tr>
              <td class="left">
                <code>Coupon</code>
              </td>
              <td class="left">
                <code>.5 range Rate</code>
              </td>
            </tr>
          </tbody>
        </table>
        <p>These expressions are evaluated on the rows remaining after
        the Where and Where Not clauses are applied. These too are stepped
        through in the tracer, allowing detailed inspection.</p>
        <h2>Select Expressions</h2>
        <p>After the optional grouping clause, the select expressions are
        evaluated. For ungrouped queries these will often be a simple list
        of column names. For grouped queries generally all of the expressions
        are aggregate expressions of one sort or another:</p>
        <table>
          <thead>
            <tr>
              <th class="left">Name</th>
              <th class="left">Expression</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="left">
                <code>NumberOfLoans</code>
              </td>
              <td class="left">
                <code>count LoanID</code>
              </td>
            </tr>
            <tr>
              <td class="left">
                <code>TotalBalance</code>
              </td>
              <td class="left">
                <code>sum Balance</code>
              </td>
            </tr>
            <tr>
              <td class="left">
                <code>Percent</code>
              </td>
              <td class="left">
                <code>percentDown Balance</code>
              </td>
            </tr>
            <tr>
              <td class="left">
                <code>PercentOfTable</code>
              </td>
              <td class="left">
                <code>TotalBalance / GrandTotalBalance</code>
              </td>
            </tr>
          </tbody>
        </table>
        <p>Note that the last expression is making use of a name defined
        two lines above it, as well as a name defined in the first section
        of computed values. Yet again, the tracer lets us step through
        these expression line by line.</p>
        <h2>Order-By</h2>
        <p>The order-by clause is the only section that is not a set of
        names and expressions. Rather it is a list of names defined in
        the Select clause and a sort directive. For example:</p>
        <table>
          <thead>
            <tr>
              <th class="left">Name</th>
              <th class="left">Direction</th>
              <th class="center"></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="left">
                <code>TotalBalance</code>
              </td>
              <td class="left">
                <code>Down</code>
              </td>
              <td class="center"></td>
            </tr>
          </tbody>
        </table>
        <p>The tracer does not step through the order-by clause line by
        line, as there is little value added.</p>
        <h2>Having Expressions</h2>
        <p>
          Finally, one or more
          <em>having</em>
          expressions may be defined, which are analogous to
          <em>where</em>
          statements, except they are applied to the sorted result. For
          example:
        </p>
        <table>
          <thead>
            <tr>
              <th class="left">Expression</th>
              <th class="left"></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="left">
                <code>TotalBalance &gt; 100000</code>
              </td>
              <td class="left"></td>
            </tr>
          </tbody>
        </table>
        <p>These expressions may be traced just like where expressions.</p>
        <h2>Conclusion</h2>
        <p>A FlipDB query is an ordered set of names and expressions that
        both defines the query and also explicitly specifies how it is
        to be executed. Whereas an SQL RDBMS might have a query optimizer
        that selects a query execution path, FlipDB, for better or worse,
        just does what the user tells it, in the order the user tells it.
        While no doubt there are a number of costs to this simple model,
        there are also major benefits. The traceability of a FlipDB query
        is a direct consequence of the fact that the query is an ordered
        set of names and expressions. That is, we can read the query incrementally
        from top to bottom unlike an SQL query where we must mentally process
        and parse the query to the end before we can understand what is
        happening at the beginning. The computer and the user or author
        read and process the query in exactly the same way.</p>
        <p>In a future post we will look at how FlipDB deals with joins,
        views, sub-queries, and all the complexities that arise when data
        is in a different table.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/composerules-revisited">ComposeRules Revisited</a>
          </h1>
          <h2>October 7, 2022</h2>
        </header>
        <p>
          In the previous post we looked at
          <a href="/posts/constructing-css-in-apl">constructing CSS programatically</a>
          . The
          <code>ComposeRules</code>
          function looked like:
        </p>
        <pre>
          <code>ComposeRules←{
     ⍝ ⍵ ←→ Vector of CSS Rules
     ⍺←0
     0=≢⍵:''
     nl←⎕UCS 13
     ⊃,/((⍺&gt;0)/nl),⍺{
         0=≢⍵.Selector:⍺ ComposeRules ⍵.Rules
         b←(4×⍺)⍴' '
         s←b,⍵.Selector,' {',nl
         s,←⍺ ComposeDeclarations ⍵
         s,←¯1↓(⍺+1)ComposeRules ⍵.Rules
         s←s,b,'}',2⍴nl
         s
     }¨⍵
 }
</code>
        </pre>
        <p>As is often the case when reviewing a function after a little
        time has passed, we wonder why we wrote it the way we did. Often
        there is a good reason, but also often there is not a good reason.</p>
        <p>
          There are at least two things that are bothersome about this
          function. First, there is a nested dfn. I don't like to do this
          without a good reason, and I had a nagging feeling there was
          in fact no good reason. I was probably just in a hurry to enhance
          the function to handle nested rules. Second, and directly related,
          the main function is called recursively by explicit name, rather
          than using self-reference (
          <code>∇</code>
          ). A refactoring is in order:
        </p>
        <pre>
          <code>ComposeRules←{
     ⍝ ⍵ ←→ Vector of CSS Rules
     ⍺←0
     0=≢⍵:''
     nl←⎕UCS 13
     1=≡⍵:⊃,/((⍺&gt;0)/nl),⍺ ∇¨⍵
     0=≢⍵.Selector:⍺ ∇ ⍵.Rules
     b←(4×⍺)⍴' '
     s←b,⍵.Selector,' {',nl
     s,←⍺ ComposeDeclarations ⍵
     s,←¯1↓(⍺+1)∇ ⍵.Rules
     s←s,b,'}',2⍴nl
     s
 }
</code>
        </pre>
        <p>Removing the nested dfn allows recursion via self-reference
        - the whole thing is much nicer.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/constructing-css-in-apl">Constructing CSS in
            APL</a>
          </h1>
          <h2>September 30, 2022</h2>
        </header>
        <p>
          Once we have mastered
          <a href="posts/a-document-object-model-in-apl">building HTML
          pages</a>
          , the next task is constructing CSS in an efficient and orderly
          way.
        </p>
        <p>While is it not as important to manipulate CSS the same way
        we need to be able to manipulate the DOM, we still want to create
        CSS programmatically, to allow for properties that depend on variables,
        to avoid catenating strings, specifying braces, colons and semicolons,
        and to not worry about getting the nesting right. We don't want
        to write CSS by hand in text files.</p>
        <p>We can do this with 3 fairly simple functions. One for creating
        a new rule:</p>
        <pre>
          <code>NewRule←{
     ⍝ ⍺ ←→ [Parent]
     ⍝ ⍵ ←→ Selector e.g. 'h1' 'h1 h2' 'header&gt;h1', etc.
     ⍺←0
     r←⎕NS''
     r.Selector←⍵
     r.Rules←⍬
     ⍺=0:r
     ⍺.Rules,←r
     r
 }
</code>
        </pre>
        <p>One for composing the rules:</p>
        <pre>
          <code>ComposeRules←{
     ⍝ ⍵ ←→ Vector of CSS Rules
     ⍺←0
     0=≢⍵:''
     nl←⎕UCS 13
     ⊃,/((⍺&gt;0)/nl),⍺{
         0=≢⍵.Selector:⍺ ComposeRules ⍵.Rules
         b←(4×⍺)⍴' '
         s←b,⍵.Selector,' {',nl
         s,←⍺ ComposeDeclarations ⍵
         s,←¯1↓(⍺+1)ComposeRules ⍵.Rules
         s←s,b,'}',2⍴nl
         s
     }¨⍵
 }
</code>
        </pre>
        <p>And one subfunction for composing declarations:</p>
        <pre>
          <code>ComposeDeclarations←{
     ⍺←0
     nl←⎕UCS 13
     n←{⍵/⍨~(⊃¨⍵)∊⎕A}⍵.⎕NL ¯2
     0=≢n:''
     v←⍕¨⍵⍎¨n
     p←'-'@('_'∘=)¨n
     b←(4×⍺+1)⍴' '
     ⊃,/p{b,⍺,': ',⍵,';',nl}¨v
 }
</code>
        </pre>
        <p>Consider a single, simple rule:</p>
        <pre>
          <code>      r←NewRule 'h1'
</code>
        </pre>
        <p>Specifying declarations is done by assignment:</p>
        <pre>
          <code>      r.margin←'1rem'
      r.font_size←'2rem'
</code>
        </pre>
        <p>
          The
          <code>ComposeRules</code>
          function returns the CSS:
        </p>
        <pre>
          <code>      ComposeRules r
h1 {
    font-size: 2rem;
    margin: 1rem;
}
</code>
        </pre>
        <p>
          Of course a style sheet will contain many rules, often nested.
          The
          <code>NewRule</code>
          function takes a parent rule as an optional left argument:
        </p>
        <pre>
          <code>      p←NewRule '@media print'
      r←p NewRule 'h1'
      r.font_size←'18pt' 
      r←p NewRule 'h2'
      r.font_size←'16pt'
      ComposeRules p
@media-print {
    h1 {
        font-size: 18pt;
    }
    h2 {
        font-size: 16pt;
    }
}
</code>
        </pre>
        <p>
          This allows us to bury the catenation or accumulation of rules.
          We can also reuse the same variable name for the result of
          <code>NewRule</code>
          , normally a bad practice, but useful in this case, when there
          could be hundreds of rules that need to be specified, and we
          don't want to have to name them all.
        </p>
        <p>Having a parent rule is useful as it means we have only one
        item to explicitly name and track. But often there is no parent,
        just a list of rules with no hierarchy. We can accumulate rules
        using a parent rule with no selector:</p>
        <pre>
          <code>      s←NewRule ''
      r←s NewRule 'h1'
      r.font_size←'2em' 
      r←s NewRule 'h2'
      r.font_size←'1.5em'
      ComposeRules s
h1 {
    font-size: 2em;
}
h2 {
    font-size: 1.5em;
}
</code>
        </pre>
        <p>
          This lets us avoid complicating things with a Style object. There
          is only one object, a rule object, and it can contain sub rules.
          And
          <code>ComposeRules</code>
          can process multiple sets of rules:
        </p>
        <pre>
          <code>      ComposeRules s p
h1 {                    
    font-size: 2em;     
}                       
                        
h2 {                    
    font-size: 1.5em;   
}                       
                        
@media print {          
                        
    h1 {                
        font-size: 18pt;
    }                   
                        
    h2 {                
        font-size: 16pt;
    }                   
}                       
</code>
        </pre>
        <p>
          These rules can be injected directly into the APLDOM using the
          <code>Style</code>
          property:
        </p>
        <pre>
          <code>       d←New'html'
       hd←d New'head'
       d.Style←s
       DOM2HTML d
&lt;!DOCTYPE html&gt;      
&lt;html&gt;               
  &lt;head&gt;             
    &lt;style&gt;          
        h1 {                 
          font-size: 2em;  
           }                    
                     
        h2 {                 
          font-size: 1.5em;
           }                    
    &lt;/style&gt;         
  &lt;/head&gt;            
&lt;/html&gt;          
</code>
        </pre>
        <p>
          HTML elements may have their own Style property, to allow for
          components to be delivered with their own styles. The idea is
          do something similar to
          <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components">Web
          Components</a>
          . This is an area where
          <a href="https://github.com/the-carlisle-group/Abacus">Abacus</a>
          needs much more work, hopefully soon.
        </p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2022 Paul S. Mansour</p>
    </footer>
  </body>
</html>
