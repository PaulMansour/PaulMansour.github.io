<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/reference">Reference</a>
        <a href="/donts">Don'ts</a>
        <a href="/hmmm">Hmmm</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/a-new-workspace-file-format">A New Workspace
            File Format</a>
          </h1>
          <h2>February 26, 2022</h2>
        </header>
        <p>
          I have documented how namespace scripts are a
          <a href="/posts/building-namespace-scripts">practical and efficient</a>
          way to store and transport source code. I have also documented
          that
          <a href="/posts/the-problem-with-namespace-scripts">they have
          problems</a>
          that prevent using them to their full potential.
        </p>
        <p>When we are able to define both scripted and unscripted namespaces,
        and when we are able to define the root namespace, all in a script,
        many very useful possibilites follow effortlessly.</p>
        <p>
          First the Dyalog interpreter should be able to simply open a
          script that defines the root. Thus if we have a simple text file
          <code>myworksapce.apln</code>
          :
        </p>
        <pre>
          <code>:Namespace #
   ⎕IO←0
   A←⍳10
   :Namespace MySpace 
   :Type unscripted
       f←{+/⍵}
   :EndNamespace 
:EndNamespace
</code>
        </pre>
        <p>Then in the session all we need to do is:</p>
        <pre>
          <code>      )load myworkspace.apln
</code>
        </pre>
        <p>
          In other words, we have a new, non-binary file format for the
          workspace. Furthermore, it zips up very well, so we could have,
          say,
          <code>.dwsx</code>
          files that are compressed text versions of dws files, analagous
          to Microsoft Excel
          <code>.xls</code>
          and
          <code>.xlsx</code>
          files. (In my sample, a 13 MB binary workspace is 750 KB as compressed
          text.)
        </p>
        <p>
          All sorts of possibilites arise with a zipped
          <code>.dwsx</code>
          file format, as it can contain, like
          <code>.xlsx</code>
          files, multiple files and folders. For example, it could contain
          a
          <a href="https://help.dyalog.com/18.0/#UserGuide/Installation%20and%20Configuration/Configuration%20Files.htm#Configuration_Files">configuration
          file</a>
          . It could have multiple namespace scripts and only load and
          fix code on demand.
        </p>
        <p>
          A
          <code>.dwsx</code>
          would probably not be appropriate for developement, as it would
          have the same drawbacks as a binary
          <code>.dws</code>
          file, but for sharing code, transport and application distribution
          it may be ideal. A non-zipped
          <code>.apln</code>
          file, however, may be quite useful for development: Open a clear
          workspace, start coding,
          <code>)saveastext</code>
          and have a text file representation of the workspace.
        </p>
        <p></p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/aaronhsuquote">Aaron Hsu at Function Conf 2022</a>
          </h1>
          <h4>January 27, 2022</h4>
        </header>
        <p>
          Aaron Hsu is giving a
          <a href="https://confengine.com/conferences/functional-conf-2022/speaker/interview/aaron-w-hsu?utm_source=twitter&amp;utm_medium=organic_social&amp;utm_campaign=FnConf-speaker-profiles">talk
          at Functional conference 2022</a>
        </p>
        <p>In the interview Aaron says:</p>
        <blockquote>
          <p>More is accomplished by understanding the whole, than optimizing
          the part.</p>
        </blockquote>
        <p>That is a first class aphorism.</p>
        <p>
          It reminded me of the saying
          <em>premature optimization is the root of all evil</em>
          , I think extracted from the full Donald Knuth quote:
        </p>
        <blockquote>
          <p>The real problem is that programmers have spent far too much
          time worrying about efficiency in the wrong places and at the
          wrong times; premature optimization is the root of all evil (or
          at least most of it) in programming</p>
        </blockquote>
        <p>Aaron's formulation says more with less; it has a positive outlook.</p>
        <p>Looking forward to seeing his presentation.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/vfi-with-csv">⎕VFI with ⎕CSV</a>
          </h1>
          <h2>January 25, 2022</h2>
        </header>
        <p>
          A long-standing problem with
          <a href="https://help.dyalog.com/latest/Content/Language/System%20Functions/vfi.htm">⎕VFI</a>
          is that it does not accept the traditional minus sign (only an
          APL high-minus), nevermind thousand separators, a plus sign in
          front of E notation, and a million other things that Excel users
          might produce in a CSV file headed your way. It takes a lot of
          preprocessing to take outside data and run it through
          <code>⎕VFI</code>
          .
        </p>
        <p>
          The relatively new sytem function
          <a href="https://help.dyalog.com/16.0/Content/Language/System%20Functions/csv.htm">⎕CSV</a>
          handles all the specific cases noted above when converting columns
          to numeric. Furthermore it works on in-memory data, so we don't
          need a file. This makes it trivial to write an implementation
          of
          <code>⎕VFI</code>
          using
          <code>⎕CSV</code>
          :
        </p>
        <pre>
          <code>vfi←{
     ⍝ ⎕VFI using ⎕CSV
     ⍝ ⍵ ←→ Char Mat
     ⍝ ← ←→ Num vector
     ⍺←-2*31
     o←⊂'Separator' '⎕'
     o,←⊂'Thousands' ','
     o,←⊂'Fill'⍺
     r←,(⎕CSV⍠o)(,⍵,⎕UCS 13)'S' 3
     v←r≠⍺
     v(v×r)
 }   
</code>
        </pre>
        <p>Note:</p>
        <p>
          1. The argument here is a char mat, not a delimited vector like
          <code>⎕VFI</code>
          .
        </p>
        <p>2. The separator is arbitrary, and should not exist in the argument.
        Probably should check for this.</p>
        <p>
          3. There is currently a bug in
          <code>⎕CSV</code>
          where it throws an error on a number with a thousand separator
          and no decimal - so don't adapt for production yet!
        </p>
        <p>4. We should probably test there are no line endings in the
        argument.</p>
        <p>
          This is almost as fast as
          <code>⎕VFI</code>
          with no preprocessing, and much faster than a solution with
          <code>⎕VFI</code>
          that requires preprocessing for negative signs and thousand separators.
        </p>
        <p>However, there are still things we might want to preprocess
        for, like parentheses for a negative number, leading currency characters,
        and trailing percentage signs. Here is a first attempt that handles
        all three cases which no doubt can be improved:</p>
        <pre>
          <code>vfiPreprocess←{
     ⍝ ⍵ ←→ Char mat
     ⍝   ←→ Modified char mat
     ⎕IO ⎕ML←0 1
     ~∨/'$%('∊⍵:⍵
     m←⍵
     m[⍸m[;0]='$';0]←' '
     lp←m[;0]='('
     ljust←{⍵⌽⍨+/∧\' '=⍵}
     m[;]←ljust⌽m
     rp←m[;0]=')'
     m[⍸m[;0]='%';0]←' '
     n←⍸lp∧rp
     m[n;0]←' '
     m[;]←ljust⌽m
     m[n;0]←'-'
     m
 }
</code>
        </pre>
        <p>
          Note that
          <code>m[;]←</code>
          is used rather than
          <code>m←</code>
          because the former does the assignment in place, while the latter
          makes a copy.
        </p>
        <p>
          When processing
          <code>CSV</code>
          files, it is useful to apply
          <code>⎕CSV</code>
          first with no numeric conversion bringing everything into the
          workspace as char columns, and then applying
          <code>vfi</code>
          to the columns we want to convert to numeric. Not only does this
          technique allow us to apply our own custom preprocess function,
          but it provide the ability to analyze the before-and-after conversion.
        </p>
        <p></p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2021 Paul S. Mansour</p>
    </footer>
  </body>
</html>
