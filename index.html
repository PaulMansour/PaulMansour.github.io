<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/a-document-object-model-in-apl">A Document
            Object Model in APL</a>
          </h1>
          <h2>September 22, 2022</h2>
        </header>
        <p>With a web browser now effectivley built-in to the interpreter,
        constructing and manipulating HTML and the DOM in a simple and
        consistent way has never been more important. Explicitly catenating
        strings is no way to go through life. Lots of (my) old code looks
        like:</p>
        <pre>
          <code>       '&lt;h1&gt;',t,'&lt;/h1&gt;'
</code>
        </pre>
        <p>or barely better we might define tag as:</p>
        <pre>
          <code>        tag←{'&lt;',⍺,'&gt;',⍵,'&lt;/',⍺,'&gt;'}
</code>
        </pre>
        <p>
          And then tag this, that and the other, which all has to be catenated
          up. And then we enhance
          <code>tag</code>
          to take an argument with attributes. It doesn't get better. And
          when we are done, we have a horrific string, probably nested
          in various places by mistake, of hopefully valid HTML that we
          cannot manipulate in any meaningful way.
        </p>
        <p>
          Consider instead a single simple function
          <code>New</code>
          :
        </p>
        <pre>
          <code>   New←{
     ⍝ ⍺ ←→ [Parent, 0 - no parent]
     ⍝ ⍵ ←→ Tag [Content [Attributes]]
     ⍝ ← ←→ Element
     ⍺←0
     s←IsString ⍵
     t c a←s⊃(3↑⍵,⊂⍬)(⍵''⍬)
     e←⎕NS''
     e.Tag←,t
     e.Parent←⍺
     e.Content←''
     _←a SetAttributes e
     e⊣Add/⍺ e c
 }
</code>
        </pre>
        <p>We can now create an object for an element, and produce HTML
        from it:</p>
        <pre>
          <code>      h←New 'h1' 'My Title'
      DOM2HTML h
&lt;h1&gt;My Title&lt;/h1&gt;
</code>
        </pre>
        <p>Attributes may be specified by assignment:</p>
        <pre>
          <code>      h.class←'chapter'
      DOM2HTML h
&lt;h1 class="chapter"&gt;My Title&lt;/h1&gt;
</code>
        </pre>
        <p>Elements can be created as children:</p>
        <pre>
          <code>      d←New 'html'
      b←d New 'body'
      m←b New 'main'
      DOM2HTML d
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;main&gt;&lt;/main&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code>
        </pre>
        <p>Content can be directly assigned:</p>
        <pre>
          <code>      m.Content←h
      DOM2HTML d
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;main&gt;
      &lt;h1 class="chapter"&gt;My Title&lt;/h1&gt;
    &lt;/main&gt;
  &lt;/body&gt;
&lt;/html&gt;
~~~      
</code>
        </pre>
        <p>
          Producing HTML without explicit catenation is only a small part
          of the benefit. Consider the function
          <code>Elements</code>
          :
        </p>
        <pre>
          <code>Elements←{
     ⍝ ⍵ ←→ Element
     ⍝ ← ←→ Vector of ⍵ and all sub elements
     326≠⎕DR ⍵:⍬
     ⍵,{c←{0=≢⍵:⍬ ⋄ ⍵/⍨326=⎕DR¨⍵}⍵.Content
         0=≢c:⍬
         ⊃,/c,¨∇¨c}⍵
 } 
</code>
        </pre>
        <p>This traverses the DOM and yields a simple vector of all the
        elements:</p>
        <pre>
          <code>      e←Elements d
      e.Tag
┌────┬────┬────┬──┐
│html│body│main│h1│
└────┴────┴────┴──┘
</code>
        </pre>
        <p>
          With this function in hand, various covers like
          <code>ElementByID</code>
          or
          <code>ElementsByTag</code>
          are trivial to write. Now its easy to find all the h1 headers
          and change, say, their class.
        </p>
        <p>Tables are especially painful to deal with without the proper
        tooling. With a few helper functions to extract cells, we can manipulate
        HTML tables like an array programmer should:</p>
        <pre>
          <code>     t←NewTable ⍕¨3 4⍴⍳12
     c←BodyCells t
     c[;2].class←⊂'char'
     DOM2HTML t
&lt;table&gt;                       
  &lt;tbody&gt;                     
    &lt;tr&gt;                      
      &lt;td&gt;0&lt;/td&gt;              
      &lt;td&gt;1&lt;/td&gt;              
      &lt;td class="char"&gt;2&lt;/td&gt; 
      &lt;td&gt;3&lt;/td&gt;              
    &lt;/tr&gt;                     
    &lt;tr&gt;                      
      &lt;td&gt;4&lt;/td&gt;              
      &lt;td&gt;5&lt;/td&gt;              
      &lt;td class="char"&gt;6&lt;/td&gt; 
      &lt;td&gt;7&lt;/td&gt;              
    &lt;/tr&gt;                     
    &lt;tr&gt;                      
      &lt;td&gt;8&lt;/td&gt;              
      &lt;td&gt;9&lt;/td&gt;              
      &lt;td class="char"&gt;10&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;             
    &lt;/tr&gt;                     
  &lt;/tbody&gt;                    
&lt;/table&gt;                      
~~~ 
</code>
        </pre>
        <p>Finally we can take HTML and get back the DOM:</p>
        <pre>
          <code>       html←DOM2HTML t
       t2←HTML2DOM html
       html≡DOM2HTML t2
1
</code>
        </pre>
        <p>
          Where
          <code>HTML2DOM</code>
          is:
        </p>
        <pre>
          <code>HTML2DOM←{
     ⍝ ⍵ ←→ HTML
     ⍝ ← ←→ DOM
     0=≢⍵:⍬
     {⍵⌷⍨⍳1=⍴⍵}0{
         m←⍵
         0=≢m:⍺
         b←m[;0]=0
         p←⍺{⍺ New 3↑1↓⍵}¨↓b⌿m
         m[;0]-←1
         p⊣p ∇¨1↓¨b⊂[0]m
     }⎕XML ⍵
 }
</code>
        </pre>
        <p>Once you start creating HTML this way, patterns arise and utility
        functions fall out naturally. These utilities return content that
        can be manipulated and injected anywhere.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/on-control-structures">On Control Structures</a>
          </h1>
          <h4>August 1, 2022</h4>
        </header>
        <p>
          The
          <a href="https://www.arraycast.com/episodes/episode32-control-structures">latest
          episode of Array Cast</a>
          is on control structures. As usual, it is an excellent episode,
          covering history and all the options in the various array languages.
          However, the panelists raised a number of interesting questions
          which were not fully examined, let alone answered - understandable,
          given how much material was covered and the time constraints.
          One question was why use control structures at all?
        </p>
        <p>
          One of the main arguments made in favor of using control structures
          was
          <em>expediency</em>
          . While this argument was meant to be proscriptive, it is definitely
          descriptive: it is obvious from inspecting large APL code bases
          that make heavy use of control structures. But expediency is
          just another word for a shortcut. We don't have time to do it
          right, so we take the fast and easy way out. As tempting as this
          always is, it is almost never the right approach.
        </p>
        <p>Expediency piles on the technical debt. When hitting a bug,
        instead of refactoring the code, and perhaps extracting a new function
        or two, we just if-then-else or trap around the problem. Functions
        lose their focus, they get longer and longer, variables proliferate,
        control structures get nested, and nested, and nested again.</p>
        <p>Note that the issue here is not searching for an array-based
        solution, which, as noted in the podcast, may be difficult (or
        even impossible) and may not be worth the time. The issue is general
        refactoring, important in any language or paradigm. When there
        is a function that appears to require lots of control structure
        statements, it is often possible to rearrange things and factor
        out the control structures. A new function or two may need to be
        extracted to cleanly eliminate some control structures. This effort,
        and make no mistake, it is indeed effort, is well worth it.</p>
        <p>By eliminating control structures, one gains a deeper understanding
        of the problem, and the resulting code is shorter, more direct,
        and easier to debug, maintain and enhance. And by extracting more
        and more functions a domain-specfic English vocabulary arises and
        separates itself from the APL primitives. The code can become self-documenting.
        In the end we may still need some control structures, but they
        are separated and are above our APL primitive code. We don't have
        a :If keyword followed by a welter of primitives, a function train,
        and an embedded assignment. Functions are written at the same level
        of abstraction. Functions are mostly written in English, or mostly
        written in APL. As was noted in the podcast, it has been suggested
        that control structures are sort of outside the language of APL.
        If it is a good idea that we code at the same level of abstraction,
        it follows that control structures should not be mixed with the
        heavy use of primitives.</p>
        <p>Most importantly, control structures provide an easy way to
        avoid naming things. Refactoring code to remove control structures
        requires naming new functions. Naming things is important. Naming
        is also hard under the best of circumstances. When looking at a
        large rambling function is can be impossible to find any section
        that is nameable - without rewriting everything. When a program
        is a single large function full of control structures, a fix or
        enhancement can be made with little thought to where it goes, precisely
        because there is no particular place for anything. There is only
        one name, the name of the big function. It's like a large messy
        room with no closet, chest of drawers, or desk. Anything can just
        get thrown in the room with no concern for where it is. This is
        chaos.</p>
        <p>In a program with many small well-named functions, the place
        for a change must be carefully considered. There may be no good
        place for the change, and a new function may be required. Or the
        change may go in a particular function, expanding or changing its
        duties and making its name inappropriate. A change can easily require
        multiple function name changes and the introduction of new functions.
        This takes work. This program is like a large neat room with appropriate
        storage; everything has a place, and everything in its place. The
        dirty shirt has a place in the hamper, the book has a place on
        the desk. If the room acquires a lot of books, and the desk becomes
        unmanageable, a bookshelf is installed. This is order. Bringing
        order out of chaos requires naming. Keeping things in order requires
        renaming.</p>
        <p>In addition to the question of why use control structures at
        all, the panelists pondered if it is possible to write large scale
        applications without them. These two questions are related, and
        if the answer to the first is primarily "expediency", the answer
        to the second is definitely "yes".</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/leetcode-601">LeetCode 601: Human Traffic of
            Stadium</a>
          </h1>
          <h2>July 9, 2022</h2>
        </header>
        <p>
          In this strangely titled
          <a href="https://leetcode.com/problems/human-traffic-of-stadium/">LeetCode
          problem</a>
          , we are given the following table:
        </p>
        <pre>
          <code> t.Display 0
── LeetCode601.Numbers ─────────
 ┌ID──┐  ┌VisitDate─┐  ┌People┐ 
 ↓1   │  ↓2017-01-01│  ↓10    │ 
 │2   │  │2017-01-02│  │109   │ 
 │3   │  │2017-01-03│  │150   │ 
 │4   │  │2017-01-04│  │99    │ 
 │5   │  │2017-01-05│  │145   │ 
 │6   │  │2017-01-06│  │1,455 │ 
 │7   │  │2017-01-07│  │199   │ 
 │8   │  │2017-01-09│  │188   │ 
 └Int8┘  └Date──────┘  └Int16─┘ 
── 8 rows by 3 columns ─────────
</code>
        </pre>
        <p>And informed that:</p>
        <blockquote>
          <p>VisitDate is the primary key for this table. Each row of this
          table contains the visit date and visit id to the stadium with
          the number of people during the visit. No two rows will have
          the same VisitDate, and as the ID increases, the dates increase
          as well.</p>
        </blockquote>
        <p>And then charged with:</p>
        <blockquote>
          <p>Write an SQL query to display the records with three or more
          rows with consecutive id's, and the number of people is greater
          than or equal to 100 for each. Return the result table ordered
          by VisitDate in ascending order.</p>
        </blockquote>
        <p>Let's take a look at how to the solve this in APL, and then
        translate to a FlipDB solution. First some variables:</p>
        <pre>
          <code>      i←1+⍳8
      p←10 109 150 99 145 1455 199 188 
</code>
        </pre>
        <p>Note that the visit date adds nothing of interest to this problem.
        Also note we assume, for now, the IDs are already in ascending
        order. Selecting out IDs where the number of People is greater
        than 100:</p>
        <pre>
          <code>      j←(p&gt;100)/i
      j
2 3 5 6 7 8
</code>
        </pre>
        <p>
          This yields non-consecutive IDs, which is the heart of the problem.
          We now need to identify runs of non-consecutive IDs, which is
          easy using the rank idiom (
          <code>⍋⍋</code>
          ):
        </p>
        <pre>
          <code>      j-⍋⍋j
2 2 3 3 3 3 
</code>
        </pre>
        <p>We might reach for pair-wise reduction here instead, to find
        where the IDs increase by more than one, but that leads to a more
        complicated solution. Now partition or group the IDs by their runs:</p>
        <pre>
          <code>     g←(j-⍋⍋j)⊆j 
     g
┌───┬───────┐
│2 3│5 6 7 8│
└───┴───────┘
</code>
        </pre>
        <p>And finally, get a simple vector of all IDs that exist in groups
        of 3 or more:</p>
        <pre>
          <code>       k←∊(3≤≢¨g)/g
       k
5 6 7 8 
</code>
        </pre>
        <p>A boolean where clause to apply to the original table is then:</p>
        <pre>
          <code>      i∊k
0 0 0 0 1 1 1 1
</code>
        </pre>
        <p>And we are pretty much done. We can write this as a one-liner
        using a couple of dfns if we want an expression that maps to a
        single FlipDB where statement:</p>
        <pre>
          <code>      i∊∊{(2&lt;≢¨⍵)/⍵}{(⍵-⍋⍋⍵)⊆⍵}(p&gt;100)/i
0 0 0 0 1 1 1 1
</code>
        </pre>
        <p>Now we can almost transliterate into FlipDB:</p>
        <pre>
          <code>      ID in {z where 2 &lt; count z} {(z-rankUp z) partition z} ID where People &gt; 100
</code>
        </pre>
        <p>
          Note that the
          <code>where</code>
          appearing twice above is not a where clause, which is the entire
          statement, but the
          <code>where</code>
          function - a FlipDB structural function. Of course in FlipDB
          we might break the problem down a bit, and define some computed
          values first in our query, and we should probably sort the IDs
          to ensure ascending order:
        </p>
        <table>
          <thead>
            <tr>
              <th class="left">Name</th>
              <th class="left">Expression</th>
              <th class="center"></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="left">
                <code>Over100</code>
              </td>
              <td class="left">
                <code>sortUp ID where People &gt; 100</code>
              </td>
              <td class="center"></td>
            </tr>
            <tr>
              <td class="left">
                <code>Groups</code>
              </td>
              <td class="left">
                <code>{(z - rankUp z) partition z} Over100</code>
              </td>
              <td class="center"></td>
            </tr>
            <tr>
              <td class="left">
                <code>Threes</code>
              </td>
              <td class="left">
                <code>Groups where 2 &lt; count Groups</code>
              </td>
              <td class="center"></td>
            </tr>
          </tbody>
        </table>
        <p>and then write a simple where statement:</p>
        <pre>
          <code>      ID in Threes
</code>
        </pre>
        <p>This keeps it clean, simple, and usefully traceable in the FlipDB
        tracer.</p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2022 Paul S. Mansour</p>
    </footer>
  </body>
</html>
