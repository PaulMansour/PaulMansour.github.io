<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <h3>"You don't know how bad your code is until you write about it."</h3>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/a-high-performance-data-grid-in-html">A High
            Performance Data Grid in HTML</a>
          </h1>
          <h2>May 20, 2024</h2>
        </header>
        <p>A first-rate data grid control is essential for many business applications. For decades we have relied on the venerable <code>⎕WC</code> grid, but we need to look at <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/DataGrid">something new</a> for the browser. There are many data grid controls out there: free ones, expensive ones, headless, full-featured, stripped down, open source, closed source, you name it. Most of them are way too complicated, trying to be all things to all people. We have APL, so we don't need a grid that implements calculations and formulas, or sorting, or a bunch of other things we can easily do ourselves. We are specifically <em>not</em> trying to implement a spreadsheet. We also don't need to support different data types in the same column. Nor do we need nested column titles, nor do we need different row heights; we don't need or want the data grid to be a reporting vehicle.  Our data grid will be designed for the efficient display, manipulation, and editing of tables, large and small. We can simplify, simplify, simplify.</p>
        <p>Let's look at what we <em>do</em> need:</p>
        <ol>
          <li>Fast, Excel-like scrolling. There should be no partial cell on the left when we scroll right, and no partial cell on the top when we scroll down.</li>
          <li>Relatively large capacity; millions of rows with hundreds of columns should be no problem. If the table can fit in the workspace, the data grid should be able to handle it. </li>
          <li>Sticky column headers.</li>
          <li>Optional row numbers.</li>
          <li>Optional freeze panes for columns (we don't care about freezing rows).</li>
          <li>Editing</li>
          <li>Selection, cut, copy and paste </li>
        </ol>
        <p>There a many different ways to tackle this problem. Everything from using a <code>&lt;div&gt;</code> for every cell, to drawing cells and borders on <code>&lt;canvas&gt;</code>. One thing you can't do is naively create a <code>&lt;table&gt;</code> with millions of rows, or even 100's of rows, and expect to efficiently render it or scroll around in it. However, the <code>&lt;table&gt;</code> element is, in the end, the right way go. It's for tabular data, and we have tabular data. It does a lot for us. Any other approach is going to require much more work and much more code. And, for what it's worth, which may not be much in an SPA, it is also semantically correct.</p>
        <p>We must also completely take over scrolling from the browser. </p>
        <p>How then do we make it work? Let's assume we have a table that fits comfortably in our APL workspace (our grid should handle both inverted and non-inverted data). At any one time, we are only going to display as much data as fits on the screen or window. Actually, a little more... we want the data to overflow a little bit down and to the right. This is not to make scrolling faster (as we shall see) by pre-drawing some out-of-sight content, but rather for two other reasons. There will almost always be a partial row on the bottom and a partial column on the right, so we certainly need at least one extra row and column. We also want to be able to resize the grid's container exposing more rows and columns, within reasonable limits, without having to resize the <code>&lt;table&gt;</code>, get more data, etc. Resizing a grid always results in more or less rows and columns at the bottom and right, never top and left. So given our screen size, and general limits to the size of the parent container, we can compute these dimensions. We will call this <strong><code>TableOverSize</code></strong>. This is a fairly fudgeable value. There is no precise way to compute it. If we make it too big, performance will suffer, if we make it too small, then the act of resizing will expose empty space, to be filled only when the resize is complete, which looks a little hokey.</p>
        <p>On the APL side, in the APL DOM, we will want to create a <code>&lt;table&gt;</code> element and all of its children elements once and only once. It will be the size specified by <code>TableOverSize</code>. We also need custom code to set the content and generate the innerHTML as this will be done repeatedly as we scroll around the grid. It must be as fast as possible. If a user is holding down a cursor key, scrolling through the grid, on every key press event we will be getting some data from the data source, constructing the innerHTML, and then sending it back to the browser.</p>
        <p>Next, we need to know exactly how many full rows and columns can be displayed at any given moment. This we call this the <strong><code>WindowSize</code></strong>, which is always smaller than <code>TableOverSize</code>.  If we scroll outside the <code>WindowSize</code> in any direction, we reset the <code>innerHTML</code> of the entire <code>&lt;table&gt;</code>, headers and all.  Resetting the headers very time we scroll solves the problem of  sticky headers, which you would think CSS <code>position: sticky;</code> solves, but it does really doesn't.</p>
        <p>Complicating <code>WindowSize</code> are optional row numbers and frozen columns. Let's define the scalar Boolean <strong><code>RowNumbers</code></strong> to be row numbers on or off, and the scalar integer <strong><code>FreezeColumns</code></strong> to be the number of frozen columns. Let's call the sum of these two properties <strong><code>FixedColumns</code></strong>. When computing <code>WindowSize</code>, which is only the scrollable area, we need to leave room for these fixed columns. We define <strong><code>TableSize</code></strong> to be the number of rows and columns we can display  including fixed columns, while <code>WindowSize</code> is the number of rows and columns we can display that will scroll. The relationship between the two is: </p>
        <pre><code>      TableSize ←→ WindowSize+0,FixedColumns
</code></pre>
        <p>If row numbers are off, and there are no frozen columns, then <code>TableSize</code> equals <code>WindowSize</code>.</p>
        <p>How do we compute WindowSize? The number of rows is easy. We know the height of our element, we know the height of our rows, we do the division. This value is fixed as long as there is not a resize event. Columns are another story. Each column can have a different width, so the number of columns we can display varies with the column that is currently displayed on the far left.  Let's first define ar few more names: </p>
        <p> <strong><code>Values</code></strong> is the data, like the <code>⎕WC</code> grid more or less.    <strong><code>DataSize</code></strong> is the shape of <code>Values</code>.</p>
        <p> <strong><code>DataCell</code></strong> is analogous to <code>⎕WC</code>'s <code>CurCell</code> - an index into <code>Values</code>, representing the current cell. </p>
        <p> <strong><code>WindowCell</code></strong> is the index of the current cell in the window.  </p>
        <p> <strong><code>TableCell</code></strong> is the index of the current cell in the table, which is just the window plus the number of fixed columns.</p>
        <p> <strong><code>WindowIndex</code></strong> is the location of upper left corner of the window in <code>Values</code>, similar to <code>⎕WC</code>'s <code>Grid.Index</code>.   </p>
        <p>In our DataGrid, we insist that the current cell is visible. This is unlike Excel or the <code>⎕WC</code> grid.  This means the following relationship holds:</p>
        <pre><code>      DataCell ←→ WindowIndex+WindowCell
</code></pre>
        <p>The number of columns that can be displayed at any given time is a function of the <code>WindowIndex</code>, the width of all the columns, and the available space. For each column, when it is in the left-most position, we need to know how many columns we can display. We call this vector <strong><code>ColumnsPerIndex</code></strong>, and it can be computed with:</p>
        <pre><code>  ComputeColumnsPerIndex←{
     s←+\¨(⍳≢⍵)↓¨⊂⍵
     1+s⍸¨⍺
 }   
</code></pre>
        <p>Where <code>⍵</code> is vector of column widths, and <code>⍺</code> is the available space. This value is useful when scrolling left. We know the column that will be the left-most column, and can then easily pick out the number of columns that can be displayd. By definition, when scrolling left, one new column comes into view on the left. A slightly different problem arises scrolling right. In order to get one new column  to come into view on the right, one or more columns may move off on the left, which in turn may actually bring more than one column in on the right. To make this easy it would be nice to know what column should be the left-most column when a given column is being scrolled into view on the right. We call this the <strong><code>ScrollIntoViewIndex</code></strong> given by:   </p>
        <pre><code>   ComputeScrollIntoViewIndex←{
     n←⍳≢⍵
     (⍵/n)[n⍳⍨∊n+⍳¨⍵]
 }
</code></pre>
        <p>where <code>⍵</code> is the <code>ColumnsPerIndex</code> vector. With these two vectors in hand, we can scroll left and right with ease. </p>
        <p>When are grid is created, or anytime a grid is resized, most of these values must be recomputed. This is done with the <code>Resize</code> function:</p>
        <pre><code> Resize←{
     t←⍺
     p←t.Parent
     t.AvailableWidth←p.Width-+/t.FixedColumns↑t.FullWidths
     t.ColumnsPerIndex←t.AvailableWidth ComputeColumnsPerIndex t.RowNumbers↓t.FullWidths
     0∊t.ColumnsPerIndex:0
     t.ScrollIntoViewIndex←ComputeScrollIntoViewIndex t.ColumnsPerIndex
     t.RowsToDisplay←p.Height ComputeRowsToDisplay 0
     t.WindowSize←t.RowsToDisplay,(1⊃t.WindowIndex)⊃t.ColumnsPerIndex
     ∨/t.WindowSize&lt;1:0
     t.WindowCell←t.WindowCell⌊t.WindowSize-1
     t.DataCell←t.WindowIndex+t.WindowCell
     t.TableCell←t.WindowCell+0,t.FixedColumns
     Refresh t
 } 
</code></pre>
        <p>With these values in hand, scrolling around is straight forward. For example, scrolling to the right is done as follows:</p>
        <pre><code>MoveWindowRight←{
     t←⍵
     c←1⊃t.DataCell
     i←c⊃t.ScrollIntoViewIndex
     t.WindowIndex[1]←i
     t.WindowSize[1]←i⊃t.ColumnsPerIndex
     t.WindowCell[1]←c-i    
     t.TableCell←t.WindowCell+0,t.FixedColumns
     _←Refresh t
     0
 }
</code></pre>
        <p>Once we have mastered scrolling one row or column at a time, up or down, left or right, then Page Up, Page Down, Home, End, etc., are all easy. </p>
        <p>In a future post we will look at editing, and various edit modes that mimic Excel behavior. We are also going to have to figure out how to put scroll bars on this thing.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/modal-dialog-boxes-progressbar-more">Modal
            Dialog Boxes 5: More on ProgressBar</a>
          </h1>
          <h2>May 18, 2024</h2>
        </header>
        <p>The <code>ProgressBar.Run</code> operator, so far, handles iterative processes; we effectively have a loop, whether implemented using the each operator or recursion. This gives us the opportunitiy to check for a <em>Pause</em> click on each iteration, to cleanly pause the process, and clean up if the operation is canceled.</p>
        <p>Sometimes we have a potentially long running process that is not itererative, or it is iterative but we don't want to bother with refactoring it to fit the needs of the <code>Progress.Run</code> operator. We want to put up a spinner or <a href="https://www.w3schools.com/howto/howto_css_loader.asp">loader</a> - and provide a cancel button to kill the process.</p>
        <p>The HTML <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/progress">progress element</a> provides an oscillating bar when no <code>max</code> attribute is set, giving us a JavaScript-free and CSS-free spinner.</p>
        <p>For this case we can wrap our long running code with the <code>Start</code> and <code>Stop</code> functions: </p>
        <pre><code>_←d Progress.Start ''
...
... your code here
...
_←d Progress.Stop ''
</code></pre>
        <p>The <code>Start</code> function puts up a modal dialog, but does not wait:    </p>
        <pre><code>Start←{
     c←⍵,(0=≢⍵)/'Working...'
     e←A.New'dialog'
     e.class←'progress-bar'
     e.id←'progress-bar'
     e.TID←⎕TID
     h1←e A.New'h1'c
     p←e A.New'progress'
     p.id←'progress'
     b←e A.New'button' 'Cancel'
     b.id←'Cancel'
     b.Unqueued←1
     b.Onclick←A.FQP'OnCancel'
     _←⍺ A.ShowModal e
     0
 }
</code></pre>
        <p>And <code>Stop</code> just closes the dialog:</p>
        <pre><code>Stop←{
     d←⍺ A.GetElementById'progress-bar'
     ⍺ A.DeleteElement d
 }
</code></pre>
        <p>In the <code>Start</code> function the thread id of the current process is noted in the component, so when <em>Cancel</em> is pressed, we can kill it:</p>
        <pre><code>OnCancel←{
     d←⍵.CurrentTarget A.GetNearest'dialog'
     _←⎕TKILL d.TID
     ⍵.Document A.DeleteElement d
 }
</code></pre>
        <p>This is a fairly crude technique, but useful in some circumstances.</p>
        <p>There is another progress bar case that we have not handled. Consider a process of N discrete but non-iterative steps. As the code is running through these N steps, we want to provide feedback to the user about where we are in the process, and allow the process to be cancelled. For this we will need something like <code>Begin</code>, <code>Update</code> and <code>End</code> functions to sprinkle throughout our code.  </p>
        <p>In addition we may want to consider what happens if and when these various processes are scripted and have no user interaction. </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/modal-dialog-boxes-progressbar">Modal Dialog
            Boxes 4: ProgressBar</a>
          </h1>
          <h2>May 14, 2024</h2>
        </header>
        <p>Implementing a general purpose, easy-to-use progress bar presents some challenges. Let's look at an attempt. The Abacus <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/ProgressBar">ProgressBar</a> is designed to handle  iterative processes where the number of iterations may or may not be known ahead of time. In either case, we want to provide some feedback on each iteration as well as the ability to cancel the process.</p>
        <p>Rather than providing a <em>Cancel</em> button on the progess bar element, which would arguably require an "are-you-sure" confirmation, we provide a <em>Pause</em> button, which  pauses the operation between two iterations. This gives us the opportunity to add a bit more functionality, without additional complexity in the UI.  When <em>Pause</em> is clicked, the user is then offered two choices, <em>Cancel</em> and <em>Resume</em>, and optionally a 3rd choice: <em>Truncate</em>.  The <em>Cancel</em> option cancels the entire operation without further ado. The <em>Resume</em> option restarts the process at the next iteration. The <em>Truncate</em> option treats the last completed iteration as the final iteration and continues the operation. It simply ignores and does not process the remaining iterations. This option is only relevant for certain types of operations. For example, when importing a CSV file, the user may decide that reading a few million rows from a large file is sufficient for his purposes.</p>
        <p>The progress bar is implemented with a monadic operator, <code>Run</code>. This operator  puts up a progress element with a <em>Pause</em> button, runs the iterations, allows the user to cancel the operation, and provides a useful result when control returns to the calling function. Here is the syntax:  </p>
        <pre><code>      R←Y F ProgressBar.Run X
</code></pre>
        <p>The left argument <code>Y</code> is the document object. The left operand <code>F</code> is a function that implements the looping task at hand. <code>X</code> is a namespace provided as a right argument to <code>F</code>. </p>
        <p>The namespace <code>X</code> must contain 3 properties: <code>Caption</code>, <code>Iterator</code> and <code>Status</code>. The <code>Caption</code> is a string specifying the title of the progress bar dialog box. The <code>Iterator</code> property is a vector. If the iteration vector is empty, the process is deemed <em>indeterminate</em>. We don't know how many iterations there may be. Otherwise the length of <code>Iterator</code> is the number of iterations, known ahead of time, and the process is deemed <em>determinate</em>. In the determinate case, the <code>Status</code> property is a vector of char vectors the same length as <code>Iterator</code>. In the indeterminate case, <code>Status</code> is a simple vector that should be reset inside <code>F</code> on every iteration.   </p>
        <p>The namespace <code>X</code> may, and often will, contain all sorts of other variables and references that are needed to support the execution of <code>F</code>. </p>
        <p>The iteration vector may be an array of any type of values. Associated with the iteration values are iterations numbers, given by <code>⍳≢X.Iterator</code>. For the determinate case, the iteration <em>number</em> (not the value) is provided as the left argument to <code>F</code>. </p>
        <p>In the indeterminate case the result of <code>F</code> is a return code of <code>0</code> if another iteration is required, or <code>1</code> if it is not. There is no other return value. Data accumulation is accomplished by either writing to file or by accumulating an array inside <code>X</code>. In the determinate case, the result of <code>F</code> may be any useful value. </p>
        <p>The result <code>R</code> (of <code>ProgressBar.Run</code>) is a scaler for the indeterminate case, and a two item vector for the determinate case. In both cases the first element of <code>R</code> is <code>0</code> if all itererations are executed, <code>1</code> if cancelled, and <code>2</code> if truncated. For determinate processes, the second element is an array of the result of each call to <code>F</code>.</p>
        <p>Let's go to the code:</p>
        <pre><code>Run←{
     p←New ⍵.Caption ⍵.Iterator
     _←⍺ A.ShowModal p
     op←⍎(0=≢⍵.Iterator)⊃'Determinate' 'Indeterminate'
     r←p ⍺⍺ op ⍵
     r⊣A.DeleteElement p
 }
</code></pre>
        <p>In the <code>Run</code> operator, the first thing we do is create the dialog element (<code>New</code>) and display it (<code>ShowModal</code>). Next we have to pick the appropriate sub-operator. The techniques are different for the two cases. For the determinate case, we use the <code>each</code> operator (<code>¨</code>) to execute iteration:</p>
        <pre><code>Determinate←{
     b r←↓⍉↑(⊂⍺ ⍵)⍺⍺{
         p w←⍺
         p.Cancel:1 0
         c←p Pause 0
         c≡'Cancel':1 0⊣p.Cancel←1
         c≡'Truncate':2 0⊣p.Cancel←1
         _←p Update ⍵⊃w.Status
         r←⍵ ⍺⍺ w
         0 r
     }¨⍳≢⍺.Iterator
     (⌈/b)(r/⍨b=0)
 }
</code></pre>
        <p>First we check if <em>Cancel</em> has been previously pressed. If so, there is nothing to do, and we get out. (Note that we always run the inner function N times if there are N iterations, even if the user has canceled). Next we run the <code>Pause</code> function to see if the user has pressed <em>Pause</em>:</p>
        <pre><code>Pause←{
     ~⍺.Pause:'Resume'
     ⍺.Pause←0
     t←'Process paused'
     c←''
     b←'Cancel' 'Resume' 'Truncate'
     ⍺.Document A.ConfirmBox.Show t c b
 }
</code></pre>
        <p>If the user has not clicked <em>Pause</em>, we exit, resuming the iterations. If the user has pressed Pause, we put a confirmation box and wait. Back in the <code>Determinate</code> operator we inspect what the user has selected in the confirmation box, exiting if <em>Cancel</em> or <em>Truncate</em>. Otherwise we update the status and execute the iteration function, the left operand of <code>Run</code>.</p>
        <p>The indeterminate operator is a bit simpler (hmm, why is that?):</p>
        <pre><code>Indeterminate←{
     _←⍺ Update ⍵.Status
     c←⍺ Pause ⍵
     c≡'Cancel':1
     c≡'Truncate':2
     ⍺⍺ ⍵:0
     ⍺ ∇ ⍵
 }
</code></pre>
        <p>Here we update the status before checking if the user clicked <em>Pause</em>. This is because in the indeterminate case, the status of an iteration is known after the iteration completes, while in the determinate case the status is known before the iteration is executed - usually. We check for `<em>Pause</em> etc., just as in the determinate case. We then run the iteration function, exiting if it returns a <code>1</code>, and continuing on to the next iteration via recursion otherwise.</p>
        <p>Regardless of the iteration technique, be it looping, recursion, or the each operator, the fact that the argument to <code>F</code> is a namespace allows us to easily maintain and update state, and accumulate results, between iterations.</p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2024 Paul S. Mansour</p>
    </footer>
  </body>
</html>
