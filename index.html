<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><link href="/ThorntonMelon.css" rel="stylesheet"></link></head><body><header><h1>Tool of Thought</h1><h2>APL for the Practical Man</h2><h3>"Vibe coding since 1987"</h3><nav><a href="/">Home</a><a href="/posts">Posts</a><a href="/projects">Projects</a><a href="/donts">Don'ts</a><a href="/links">Links</a><a href="/about">About</a></nav></header><main><article><header><h1><a href="/posts/input-components">Input Components</a></h1><h2>August 6, 2025</h2></header><p>(Or, How Did We Live Before <code>⎕VSET</code> and <code>⎕VGET</code>?)</p><p>We need some functions to wrap the HTML <code>&lt;input&gt;</code> element. We need inputs for text, numbers, dates check boxes, and pick lists, and thus define the following components:</p><ul><li><code>TextInput</code></li><li><code>NumberInput</code></li><li><code>DateInput</code></li><li><code>CheckBox</code></li><li><code>DropList</code></li></ul><p>Let's look at <code>TextInput.New</code>, as a representative pattern: </p><pre><code>New←{
     d←(⍺ A.New'div')⎕NS(
         'Name' ''
         'Label' ''
         'Value' ''
         'AutocompleteItems' ''
         'OnChange' ''
     )A.InitProps ⍵
     d.class←'TextInput'
     l←d A.New'label'd.Label
     l.for←d.Name
     i←d A.New'input'
     i.value←d.Value
     i.id←d.Name
     d.Onchange←A.FQP'OnChange'
     d
 }
</code></pre><p>Here we have taken advantage of V20's new array notation. This allows us to easily see and modify the supported properties and their default values, across multiple lines, without repeated catenation, enclosing, etc. The argument to <code>New</code> may be a namespace, or an array where each  item is either a name/value pair, or just a value. If only a value is provided, then its property name is inferred from its position (like <code>⎕WC</code>). For example, the following two expressions are equivalent:</p><pre><code>      TextEdit.New (Label:'First name:' ⋄ Name:'FirstName' ⋄ Value:'Paul')
      TextEdit.New 'FirstName' ('Value' 'Paul') ('Label' 'FirstName)
</code></pre><p>The <code>InitProps</code> function processes the argument:</p><pre><code>InitProps←{
     ⍝ ⍺ ←→ Default name/value pairs
     ⍝ ⍵ ←→ Given argument
     ⍝ ← ←→ A new space with ⍺ overiddden by ⍵
     d←()⎕VSET ⍺
     9=⎕NC'⍵':d ⎕NS ⍵
     n←⊃¨⍺
     m←n↑⍨≢⍵
     p←m{2∧.=(≢⍵),|≡⍵:⍵ ⋄ ⍺ ⍵}¨⍵
     +d ⎕NS()⎕VSET p/⍨n∊⍨⊃¨p
 }
</code></pre><p>Once we have a namespace with all the user set properties and default properties, all of the property names and values are injected into the root  element of the component. This means that property names must begin with an uppercase letter, to avoid conflict with element attributes like <code>class</code> or <code>onclick</code>, and that the names <code>Tag</code>, <code>Content</code>, and <code>Parent</code> are reserved.  </p><p>If a property is not referenced in the <code>New</code> function, like <code>OnChange</code>, it may also be specified by assignment after the component is created. Setting other properties after the component has been created will generally  require a setter function. For example, to set the <code>Value</code> property requires a call to <code>TextInput.SetValue</code>.</p><p>The component <code>&lt;div&gt;</code> contains a <code>&lt;label&gt;</code> element and an <code>&lt;input&gt;</code> element. They are tied together explicitly with the <code>for</code> attribute, rather than nesting, in order to provide more options for display purposes, specifically grid and flexbox.    </p><h2>Events</h2><p>For now, each component accepts an <code>OnChange</code> callback function, to allow further action to be taken after Abacus handles the change. In the case of <code>TextInput</code>, Abacus simply updates the APL DOM to reflect the change in the browser, and then calls the <code>OnChange</code> callback, if specfied by the user:</p><pre><code>OnChange←{
     c←⍵.CurrentTarget
     c.Value←⍵.Value
     ⍵ A.Execute'OnChange'
 }
</code></pre><h2>The GetValues and SetValues functions</h2><p>The main Abacus namespace contains the functions <code>GetValues</code> and <code>SetValues</code> for getting and setting multiple values, a typical task given a dialog box with a bunch of inputs. The <code>GetValues</code> function:</p><pre><code> GetValues←{
     ⍝ ⍵ ←→ DOM node
     ⍝ ← ←→ Namespace of Values from ⍵
     e←⍵ GetElementsWith'Name'
     0=≢e:()
     +()⎕VSET(↑e.Name)e.Value
 }
</code></pre><p>...takes an APL DOM node as its argument and returns a namespace containing the values for each input component found within.  The DOM node is searched for elements that have a <code>Name</code> property, and we assume a corresponding <code>Value</code> property. This search technique could be tightened up if necessary, but for now it's adequate.  </p><p>The <code>SetValues</code> function:</p><pre><code> SetValues←{
     ⍝ ⍺ ←→ Namespace of values
     ⍝ ⍵ ←→ DOM node
     e←⍵ GetElementsWith'Name'
     0=≢e:0
     m←e.Name
     n v←↓⍉↑⍵ ⎕VGET ¯2
     i j←m n⍳¨⊂m∩n
     0=≢i:0
     c←⎕VGET e[i].class
     0⊣e[i]c.SetValue v[j]
 }
</code></pre><p>...similarly takes a DOM node as its right argument, but also a namespace of values as its left argment, and populates the inputs in the DOM with the values. <code>SetValues</code> is happy to accept more or fewer values than would be indicated by the DOM, and only set values that have correpsonding inputs. We must use the  individual <code>SetValue</code> function in each component to set the values.</p></article><article><header><h1><a href="/posts/whats-on-the-menu">What's on the Menu?</a></h1><h2>June 21, 2025</h2></header><p>We find ourselves in need of a menu. Let's noodle around with a design.</p><p>With <code>⎕WC</code>, we had a full-blown object model, and thus <code>MenuBar</code>, <code>Menu</code>, <code>MenuItem</code> and <code>Separator</code> objects with all of their attendant properties and methods. With Abacus components, we are working at a higher level than <code>⎕WC</code>, trying to make things simple and easy for our purposes. We used to write cover functions over <code>⎕WC</code> to help construct menus, here we are writing cover functions over HTML. Of course we have to accept the constraints and lack of generality these cover functions impose. We are also trying to get by on the cheap, and not implement a massive dynamic object model, with getters and setters and all that entails. </p><p>Our requirements include a classic menu bar, a hamburger menu, and a popup or context-sensitive menu. And sub-menus, checked menu items, and inactive menu items. Separators too.     Can we get by with just a <code>Menu</code> component and few functions? Maybe. Let's have a function that builds a menu component that we may then use in different circumstances:</p><pre><code>BuildMenu←{
     New←A.Menu.New
     Add←A.Menu.Add
     m←New''
     s←m Add New'File'
     i←s Add'Open' 'Ctrl+O' 'OnFileOpen'
     i←s Add'Save' 'Ctrl+S' 'OnFileSave'
     i←s Add'Save As...' 'Ctrl+A' 'OnFileSaveAs'
     s←m Add New'Edit'
     i←s Add'Cut' 'Ctrl+X' 'OnCut'
     i←s Add'Copy' 'Ctrl+C' 'OnCopy'
     i←s Add'Paste' 'Ctrl+V' 'OnPaste'
     s←m Add New'View'
     i←s Add'List' 'Ctrl+Q' 'OnViewList'
     s2←s Add New'Icons'
     i←s2 Add'Small' 'Ctrl+L' 'OnViewLarge'
     i←s2 Add'Medium' 'Ctrl+M' 'OnViewMedium' 0 0 1
     i←s2 Add'Large' 'Ctrl+S' 'OnViewSmall' 0 0   
     m
 }
</code></pre><p>The <code>New</code> function of the Menu component creates and returns a new <code>&lt;menu&gt;</code> element. It takes a simple string, the name or label, as its argument.</p><p>The <code>Add</code> function adds a menu item or a sub-menu. A menu item is defined by up to 6 items in the argument to <code>Add</code>:</p><table><thead><tr><th class="left">Item</th><th class="left">Name</th><th class="left">Description</th></tr></thead><tbody><tr><td class="left">0</td><td class="left">Label</td><td class="left">The name or label of the menu item</td></tr><tr><td class="left">1</td><td class="left">Shortcut</td><td class="left">Purely decorative, must be implemented separately</td></tr><tr><td class="left">2</td><td class="left">CallBack</td><td class="left">The event handler function (a string)</td></tr><tr><td class="left">3</td><td class="left">Separator</td><td class="left">Boolean; should a divider precede this menu item, default is 0</td></tr><tr><td class="left">4</td><td class="left">Active</td><td class="left">Boolean; active/inactive flag, default is 1</td></tr><tr><td class="left">5</td><td class="left">Marker</td><td class="left">Int; 0 for no marker (default), 1 for check, 2 for radio</td></tr></tbody></table><p>Usually we eschew long lists of ordered parameters as arguments, but  we really want to keep the definition of a menu item on a single line. We can provide a namespace as well, but it will tend to add more clutter:</p><pre><code>      m Menu.Add {⍵.Label←'Save as...' ⋄ Callback←'OnSaveAs' ⋄ Active:0 ⋄ ⍵}⎕NS '' 
</code></pre><p>even in v20 when we can do:</p><pre><code>      m Menu.Add (Label:'Save as...' ⋄ Callback:'OnSaveAs' ⋄ Active:0)
</code></pre><p>When adding a menu item, the result is an <code>&lt;li&gt;</code> element, probably not needed most of the time. When adding a sub menu, the result is a <code>&lt;menu&gt;</code> element.  </p><p>With these two functions, <code>New</code> and <code>Add</code>, we can construct an entire menu hierarchy.  </p><p>Neither the <code>New</code> function, nor the user defined <code>Build</code> function adds the menu element and  its children to the DOM. This is handled later, on demand, by various functions in the <code>Menu</code> component.</p><p>Now that we have a function that builds a menu, we can display it as a popup by attaching a handler to the Javascript <code>contextMenu</code> event. We simply build the menu on demand, and use the <code>Show</code> method to add it to the DOM and display it: </p><pre><code>OnContextMenu←{
    m←BuildMenu ⍵
    A.Show m
}
</code></pre><p>A popup has no permanent visual presence, so this event handler is all we need. The entire menu hierarchy is constructed every time the context menu is called for, and then deleted when the menu is dismissed.</p><p>We can take the exact same <code>Build</code> function and use it to implement a menu bar. Unlike a popup menu, a menu bar is permanently visible. We can use the <code>NewMenuBar</code> function to create the menu bar, adding to the DOM, and setting up its behavior, callbacks, etc:</p><pre><code>      mb←Parent Menu.NewMenuBar 'Build'
</code></pre><p>The argument is the name (not the result) of the build function. <code>NewMenuBar</code> will execute this function once to extract the labels from the top level menus, and then will execute the function every time a top level menu item is clicked.</p><p>In a similar we we can create a hamburger menu, again from the same source:</p><pre><code>      hm←Parent Menu.NewHamburgerMenu 'Build'
</code></pre><p>If the menu stucture is limited to 2 levels, we can also display it as a sort of ribbon:</p><pre><code>      r←Parent Menu.NewRibbon 'Build'
</code></pre><p>We could add new display types if they arise.</p><p>Thus the <code>Menu</code> component provides us with a few functions to construct menus, and then display them in different ways.</p><p>A menu only exists in the DOM if the top level is visible; menus are create and deleted on demand.</p></article><article><header><h1><a href="/posts/grok-as-apl-interpreter">Grok as APL Interpreter</a></h1><h2>June 4, 2025</h2></header><p>So far, AI has not been great at writing APL code. But Grok appears pretty good at reading and evaluating APL code. We asked Grok to evaluate this:</p><pre><code>40 f 'Once upon a time in the west.'
</code></pre><p>given:</p><pre><code>f←{ 
     ⎕IO ⎕ML←0 1
     segs←{¯1+⍵{(⍵,⍴⍺)-¯1,⍵}⍸⍵}
     split←{((⍵|⍺)&gt;⍳⍵)+⌊⍺÷1⌈⍵}
     lf sp←(⎕UCS 13 32)=⊂⍵
     sizes←segs lf
     ⍺←⌈/sizes
     blanks←segs~(lf∨sp)/sp
     required←blanks+⍺-sizes
     breps←required split¨blanks
     last←1⌈¯1+⍴sizes
     brep←∊(last↑breps),×last↓breps
     ((~sp)+sp\∊brep)\⍵
 }
</code></pre><p>Grok proceeded to analyze and simulate execution of the function line by line, in gory  detail and with voluminous output, explaining every step, all of which appeared to be correct. It got the right answer, and it knew and reported on the value of every variable along the way. It recognized the purpose of the function.</p><p>Here is a very small extract of Grok's output:</p><pre><code>apl
sizes ← segs lf
lf is all zeros (no line feeds).
segs computes segment lengths:
⍸lf is empty (no 1s).
⍴⍺ = 29 (length of ⍵).
(⍵,⍴⍺)-¯1,⍵ = (empty,29)-¯1,empty = 29-¯1 = 30.
¯1+30 = 29.
So, sizes = 29 (one segment of length 29).
</code></pre><p>Grok claims it only used its knowledge of APL primitives and syntax to evaluate the function, and that it did not look on the internet to find if this function existed somewhere and get information about it. I think I believe it.</p><p>So then we asked Grok to evaluate the expression: </p><pre><code>      'MM-DD-YYYY' Text2Date '12-31-1999'  '02-29-2001' '01-01-2000'
</code></pre><p>given this <a href="https://github.com/the-carlisle-group/Text2Date">code base</a>. It got almost the right answer, getting hung up in the <a href="https://github.com/the-carlisle-group/Text2Date/blob/master/APLSource/Main/Scale.aplf">Scale</a> function thinking  <code>⍺-6-⍺</code> was <code>(⍺-6)-⍺</code> rather than <code>⍺-(6-⍺)</code>, which is a rather odd error given everything else it got right. But that was its only error. Other than that one glitch, it worked though numerous functions and explicated everything in profuse detail.</p></article><h2><a href="/posts">More posts...</a></h2></main><footer><p>Copyright 2021-2025 Paul S. Mansour</p></footer></body></html>
