<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/operators-in-a-dsl">Operators in a DSL</a>
          </h1>
          <h2>May 28, 2022</h2>
        </header>
        <p>When designing a number-crunching domain specific language (DSL)
        in Dyalog APL we have the luxury of using operators. This immediately
        presents many design issues. Operators decrease the number of functions
        in the DSL, reducing overall size and complexity. At the same time,
        operators increase the complexity of composing an individual expression
        by introducing move moving parts.</p>
        <blockquote>
          <p>
            Note
            <code>⎕IO←0</code>
            and
            <code>⎕ML←1</code>
            throughout. In addition, all functions and operators defined
            below are simplified and unoptimized versions of production
            code.
          </p>
        </blockquote>
        <p>
          Consider providing a
          <code>maximum</code>
          function and a
          <code>reduce</code>
          operator in the DSL as direct covers of their APL counterparts:
        </p>
        <pre>
          <code>      maximum←{⍺⌈⍵}
      reduce←{⍺⍺/⍵}
</code>
        </pre>
        <p>No end-user wants to think or type:</p>
        <pre>
          <code>      maximum reduce StockPrice
</code>
        </pre>
        <p>when he could type:</p>
        <pre>
          <code>      max StockPrice
</code>
        </pre>
        <p>
          which one can do in say, SQL. So instead we provide the aggregate
          functions like
          <code>sum</code>
          and
          <code>max</code>
          in addition to their scalar counterparts:
        </p>
        <pre>
          <code>      sum←{+/⍵}
      max←{⌈/⍵}
</code>
        </pre>
        <p>As noted, fewer operators make more functions. However, many
        if not most of the primitive arithmetic and boolean reductions
        are so commonly used that they have useful and well-known names
        like sum, min, max, any, all, etc. In addition, there are many
        more common aggregate functions like average and variance that
        are not primitive scalar reductions and these would need to be
        provided directly as functions anyway. So this is an easy decision;
        the trade-off of more functions and fewer operators in this case
        is well worth it.</p>
        <p>
          Now let's take the next step: running aggregates. Again, we have
          the option of providing a single operator or an additional set
          of functions. In APL we use the scan operator with a scalar function
          for this. However, in our DSL, once we have named aggregate functions
          like
          <code>sum</code>
          and
          <code>max</code>
          , it makes sense to use the aggregate function as the operand
          rather than the scalar function on which the aggregate is based,
          so we might define a
          <code>running</code>
          operator as:
        </p>
        <pre>
          <code>      running←{
          h←⊃61 ⎕ATX'⍺⍺'
          f←{⍵↑⍨⍵⍳'←'}1↓h
          f≡'sum':+\⍵
          f≡'max':⌈\⍵
          ⍺⍺¨,\⍵
      }
</code>
        </pre>
        <p>
          Here the choice is more open for debate, but I think it is still
          clearly in favor of the operator, especially considering that
          moving statistics could be handled by just giving a left argument
          to the running operator. Now a single operator is reducing the
          need for a lot of functions that will have awkward names and
          that will not get called very often. Kx Systems took the opposite
          approach with q, but I can only imagine there was no choice,
          as k does not support user-defined operators. The proliferation
          of functions and the difficulty naming them
          <a href="https://code.kx.com/q/ref/sum/">is immediately apparent.</a>
        </p>
        <p>
          The derived function
          <code>sum running</code>
          is an example of a
          <strong>uniform</strong>
          function - a function that returns a result that is the same
          shape as its argument. The result of a uniform function generally
          depends on the totality of the items in the array - both the
          existence and the ordering of the items. This feature distinguishes
          them from scalar functions. There are many uniform functions
          that are not derived functions. Prime examples in APL are grade
          up (
          <code>⍋</code>
          ) and grade down
          <code>(⍒)</code>
          , rotate
          <code>(⌽)</code>
          and first occurrence (monadic
          <code>≠</code>
          ). A DSL may have many more like
          <code>lag</code>
          and
          <code>lead</code>
          :
        </p>
        <pre>
          <code>      lag←{
           ¯1↓0,⍵
       }
      lead←{
          1↓⍵,0
       } 
</code>
        </pre>
        <p>
          Uniform functions lend themselves to being applied to an argument
          that is conceptually grouped and or ordered. Yet again we are
          faced with the choice of an operator or a plethora of additional
          functions- functions that are even more awkward to name, and
          that require a lot of arguments. In this case there is simply
          no contest. Going the route of additional functions is
          <a href="https://docs.1010data.com/1010dataReferenceManual/Functions/GroupFunctions/Group.html">not
          pretty.</a>
          Let's define an operator
          <code>by</code>
          with the following syntax:
        </p>
        <pre>
          <code>      R←[X] F by Y I [B]     
</code>
        </pre>
        <p>Here F is any uniform (or aggregate - more on this later) function.
        Y is a suitable right argument for F, and X is an optional left
        argument for F. I is a grade vector that orders Y, or a set of
        grade vectors that groups and optionally orders Y. B is an optional
        boolean selection vector that flags items to include and exclude
        in the computation.</p>
        <p>
          The by operator sorts and groups Y according to I, (optionally
          selecting by B), applies F to each group, and then ungroups and
          reorders the results to correspond to the original argument Y.
          This is similar to the under
          <a href="https://aplwiki.com/wiki/Under">operator</a>
          , but I don't think it can handle this particular case.
        </p>
        <p>Sorting and grouping is provided by grade vectors rather than
        providing corresponding values on which to sort and group for the
        same reason sorting in APL is a two-step process with grade up
        and grade down. In addition we extract some complexity from the
        by operator by computing I beforehand using grouping and sorting
        functions.</p>
        <p>
          Let's define
          <code>by</code>
          as follows:
        </p>
        <pre>
          <code>by←{
     ⍺←⊣
     a i b←3↑⍵,⊂1⍴⍨≢⊃⍵
     g←{⍺{⍵⌷⍨⊂⍺}¨⊂⍵}
     (pa pb)←(⊆i)∘g¨a b
     sa←pb/¨pa
     r←⍺ ⍺⍺¨sa
     af←1=≡r
     ua←2=≢61 ⎕ATX'⍺⍺'
     ff←af∨ua
     z←(~⊃¨pb)∧~af
     (⊃¨pb)←1
     e←({|2-/⍸⍵,1}¨⍣ff)pb
     v←∊e\¨r,¨⍨z/¨0
     v[⍋∊i]
 }
</code>
        </pre>
        <p>Now we can do a running sum from lowest to highest:</p>
        <pre>
          <code>      A←100 2 1 8 12
      sum running by A (⍋A)
123 3 1 11 23
</code>
        </pre>
        <p>In other words, for each item, find the sum of it and all items
        less than it. Let's also define a grouping function that can optionally
        take a grade vector as its left argument:</p>
        <pre>
          <code>group←{
     ⍺←⍳≢⍵
     i←{↓⍵}⌸⍵[⍺]
     ⍺∘{⍺[⍵]}¨i
 }
</code>
        </pre>
        <p>And some more data to play around with:</p>
        <pre>
          <code>      RowId←1+⍳10
      Account←1 2 3 3 1 2 1 1 1 2
      Payment←8 3 5 4 2 7 1 9 6 10
      Day←31 1 9 5 14 27 22 17 3 11
      M←⍉↑RowId Account Payment Day
      M
 1 1  8 31
 2 2  3  1
 3 3  5  9
 4 3  4  5
 5 1  2 14
 6 2  7 27
 7 1  1 22
 8 1  9 17
 9 1  6  3
10 2 10 11
</code>
        </pre>
        <p>To round out our little DSL, let's also cover grade up:</p>
        <pre>
          <code>orderUp←{
     ⍋⍵
 }
</code>
        </pre>
        <p>Now we can compute a running sum of payments by account:</p>
        <pre>
          <code>      M,sum running by Payment (group Account)
 1 1  8 31  8
 2 2  3  1  3
 3 3  5  9  5
 4 3  4  5  9
 5 1  2 14 10
 6 2  7 27 10
 7 1  1 22 11
 8 1  9 17 20
 9 1  6  3 26
10 2 10 11 20
</code>
        </pre>
        <p>It is often useful to compute and save the ordering and grouping.
        So to find the ordered running sum of payments by account:</p>
        <pre>
          <code>      G←(orderUp Day) group Account
      M,sum running by Payment G
 1 1  8 31 26
 2 2  3  1  3
 3 3  5  9  9
 4 3  4  5  4
 5 1  2 14  8
 6 2  7 27 20
 7 1  1 22 18
 8 1  9 17 17
 9 1  6  3  6
10 2 10 11 13
</code>
        </pre>
        <p>And to find the previous payment for each day by account:</p>
        <pre>
          <code>      M,lag by Payment G
 1 1  8 31  1
 2 2  3  1  0
 3 3  5  9  4
 4 3  4  5  0
 5 1  2 14  6
 6 2  7 27 10
 7 1  1 22  9
 8 1  9 17  2
 9 1  6  3  0
10 2 10 11  3
</code>
        </pre>
        <p>
          The
          <code>by</code>
          operator is useful not only with uniform functions, but with
          aggregate functions as well. The result of the aggregate function
          on each group is replicated to line up with the original argument:
        </p>
        <pre>
          <code>      M,sum by Payment (group Account)
 1 1  8 31 26
 2 2  3  1 20
 3 3  5  9  9
 4 3  4  5  9
 5 1  2 14 26
 6 2  7 27 20
 7 1  1 22 26
 8 1  9 17 26
 9 1  6  3 26
10 2 10 11 20
</code>
        </pre>
        <p>And we can apply a boolean selection as well:</p>
        <pre>
          <code>      M,sum by Payment (group Account) (Day&lt;15)
 1 1  8 31  8
 2 2  3  1 13
 3 3  5  9  9
 4 3  4  5  9
 5 1  2 14  8
 6 2  7 27 13
 7 1  1 22  8
 8 1  9 17  8
 9 1  6  3  8
10 2 10 11 13
</code>
        </pre>
        <p>There is a balancing act with respect to operators and functions.
        This is similar to the balancing act of fewer functions with more
        arguments, versus more functions and fewer arguments. Overuse of
        operators can make individual expressions and discovery difficult.
        Underuse can lead to a proliferation of badly named and rarely
        used functions that have too many arguments.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/session-configuration">Session Configuration</a>
          </h1>
          <h2>March 6, 2022</h2>
        </header>
        <p>When I get a new version of Dyalog (Windows), I go to the configuration
        dialog box and manually set some options. This is painful, error
        prone and a general waste of time. In addition, I increase the
        session font size, and save the session file. This is even worse,
        as saving the session file can have other deleterious effects.
        It has never been clear to me why it is necessary to save the session
        file simply to remember session font size. Anyway, it is way past
        time to change this entire routine.</p>
        <p>Dyalog 18.0 introduced some new features, techniques, and options
        for session configuration. The most important is the introduction
        of configuration files. Dyalog 18.2 brings some enhancments to
        these features. There is now a plethora of ways to intialize settings,
        configure things, and run code on starting the interpreter.</p>
        <p>
          When a new version of Dyalog is installed, I want to specify
          at most one thing: The UserConfigFile parameter. This parameter
          will point to my confuration file and, indirectly, its parent
          folder. This parent folder is my
          <strong>user configuration folder</strong>
          ; it contains the configuration file itself, as well as any other
          assets for configuring the sesssion like custom user commands
          and code that execute on startup.
        </p>
        <p>The user config file, and its encompassing user config folder,
        should be completely portable, which means that any file or path
        specified inside the config file should be relative to the location
        of the config file itself.</p>
        <p>
          Currently it looks like some parameters that take file names
          or paths as values will accept relative paths, but not all. The
          most important one for me that does not accept relative paths
          is the SALT/CommandFolder that specifies where to look for user
          commands. (I could probably hack this, but if I start looking
          at the APL code in
          <code>⎕SE</code>
          , the urge to rewrite the entire user command framework will
          be overwhelming - must not do that!) Thus I am stuck with a unportable
          configuration file that looks something like:
        </p>
        <pre>
          <code>{ 
  Settings: {
             Default_IO: 0,
             Default_ML: 3, 
             ClassicMode: 1,
             ClassicModeSavePosition: 1,
             SingleTrace: 1,
             AutoPW: 1, 
             SessionOnTop: 1,                          
             Log_Size: "8M",
             MaxWS: "8G",
             PropertyExposeRoot: 1,
             Load: "startup.apln",   
             SALT: {
                    CommandFolder: "c:/APLStartup/;[dyalog]/SALT/spice",                 
                   },
             Colours: {
                       SchemeName: "Back in Black",  
                      },
            }
}
</code>
        </pre>
        <p>We should be able to write something like:</p>
        <pre>
          <code>  SALT: {
            CommandFolder: "[configfolder];[dyalog]/SALT/spice",                 
        },
</code>
        </pre>
        <h2>Fixing and Executing Code on Startup</h2>
        <p>There are at least four ways to fix and excute code on startup:</p>
        <p>
          1. The user command framework using a
          <strong>setup.dyalog</strong>
          file.
        </p>
        <p>
          2. The
          <strong>DyalogStartup</strong>
          parameter.
        </p>
        <p>
          3. The
          <strong>DyalogStartupSE</strong>
          parameter.
        </p>
        <p>
          4. The
          <strong>Load</strong>
          (and
          <strong>LX</strong>
          ) configuration parameter.
        </p>
        <p>
          Option 1 requires placing setup.dyalog in a specific place, this
          is a no go. Option 2 requires highjacking LINK, and the DyalogStartupSE
          parameter which we probably don't want to do. Option 3 requires
          either putting code in some specific place that dyalog knows
          about or specifying a fully qualified path. Furthermore, there
          is a heirarchy of folders that are searched, which may be too
          clever by half, and lead to a lot of confusion. That leaves Option
          4, the
          <code>Load</code>
          parameter. Luckily it respects relative paths, and will look
          in the same location as the config file. The code can expunge
          itself after executing, and not clutter the root or introduce
          a name conflict. Here, for example, is a very simple startup
          routine that increases the font size, and specifies that the
          session window should be maximized:
        </p>
        <pre>
          <code>:Namespace startup
     ⎕SE.FontObj[1]←28
     ⎕SE.State←2
     Run←{
         #.⎕EX 'startup'
     }
:EndNamespace
</code>
        </pre>
        <p>Of course we could do much more here, like set PFKeys, load
        code into ⎕SE, mess around with menus, etc.</p>
        <p>
          It is not clear to me what precisely Dyalog envisioned as use-cases
          for the
          <code>Load</code>
          parameter. It accepts, workspaces, functions, namespace and class
          scripts and even, new in 18.2, a folder that is then automatically
          LINKed. For developement purposes, it seems ideal to use
          <code>Load</code>
          for session configuration.
        </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/a-new-workspace-file-format">A New Workspace
            File Format</a>
          </h1>
          <h2>February 26, 2022</h2>
        </header>
        <p>
          I have documented how namespace scripts are a
          <a href="/posts/building-namespace-scripts">practical and efficient</a>
          way to store and transport source code. I have also documented
          that
          <a href="/posts/the-problem-with-namespace-scripts">they have
          problems</a>
          that prevent using them to their full potential.
        </p>
        <p>When we are able to define both scripted and unscripted namespaces,
        and when we are able to define the root namespace, all in a script,
        many very useful possibilites follow effortlessly.</p>
        <p>
          First the Dyalog interpreter should be able to simply open a
          script that defines the root. Thus if we have a simple text file
          <code>myworksapce.apln</code>
          :
        </p>
        <pre>
          <code>:Namespace #
   ⎕IO←0
   A←⍳10
   :Namespace MySpace 
   :Type unscripted
       f←{+/⍵}
   :EndNamespace 
:EndNamespace
</code>
        </pre>
        <p>Then in the session all we need to do is:</p>
        <pre>
          <code>      )load myworkspace.apln
</code>
        </pre>
        <p>
          In other words, we have a new, non-binary file format for the
          workspace. Furthermore, it zips up very well, so we could have,
          say,
          <code>.dwsx</code>
          files that are compressed text versions of dws files, analagous
          to Microsoft Excel
          <code>.xls</code>
          and
          <code>.xlsx</code>
          files. (In my sample, a 13 MB binary workspace is 750 KB as compressed
          text.)
        </p>
        <p>
          All sorts of possibilites arise with a zipped
          <code>.dwsx</code>
          file format, as it can contain, like
          <code>.xlsx</code>
          files, multiple files and folders. For example, it could contain
          a
          <a href="https://help.dyalog.com/18.0/#UserGuide/Installation%20and%20Configuration/Configuration%20Files.htm#Configuration_Files">configuration
          file</a>
          . It could have multiple namespace scripts and only load and
          fix code on demand.
        </p>
        <p>
          A
          <code>.dwsx</code>
          would probably not be appropriate for developement, as it would
          have the same drawbacks as a binary
          <code>.dws</code>
          file, but for sharing code, transport and application distribution
          it may be ideal. A non-zipped
          <code>.apln</code>
          file, however, may be quite useful for development: Open a clear
          workspace, start coding,
          <code>)saveastext</code>
          and have a text file representation of the workspace.
        </p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2022 Paul S. Mansour</p>
    </footer>
  </body>
</html>
