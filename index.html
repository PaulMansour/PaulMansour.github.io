<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/on-control-structures">On Control Structures</a>
          </h1>
          <h4>August 1, 2022</h4>
        </header>
        <p>
          The
          <a href="https://www.arraycast.com/episodes/episode32-control-structures">latest
          episode of Array Cast</a>
          is on control structures. As usual, it is an excellent episode,
          covering history and all the options in the various array languages.
          However, the panelists raised a number of interesting questions
          which were not fully examined, let alone answered - understandable,
          given how much material was covered and the time constraints.
          One question was why use control structures at all?
        </p>
        <p>
          One of the main arguments made in favor of using control structures
          was
          <em>expediency</em>
          . While this argument was meant to be proscriptive, it is definitely
          descriptive: it is obvious from inspecting large APL code bases
          that make heavy use of control structures. But expediency is
          just another word for a shortcut. We don't have time to do it
          right, so we take the fast and easy way out. As tempting as this
          always is, it is almost never the right approach.
        </p>
        <p>Expediency piles on the technical debt. When hitting a bug,
        instead of refactoring the code, and perhaps extracting a new function
        or two, we just if-then-else or trap around the problem. Functions
        lose their focus, they get longer and longer, variables proliferate,
        control structures get nested, and nested, and nested again.</p>
        <p>Note that the issue here is not searching for an array-based
        solution, which, as noted in the podcast, may be difficult (or
        even impossible) and may not be worth the time. The issue is general
        refactoring, important in any language or paradigm. When there
        is a function that appears to require lots of control structure
        statements, it is often possible to rearrange things and factor
        out the control structures. A new function or two may need to be
        extracted to cleanly eliminate some control structures. This effort,
        and make no mistake, it is indeed effort, is well worth it.</p>
        <p>By eliminating control structures, one gains a deeper understanding
        of the problem, and the resulting code is shorter, more direct,
        and easier to debug, maintain and enhance. And by extracting more
        and more functions a domain-specfic English vocabulary arises and
        separates itself from the APL primitives. The code can become self-documenting.
        In the end we may still need some control structures, but they
        are separated and are above our APL primitive code. We don't have
        a :If keyword followed by a welter of primitives, a function train,
        and an embedded assignment. Functions are written at the same level
        of abstraction. Functions are mostly written in English, or mostly
        written in APL. As was noted in the podcast, it has been suggested
        that control structures are sort of outside the language of APL.
        If it is a good idea that we code at the same level of abstraction,
        it follows that control structures should not be mixed with the
        heavy use of primitives.</p>
        <p>Most importantly, control structures provide an easy way to
        avoid naming things. Refactoring code to remove control structures
        requires naming new functions. Naming things is important. Naming
        is also hard under the best of circumstances. When looking at a
        large rambling function is can be impossible to find any section
        that is nameable - without rewriting everything. When a program
        is a single large function full of control structures, a fix or
        enhancement can be made with little thought to where it goes, precisely
        because there is no particular place for anything. There is only
        one name, the name of the big function. It's like a large messy
        room with no closet, chest of drawers, or desk. Anything can just
        get thrown in the room with no concern for where it is. This is
        chaos.</p>
        <p>In a program with many small well-named functions, the place
        for a change must be carefully considered. There may be no good
        place for the change, and a new function may be required. Or the
        change may go in a particular function, expanding or changing its
        duties and making its name inappropriate. A change can easily require
        multiple function name changes and the introduction of new functions.
        This takes work. This program is like a large neat room with appropriate
        storage; everything has a place, and everything in its place. The
        dirty shirt has a place in the hamper, the book has a place on
        the desk. If the room acquires a lot of books, and the desk becomes
        unmanageable, a bookshelf is installed. This is order. Bringing
        order out of chaos requires naming. Keeping things in order requires
        renaming.</p>
        <p>In addition to the question of why use control structures at
        all, the panelists pondered if it is it possible to write large
        scale applications without them. These two questions are related,
        and if the answer to the first is primarily "expediency", the answer
        to the second is definitely "yes".</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/leetcode-601">LeetCode 601: Human Traffic of
            Stadium</a>
          </h1>
          <h2>July 9, 2022</h2>
        </header>
        <p>
          In this strangely titled
          <a href="https://leetcode.com/problems/human-traffic-of-stadium/">LeetCode
          problem</a>
          , we are given the following table:
        </p>
        <pre>
          <code> t.Display 0
── LeetCode601.Numbers ─────────
 ┌ID──┐  ┌VisitDate─┐  ┌People┐ 
 ↓1   │  ↓2017-01-01│  ↓10    │ 
 │2   │  │2017-01-02│  │109   │ 
 │3   │  │2017-01-03│  │150   │ 
 │4   │  │2017-01-04│  │99    │ 
 │5   │  │2017-01-05│  │145   │ 
 │6   │  │2017-01-06│  │1,455 │ 
 │7   │  │2017-01-07│  │199   │ 
 │8   │  │2017-01-09│  │188   │ 
 └Int8┘  └Date──────┘  └Int16─┘ 
── 8 rows by 3 columns ─────────
</code>
        </pre>
        <p>And informed that:</p>
        <blockquote>
          <p>VisitDate is the primary key for this table. Each row of this
          table contains the visit date and visit id to the stadium with
          the number of people during the visit. No two rows will have
          the same VisitDate, and as the ID increases, the dates increase
          as well.</p>
        </blockquote>
        <p>And then charged with:</p>
        <blockquote>
          <p>Write an SQL query to display the records with three or more
          rows with consecutive id's, and the number of people is greater
          than or equal to 100 for each. Return the result table ordered
          by VisitDate in ascending order.</p>
        </blockquote>
        <p>Let's take a look at how to the solve this in APL, and then
        translate to a FlipDB solution. First some variables:</p>
        <pre>
          <code>      i←1+⍳8
      p←10 109 150 99 145 1455 199 188 
</code>
        </pre>
        <p>Note that the visit date adds nothing of interest to this problem.
        Also note we assume, for now, the IDs are already in ascending
        order. Selecting out IDs where the number of People is greater
        than 100:</p>
        <pre>
          <code>      j←(p&gt;100)/i
      j
2 3 5 6 7 8
</code>
        </pre>
        <p>
          This yields non-consecutive IDs, which is the heart of the problem.
          We now need to identify runs of non-consecutive IDs, which is
          easy using the rank idiom (
          <code>⍋⍋</code>
          ):
        </p>
        <pre>
          <code>      j-⍋⍋j
2 2 3 3 3 3 
</code>
        </pre>
        <p>We might reach for pair-wise reduction here instead, to find
        where the IDs increase by more than one, but that leads to a more
        complicated solution. Now partition or group the IDs by their runs:</p>
        <pre>
          <code>     g←(j-⍋⍋j)⊆j 
     g
┌───┬───────┐
│2 3│5 6 7 8│
└───┴───────┘
</code>
        </pre>
        <p>And finally, get a simple vector of all IDs that exist in groups
        of 3 or more:</p>
        <pre>
          <code>       k←∊(3≤≢¨g)/g
       k
5 6 7 8 
</code>
        </pre>
        <p>A boolean where clause to apply to the original table is then:</p>
        <pre>
          <code>      i∊k
0 0 0 0 1 1 1 1
</code>
        </pre>
        <p>And we are pretty much done. We can write this as a one-liner
        using a couple of dfns if we want an expression that maps to a
        single FlipDB where statement:</p>
        <pre>
          <code>      i∊∊{(2&lt;≢¨⍵)/⍵}{(⍵-⍋⍋⍵)⊆⍵}(p&gt;100)/i
0 0 0 0 1 1 1 1
</code>
        </pre>
        <p>Now we can almost transliterate into FlipDB:</p>
        <pre>
          <code>      ID in {z where 2 &lt; count z} {(z-rankUp z) partition z} ID where People &gt; 100
</code>
        </pre>
        <p>
          Note that the
          <code>where</code>
          appearing twice above is not a where clause, which is the entire
          statement, but the
          <code>where</code>
          function - a FlipDB structural function. Of course in FlipDB
          we might break the problem down a bit, and define some computed
          values first in our query, and we should probably sort the IDs
          to ensure ascending order:
        </p>
        <table>
          <thead>
            <tr>
              <th class="left">Name</th>
              <th class="left">Expression</th>
              <th class="center"></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="left">
                <code>Over100</code>
              </td>
              <td class="left">
                <code>sortUp ID where People &gt; 100</code>
              </td>
              <td class="center"></td>
            </tr>
            <tr>
              <td class="left">
                <code>Groups</code>
              </td>
              <td class="left">
                <code>{(z - rankUp z) partition z} Over100</code>
              </td>
              <td class="center"></td>
            </tr>
            <tr>
              <td class="left">
                <code>Threes</code>
              </td>
              <td class="left">
                <code>Groups where 2 &lt; count Groups</code>
              </td>
              <td class="center"></td>
            </tr>
          </tbody>
        </table>
        <p>and then write a simple where statement:</p>
        <pre>
          <code>      ID in Threes
</code>
        </pre>
        <p>This keeps it clean, simple, and usefully traceable in the FlipDB
        tracer.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/trains">Trains</a>
          </h1>
          <h2>July 8, 2022</h2>
        </header>
        <p>
          In a
          <a href="/posts/leetcode-571">previous post</a>
          we computed the median on grouped data by replicating it and
          applying a
          <code>median</code>
          function that works on ungrouped data. I assumed that there was
          a way to compute the median without replicating the data, and
          sure enough,
          <a href="http://tamstat.com">Brother Statistician Steve</a>
          sent me this old (pre-interval index) solution (slightly modified
          for explanatory purposes):
        </p>
        <pre>
          <code>median1←{
    ⍝ ⍺ ←→ Frequency
    ⍝ ⍵ ←→ Values
    c←(+\⍺)÷+/⍺
    i←(0.5≤c)⍳1
    ⍵[i+0,0.5∊c]+.÷2
}
</code>
        </pre>
        <p>Looking at:</p>
        <pre>
          <code>      (+\⍺)÷+/⍺
</code>
        </pre>
        <p>the function train jumps right off the monitor:</p>
        <pre>
          <code>      +\÷+/
</code>
        </pre>
        <p>
          As an aside, trains come in two styles. First is the
          <strong>Orange Blossom Special</strong>
          style, of which this is a prime example. These trains are elegant,
          a great pleasure to ride. Then we have the
          <strong>Amtrak</strong>
          style, which is a mess of tacks, jots, and tildes diaeresis.
          (I'm guessing that is the proper plural form, and not tilde diaereses.)
          These trains are all glue and duct tape. A terrible travel experience.
          One is better off taking the dfn.
        </p>
        <p>But the point of this post is that it never occurred to me that
        trains work in FlipDB. And why wouldn't they?! In the FlipDB session:</p>
        <pre>
          <code>      (sum running / sum) 7 1 3 1
┌────────────┐
↓0.5833333333│
│0.6666666667│
│0.9166666667│
│1           │
└Float───────┘
</code>
        </pre>
        <p>So we can use trains anywhere, in a where clause, a select clause,
        a having clause, anywhere a FlipDB expression is called for.</p>
        <p>Ten minutes after Steve sent over the solution above he sent
        a new one using interval index, and catching the train too.</p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2022 Paul S. Mansour</p>
    </footer>
  </body>
</html>
