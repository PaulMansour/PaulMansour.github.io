<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/constructing-css-in-apl">Constructing CSS in
            APL</a>
          </h1>
          <h2>September 30, 2022</h2>
        </header>
        <p>
          Once we have mastered
          <a href="posts/a-document-object-model-in-apl">building HTML
          pages</a>
          , the next task is constructing CSS in an efficient and orderly
          way.
        </p>
        <p>While is it not as important to manipulate CSS the same way
        we need to be able to manipulate the DOM, we still want to create
        CSS programmatically, to allow for properties that depend on variables,
        to avoid catenating strings, specifying braces, colons and semicolons,
        and to not worry about getting the nesting right. We don't want
        to write CSS by hand in text files.</p>
        <p>We can do this with 3 fairly simple functions. One for creating
        a new rule:</p>
        <pre>
          <code>NewRule←{
     ⍝ ⍺ ←→ [Parent]
     ⍝ ⍵ ←→ Selector e.g. 'h1' 'h1 h2' 'header&gt;h1', etc.
     ⍺←0
     r←⎕NS''
     r.Selector←⍵
     r.Rules←⍬
     ⍺=0:r
     ⍺.Rules,←r
     r
 }
</code>
        </pre>
        <p>One for composing the rules:</p>
        <pre>
          <code>ComposeRules←{
     ⍝ ⍵ ←→ Vector of CSS Rules
     ⍺←0
     0=≢⍵:''
     nl←⎕UCS 13
     ⊃,/((⍺&gt;0)/nl),⍺{
         0=≢⍵.Selector:⍺ ComposeRules ⍵.Rules
         b←(4×⍺)⍴' '
         s←b,⍵.Selector,' {',nl
         s,←⍺ ComposeDeclarations ⍵
         s,←¯1↓(⍺+1)ComposeRules ⍵.Rules
         s←s,b,'}',2⍴nl
         s
     }¨⍵
 }
</code>
        </pre>
        <p>And one subfunction for composing declarations:</p>
        <pre>
          <code>ComposeDeclarations←{
     ⍺←0
     nl←⎕UCS 13
     n←{⍵/⍨~(⊃¨⍵)∊⎕A}⍵.⎕NL ¯2
     0=≢n:''
     v←⍕¨⍵⍎¨n
     p←'-'@('_'∘=)¨n
     b←(4×⍺+1)⍴' '
     ⊃,/p{b,⍺,': ',⍵,';',nl}¨v
 }
</code>
        </pre>
        <p>Consider a single, simple rule:</p>
        <pre>
          <code>      r←NewRule 'h1'
</code>
        </pre>
        <p>Specifying declarations is done by assignment:</p>
        <pre>
          <code>      r.margin←'1rem'
      r.font_size←'2rem'
</code>
        </pre>
        <p>
          The
          <code>ComposeRules</code>
          function returns the CSS:
        </p>
        <pre>
          <code>      ComposeRules r
h1 {
    font-size: 2rem;
    margin: 1rem;
}
</code>
        </pre>
        <p>
          Of course a style sheet will contain many rules, often nested.
          The
          <code>NewRule</code>
          function takes a parent rule as an optional left argument:
        </p>
        <pre>
          <code>      p←NewRule '@media print'
      r←p NewRule 'h1'
      r.font_size←'18pt' 
      r←p NewRule 'h2'
      r.font_size←'16pt'
      ComposeRules p
@media-print {
    h1 {
        font-size: 18pt;
    }
    h2 {
        font-size: 16pt;
    }
}
</code>
        </pre>
        <p>
          This allows us to bury the catenation or accumulation of rules.
          We can also reuse the same variable name for the result of
          <code>NewRule</code>
          , normally a bad practice, but useful in this case, when there
          could be hundreds of rules that need to be specified, and we
          don't want to have to name them all.
        </p>
        <p>Having a parent rule is useful as it means we have only one
        item to explicitly name and track. But often there is no parent,
        just a list of rules with no hierarchy. We can accumulate rules
        using a parent rule with no selector:</p>
        <pre>
          <code>      s←NewRule ''
      r←s NewRule 'h1'
      r.font_size←'2em' 
      r←s NewRule 'h2'
      r.font_size←'1.5em'
      ComposeRules s
h1 {
    font-size: 2em;
}
h2 {
    font-size: 1.5em;
}
</code>
        </pre>
        <p>
          This lets us avoid complicating things with a Style object. There
          is only one object, a rule object, and it can contain sub rules.
          And
          <code>ComposeRules</code>
          can process multiple sets of rules:
        </p>
        <pre>
          <code>      ComposeRules s p
h1 {                    
    font-size: 2em;     
}                       
                        
h2 {                    
    font-size: 1.5em;   
}                       
                        
@media print {          
                        
    h1 {                
        font-size: 18pt;
    }                   
                        
    h2 {                
        font-size: 16pt;
    }                   
}                       
</code>
        </pre>
        <p>
          These rules can be injected directly into the APLDOM using the
          <code>Style</code>
          property:
        </p>
        <pre>
          <code>       d←New'html'
       hd←d New'head'
       d.Style←s
       DOM2HTML d
&lt;!DOCTYPE html&gt;      
&lt;html&gt;               
  &lt;head&gt;             
    &lt;style&gt;          
        h1 {                 
          font-size: 2em;  
           }                    
                     
        h2 {                 
          font-size: 1.5em;
           }                    
    &lt;/style&gt;         
  &lt;/head&gt;            
&lt;/html&gt;          
</code>
        </pre>
        <p>
          HTML elements may have their own Style property, to allow for
          components to be delivered with their own styles. The idea is
          do something similar to
          <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components">Web
          Components</a>
          . This is an area where
          <a href="https://github.com/the-carlisle-group/Abacus">Abacus</a>
          needs much more work, hopefully soon.
        </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/threading-the-htmlrenderer">Threading the HTMLRenderer</a>
          </h1>
          <h2>September 22, 2022</h2>
        </header>
        <p>The HTMLRenderer supports web sockets, which gives us two-way
        asynchronous communication between the browser and the APL session.
        The browser can send a message to APL, and APL can send a message
        to the browser. However, in neither case is the sender waiting
        for a reply from the recipient. Much functionality can be achieved
        this way. However, there are at least two cases when, from APL,
        we want to send a message to the HTMLRenderer and wait for a response.
        The first is simply to execute a little general JavaScript. We
        might want to execute '2+2' or get the innerHTML from an element,
        or get the HTML of the entire page. This should work anytime, anywhere,
        and specifically it must work under the event handler of the WebSocketReceive
        event, which is exactly where it gets tricky.</p>
        <p>The second is when, from APL, we want to fire an event in the
        HTMLRenderer which has been wired with a event handler that calls
        back into APL. APL handles the message, presumably changing some
        state, and perhaps sending a message back to the HTMLRenderer,
        changing some state there. In this case we want to be able to wait
        in APL for all this to happen, and then verify the state changes.
        In other words, we want to test our HTMLRenderer GUI code in a
        easy, linear fashion, in one APL process. This post attempts to
        explain an attempt to implement this synchronous behavior for these
        two cases.</p>
        <p>
          The
          <code>ExecutJavaScriptSync</code>
          function executes a snippet of JavasScript and waits for a response:
        </p>
        <pre>
          <code>ExecuteJavaScriptSync←{
     ⍝ ⍺ ←→ Document
     ⍝ ⍵ ←→ Javascript
     ⍝ ← ←→ Result                                                     
     c←'"',⍵,'"'
     j←'execCode(',(⍕⎕TID),',',c,')'
     _←⍺ ExecuteJavaScript j
     ⎕TGET ⎕TID
 }
</code>
        </pre>
        <p>The left argument is the APLDOM object, the right argument is
        a string of JavaScript. The thread ID is used as a message identifier.</p>
        <p>There is also a cover function that executes a string of javascript
        inside a specfic element:</p>
        <pre>
          <code>ExecuteOnElementSync←{
     ⍝ ⍺ ←→ Element
     ⍝ ⍵ ←→ Javascript
     ⍝ ← ←→ Result
     i←TagIndex ⍺
     t←⍺.Tag
     c←'document.getElementsByTagName'
     c,←'(''',t,''').item(',(⍕i),').',⍵,';'
     ⍺.Document ExecuteJavaScriptSync c
 }
</code>
        </pre>
        <p>
          The
          <code>ExecuteJavaScript</code>
          function just sends the data over the socket:
        </p>
        <pre>
          <code>ExecuteJavaScript←{
     ⍝ ⍺ ←→ Document
     ⍝ ⍵ ←→ JavaScript
     ⍺.HTMLRenderer.WebSocketSend ⍺.HTMLRenderer.WebSocketID ⍵ 1 1
 }
</code>
        </pre>
        <p>Note that we do not make use of the HTMLRenderer.ExecuteJavaScript
        method.</p>
        <p>
          Once the message is sent, we wait for a token (
          <code>⎕TGET ⎕TID</code>
          ). Meanwhile, in the HTMLRenderer, the following JavaScript is
          executed on receipt of the message from APL:
        </p>
        <pre>
          <code>  function execCode(id,code) { 
         const b = {Event: "SJSR", id: id, result: eval(code) }; 
         const m = JSON.stringify(b); 
         ws.send (m)
}      
</code>
        </pre>
        <p>
          This simply evaluates the code and sends the result and the id
          back to APL. It also invents and returns an event named "SJSR"
          for
          <strong>synchronous javascript result</strong>
          .
        </p>
        <p>Back in APL, we are waiting for and processing messages from
        the HTMLRenderer via the HTMLRenderer's WebSocketReceive event:</p>
        <pre>
          <code>OnWebSocketReceive←{
     h←⊃⍵
     c←⎕JSON 3⊃⍵
     c.Event≡'SJSR':c.result ⎕TPUT c.id
     d←h.Document
     q←d.StopPropagation
     d.StopPropagation←0
     q:0
     c.HTMLRenderer←h
     j←c.TargetIndex
     k←c.CurrentTargetIndex
     te ce←(Elements d)[j k]
     c.Target←te
     c.CurrentTarget←ce
     h.LastTID←h.LastTID HandleRequest&amp;c
     0
 }
</code>
        </pre>
        <p>This function must handle messages that are instigated by events
        in the browser, like clicking a button, as well as messages responding
        to synchronous calls from APL (the "SJSR" event).</p>
        <p>
          We must allow
          <code>OnWebSocketReceive</code>
          to fire continuously without waiting for the event handler in
          APL (for the click event on a button, say) to complete. Otherwise
          if the event handler itself sends a synchronous request back
          to the browser, the system will deadlock, waiting for a response
          that will never arrive, as
          <code>OnWebSocketReceive</code>
          can never fire as it is waiting for the event handler to complete,
          which is waiting for the response to the synchronous request.
          Thus we need to thread something, somewhere. But this introduces
          a new problem. The moment we thread, we allow all browser events
          to be processed concurrently, when we only want SJSR events processed
          concurrently with respect to all other events. All events initiated
          by the browser must be processed sequentially and exclusively,
          unless of course explicitly threaded somewhere in their own handlers.
        </p>
        <p>
          It is possible to thread
          <code>OnWebSocketReceive</code>
          itself, but this only makes it significantly more difficult to
          queue the events. Instead we thread at the very end where we
          call
          <code>HandleRequest</code>
          which waits for the previous request to complete before executing:
        </p>
        <pre>
          <code>HandleRequest←{
     _←{6::0 ⋄ ⎕TSYNC ⍵}⍺
     _←(⍎⍵.CurrentTarget⍎'On',⍵.Event)⍵
     ~EventToken∊⎕TREQ ⎕TNUMS:0
     ⍵ ⎕TPUT EventToken
 }
</code>
        </pre>
        <p>
          Because
          <code>OnWebSockReceive</code>
          is single-threaded, we are guaranteed that
          <code>LastTID</code>
          is updated before the next message is received, and events processed
          in the proper order.
        </p>
        <p>If the event is "SJSR", that is if the event is the result of
        a synchronous JavaScript request, we put a token whose value is
        the result into the pool, signaling to the waiting thread that
        it now has its requested result. The second case for synchronous
        behavior is testing. We want to be in APL and initiate an event
        in the HTMLRenderer that in turn sends a message to APL that does
        some processing. When this processing is complete, we want to verify
        some state change. Let's look at a sample test function:</p>
        <pre>
          <code>TestDecrement←{
     d←⍵.Document
     r←d A.ElementById'result'
     v←⍎⊃r.Content
     b←d A.ElementById'decrement'
     _←b A.FireEventAndWait'click'
     (v-1)≠⍎⊃r.Content
 }
</code>
        </pre>
        <p>
          This function first inspects and saves the content of an element,
          then fires a click event in the HTMLRenderer and waits for the
          event handler to complete, and finally compares the new value
          in the element to the expected value. The
          <code>FireEventAndWait</code>
          function is:
        </p>
        <pre>
          <code>FireEventAndWait←{
     ⍝ ⍺ ←→ Element
     ⍝ ⍵ ←→ Event
     ⍺=0:0
     _←⍺ ExecuteOnElement ⍵,'()'
     ⎕TGET EventToken
 }
</code>
        </pre>
        <p>
          The
          <code>EventToken</code>
          is just a constant. Test functions MUST run in their own thread,
          separate from the thread the HTMLRenderer is using to process
          WebSocketReceive events, otherwise no events are processed as
          we sit waiting for
          <code>EventToken</code>
          . What now happens as we are waiting to get
          <code>EventToken</code>
          ? If we review the last couple of lines of
          <code>HandleRequest</code>
          above we see that after an event is processed if there is any
          thread waiting on an EventToken, then it is supplied:
        </p>
        <pre>
          <code>     ~EventToken∊⎕TREQ ⎕TNUMS:0
     ⍵ ⎕TPUT EventToken 
</code>
        </pre>
        <p>The test framework can thread itself, so all of the tests run
        in a new thread:</p>
        <pre>
          <code>RunTests←{
     ⍝ ⍺ ←→ [Namespace of tests]
     ⍝ ⍵ ←→ HTMLRenderer
     ⍺←⊃⎕RSI
     ⎕TID=0:⍺ ∇&amp;⍵
     s h←⍺ ⍵
     c←'Passed' 'Failed' 'Broken' 'N/A' 'Disabled'
     r←{
         b←{0::2 ⋄ (s⍎⍵)h}⍵
         b⊣⎕←⍵,': ',⍕b⊃c
     }¨'T's.⎕NL ¯3
     n←¯1+{≢⍵}⌸r,⍨⍳≢c
     ⍉↑(c,⊂'Total')(n,+/n)
 }
</code>
        </pre>
        <p>
          The only reason to thread the event handler in
          <code>OnWebSocketReceive</code>
          is to allow for synchronous JavaScript from within the event
          handler. If synchronous JavaScript is not needed, the
          <code>&amp;</code>
          and the
          <code>⎕TSYNC</code>
          may just be removed, and all event handlers run in thread 0,
          for what that is worth. Tests need to be threaded regardless,
          and as a byproduct this allows synchronous JavaScript to run
          in tests even when not threading the event handler.
        </p>
        <p></p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/a-document-object-model-in-apl">A Document
            Object Model in APL</a>
          </h1>
          <h2>September 21, 2022</h2>
        </header>
        <p>With a web browser now effectively built into the interpreter,
        constructing and manipulating HTML and the DOM in a simple and
        consistent way has never been more important. Explicitly catenating
        strings is no way to go through life. Lots of (my) old code looks
        like:</p>
        <pre>
          <code>       '&lt;h1&gt;',t,'&lt;/h1&gt;'
</code>
        </pre>
        <p>or barely better we might define tag as:</p>
        <pre>
          <code>        tag←{'&lt;',⍺,'&gt;',⍵,'&lt;/',⍺,'&gt;'}
</code>
        </pre>
        <p>
          And then tag this, that and the other, which all has to be catenated
          up. And then we enhance
          <code>tag</code>
          to take an argument with attributes. It doesn't get better. And
          when we are done, we have a horrific string, probably nested
          in various places by mistake, of hopefully valid HTML that we
          cannot manipulate in any meaningful way.
        </p>
        <p>
          Consider instead a single simple function
          <code>New</code>
          :
        </p>
        <pre>
          <code>   New←{
     ⍝ ⍺ ←→ [Parent, 0 - no parent]
     ⍝ ⍵ ←→ Tag [Content [Attributes]]
     ⍝ ← ←→ Element
     ⍺←0
     s←IsString ⍵
     t c a←s⊃(3↑⍵,⊂⍬)(⍵''⍬)
     e←⎕NS''
     e.Tag←,t
     e.Parent←⍺
     e.Content←''
     _←a SetAttributes e
     e⊣Add/⍺ e c
 }
</code>
        </pre>
        <p>We can now create an object for an element, and produce HTML
        from it:</p>
        <pre>
          <code>      h←New 'h1' 'My Title'
      DOM2HTML h
&lt;h1&gt;My Title&lt;/h1&gt;
</code>
        </pre>
        <p>Attributes may be specified by assignment:</p>
        <pre>
          <code>      h.class←'chapter'
      DOM2HTML h
&lt;h1 class="chapter"&gt;My Title&lt;/h1&gt;
</code>
        </pre>
        <p>Elements can be created as children:</p>
        <pre>
          <code>      d←New 'html'
      b←d New 'body'
      m←b New 'main'
      DOM2HTML d
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;main&gt;&lt;/main&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code>
        </pre>
        <p>Content may be directly assigned:</p>
        <pre>
          <code>      m.Content←h
      DOM2HTML d
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;main&gt;
      &lt;h1 class="chapter"&gt;My Title&lt;/h1&gt;
    &lt;/main&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code>
        </pre>
        <p>
          Producing HTML without explicit catenation is only a small part
          of the benefit. Consider the function
          <code>Elements</code>
          :
        </p>
        <pre>
          <code>Elements←{
     ⍝ ⍵ ←→ Element
     ⍝ ← ←→ Vector of ⍵ and all sub elements
     326≠⎕DR ⍵:⍬
     ⍵,{c←{0=≢⍵:⍬ ⋄ ⍵/⍨326=⎕DR¨⍵}⍵.Content
         0=≢c:⍬
         ⊃,/c,¨∇¨c}⍵
 } 
</code>
        </pre>
        <p>This traverses the DOM and yields a simple vector of all the
        elements:</p>
        <pre>
          <code>      e←Elements d
      e.Tag
┌────┬────┬────┬──┐
│html│body│main│h1│
└────┴────┴────┴──┘
</code>
        </pre>
        <p>
          With this function in hand, various covers like
          <code>ElementByID</code>
          or
          <code>ElementsByTag</code>
          are trivial to write. Now its easy to find all the h1 headers
          and change, say, their class.
        </p>
        <p>Tables are especially painful to deal with without the proper
        tooling. With a few helper functions to extract cells, we can manipulate
        HTML tables like an array programmer should:</p>
        <pre>
          <code>     t←NewTable ⍕¨3 4⍴⍳12
     c←BodyCells t
     c[;2].class←⊂'char'
     DOM2HTML t
&lt;table&gt;                       
  &lt;tbody&gt;                     
    &lt;tr&gt;                      
      &lt;td&gt;0&lt;/td&gt;              
      &lt;td&gt;1&lt;/td&gt;              
      &lt;td class="char"&gt;2&lt;/td&gt; 
      &lt;td&gt;3&lt;/td&gt;              
    &lt;/tr&gt;                     
    &lt;tr&gt;                      
      &lt;td&gt;4&lt;/td&gt;              
      &lt;td&gt;5&lt;/td&gt;              
      &lt;td class="char"&gt;6&lt;/td&gt; 
      &lt;td&gt;7&lt;/td&gt;              
    &lt;/tr&gt;                     
    &lt;tr&gt;                      
      &lt;td&gt;8&lt;/td&gt;              
      &lt;td&gt;9&lt;/td&gt;              
      &lt;td class="char"&gt;10&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;             
    &lt;/tr&gt;                     
  &lt;/tbody&gt;                    
&lt;/table&gt;                      
</code>
        </pre>
        <p>Finally we can take HTML and get back the DOM:</p>
        <pre>
          <code>       html←DOM2HTML t
       t2←HTML2DOM html
       html≡DOM2HTML t2
1
</code>
        </pre>
        <p>
          Where
          <code>HTML2DOM</code>
          is:
        </p>
        <pre>
          <code>HTML2DOM←{
     ⍝ ⍵ ←→ HTML
     ⍝ ← ←→ DOM
     0=≢⍵:⍬
     {⍵⌷⍨⍳1=⍴⍵}0{
         m←⍵
         0=≢m:⍺
         b←m[;0]=0
         p←⍺{⍺ New 3↑1↓⍵}¨↓b⌿m
         m[;0]-←1
         p⊣p ∇¨1↓¨b⊂[0]m
     }⎕XML ⍵
 }
</code>
        </pre>
        <p>Once you start creating HTML this way, patterns arise and utility
        functions fall out naturally. These utilities return content that
        can be manipulated and injected anywhere.</p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2022 Paul S. Mansour</p>
    </footer>
  </body>
</html>
