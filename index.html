<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <h3>"You don't know how bad your code is until you write about it."</h3>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/a-fair-mutex">A Fair Mutex</a>
          </h1>
          <h2>June 24, 2024</h2>
        </header>
        <p>A mutex may be <em>fair</em> or <em>unfair</em>. A fair mutex lets threads into the  critical section in the order in which they request the lock. That is, FIFO; the thread waiting the longest, will be serviced first. That certainly seems fair.</p>
        <p>An unfair mutex provides no such guarantee. This means that a thread can be starved - it may  never be allowed to proceed into the critical section. That certainly seems unfair.</p>
        <p>In Dyalog:</p>
        <pre><code>:Hold TokenString
    ...
    critical section
    ...
:EndHold
</code></pre>
        <p>implements an unfair mutex. And it <strong>will</strong> starve threads. A newly created thread that hits the <code>:Hold</code> will be serviced before any existing threads that may be waiting. The same is true for:</p>
        <pre><code>⎕TGET TokenInt
...
critical section
...
⎕TPUT TokenInt
</code></pre>
        <p>No doubt the interpreter uses the same algorithm for servicing waiting threads in both cases. Unfair mutex implementations are the norm in the industry, for reasons I don't fully understand. A cursory glance at the literature indicates that unfair mutexes are more efficient in some way.  Presumably if it matters not in what order waiting threads are serviced, the interpreter has less to keep track of. One example often given is when a thread releases a mutex and then tries to reaquire it (not a good pattern I think anyway), a fair mutex will put it at the end of the line, whereas  an unfair mutex can put it at the head the line, and avoid some thread switching. It is not clear to me if these efficiency arguments hold for the type of threads that the Dyalog interpreter implements.     </p>
        <p>Anyway, the question arises, can we implement a fair mutex in Dyalog? Let's look at a very simple implementation. Using the token pool we can create a new mutex object:</p>
        <pre><code>NewMutex←{
     m←⎕NS''
     m.Key←{}&amp;0
     m⊣⎕TPUT m.Key
 }
</code></pre>
        <p>The mutex has a key, which must be aquired to gain access. At the same time, the key must be changed for the next thread. Any unique key value per thread could be used. We use the thread ID for convenience.</p>
        <p>To initialize the mutex, we burn a thread and then put the key into the token pool.                                                       </p>
        <p>To enter the critical section, a thread has to wait for the current mutex key, and then create a new key using the <code>Lock</code> function, which takes the mutex as the right argument:                                                      </p>
        <pre><code>Lock←{
     k←⍵.Key
     ⍵.Key←⎕TID
     ⎕TGET k
 }
</code></pre>
        <p>When it exits the critical section, the thread has to unlock the mutex by putting the key into the token pool:                                                      </p>
        <pre><code>Unlock←{
     ⊢⎕TPUT ⎕TID
}
</code></pre>
        <blockquote>
          <p>the <code>⊢</code> is needed only because I think there is a bug in the intepreter. In test code, I use <code>⎕TSYNC ⎕TNUMS~0</code>  to know when all the threads have completed. Without the <code>⊢</code>,  the <code>⎕TSYNC</code> fails because "VALUE ERROR: No result was provided when the context expected one." This does not seem right. Must have something to do with the fact the result of <code>⎕TPUT</code> is shy.</p>
        </blockquote>
        <p>The <code>Unlock</code> function does not really need to know about the particular mutex instance, as the key is simply the thread id.</p>
        <p>I don't think it is as simple to implement a fair mutex using <code>:Hold</code>, as it is not natural construct for waiting on one token and then releasing a different token.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/how-to-center-a-dialog-element">How to Center
            a Dialog Element</a>
          </h1>
          <h2>May 29, 2024</h2>
        </header>
        <p>How to center a <em>modal</em> dialog box to be precise.</p>
        <p>TL;DR:</p>
        <pre><code>     
</code></pre>
        <p>Yes, that's right. Nothing. Nada. Zero. Zilch.</p>
        <p>Now for the full story.</p>
        <p>I have been using a <a href="https://www.toolofthought.com/posts/beware-the-blur">ubiquitous but archaic and problematic technique</a> to center a modal dialog box in the viewport. On this morning's drive listening to the <a href="https://syntax.fm/show/775/components-we-need-on-every-project">current episode</a> of the excellent web dev podcast <a href="https://syntax.fm/">Syntax</a>, the hosts hinted at another method for centering using the CSS <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/inset">inset</a> property, which I was unfamiliar with. It turns out this property is just shorthand for top, right, bottom and left. Looking for more information, I stumbled on this <a href="https://www.youtube.com/shorts/9cSL5dP4rgM">video short</a>. Could it be that simple? All we need is <code>inset:0</code> and <code>margin:auto</code>? It turns out it is even simpler!</p>
        <p>It is useful to inspect the user-agent styling for <code>&lt;dialog&gt;</code> (in Chrome):</p>
        <pre><code>  dialog:-internal-modal {
    position: fixed;
    top: 0px;
    bottom: 0px;
    max-width: calc((100% - 6px) - 2em);
    max-height: calc((100% - 6px) - 2em);
    overflow: auto;
}    
  dialog {
    display: block;
    position: absolute;
    left: 0px;
    right: 0px;
    width: fit-content;
    height: fit-content;
    color: -internal-light-dark(black, white);
    margin: auto;
    border-width: initial;
    border-style: solid;
    border-color: initial;
    border-image: initial;
    padding: 1em;
    background: -internal-light-dark(white, black);
}
</code></pre>
        <p>Note the default values for the <code>&lt;dialog&gt;</code> element properties <code>position</code>, <code>left</code>, <code>right</code>, and <code>margin</code>. Further note that that when the <code>&lt;dialog&gt;</code> element is opened in a modal state, additional properties are defaulted, and some are overridden. The net result is that for a modal dialog box, the default value of <code>inset</code> is <code>0</code>, and the default value of <code>margin</code> is <code>auto</code>. Therefore, to center a modal dialog, <strong><em>nothing needs to be done</em></strong>.    But it is likely you have a CSS reset that sets all margins to <code>0</code>. In that case you will need: </p>
        <pre><code>    margin:auto;
</code></pre>
        <p>I don't think it likely that <code>inset</code> will have a different value than <code>0</code>, so no need to explicitly set it. </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/beware-the-blur">Beware the Blur, and More</a>
          </h1>
          <h2>May 24, 2024</h2>
        </header>
        <p>Modal dialog boxes are trivial now with the <code>&lt;dialog&gt;</code> element and the JavaScript <code>showModal</code> method. Almost all of the demos and introductions to this functionality love to show off the associated CSS <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/::backdrop">backdrop pseudo-element</a>, which allows us to style the background of the dyalog when it is being shown in a modal state.                Usually we see some CSS like:</p>
        <pre><code>dialog::backdrop {
  backdrop-filter: blur(2px);
}
</code></pre>
        <p>Which blurs out the background. This looks really nice. However, it turns out that it is a <a href="https://github.com/thirdweb-dev/dashboard/issues/703">ridiculously expensive effect</a>. If you have any changes to the dialog while it is open, the repaint is very slow. In our app, we have modal dialogs that contain small tables for editing. A background blur makes them unusable. </p>
        <p>Another thing to watch out for is using <code>transform</code> to center a dialog element. It's a cute technique: put the upper left corner in the center, and then move it back and to the left by 50 percent. In Abacus-style CSS:</p>
        <pre><code>     s.position←'fixed'
     s.left←'50%'
     s.top←'50%'
     s.transform←'translate(-50%, -50%)'
</code></pre>
        <p>All well and good, but there is a side-effect of using <code>transform</code> that affects positioning. Elements with fixed position on a dialog box that is centered this way will be <a href="https://dev.to/salilnaik/the-uncanny-relationship-between-position-fixed-and-transform-property-32f6">fixed relative to the dialog, not the viewport</a>, which is what you would normally expect. We have autocomplete elements that pop up on dialogs, and this makes positioning them much harder. For now I have taken to fixing the size of the dialog, so I can center it directly with using <code>transform</code>.</p>
        <p>To sum up, on &lt;dialog&gt; elements:</p>
        <blockquote>
          <p>Don't use <code>backdrop-filter: blur</code></p>
        </blockquote>
        <blockquote>
          <p>Don't use <code>transform</code>. </p>
        </blockquote>
        <p>Time to start a CSS Don'ts page perhaps.</p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2024 Paul S. Mansour</p>
    </footer>
  </body>
</html>
