<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/towards-a-chart-wizard">Towards a Chart Wizard</a>
          </h1>
          <h2>September 20, 2023</h2>
        </header>
        <p>What might a good, embeddable, re-usable chart wizard, wrapping the <a href="https://sharpplot.com">SharpPlot library</a>, look like? This wizard should be easy to add to an application, and could be used in the Dyalog APL session as well. Before designing a GUI for a chart wizard, however, we must design an appropriate, lower-level wrapper for the library.</p>
        <p>SharpPlot is powerful, comprehensive, and well designed. Despite this fact, we still need a thin layer over the top of it to insulate us from the details and idiosyncrasies of .NET, to have a clearer separation of source data and chart properties, and to provide a more declarative language for defining charts.    For example, there are many "set" methods like <code>SetMargins</code> and <code>SetPenWidth</code> that are  conceptually just properties. We should be able to specify them as such. There are also draw methods for each chart type, and we should be able to specify a chart type property rather than call a method. Finally, there is often overlap of the  the primary data of a chart with the argument to the draw method and some additional  properties. For example, the <code>DrawBarChart</code> method requires one or more vectors of bar heights. The corresponding categories, however, are specified via the <code>SetXLabels</code> method. The vast majority of the time, the categories and the corresponding values will be  provided to us as two or more columns in a table, and we should be able to specify the data as such, and have our chart language take care of the rest.  </p>
        <p>For the sake of simplicity, we assume the data is provided in a namespace enclosing a vector of names, and a corresponding vector (of vectors) of values. The particular form of this data is not important. What is important is that it is essentially a table, with named and ordered columns. Using the data from the first example in the SharpPlot <a href="https://sharpplot.com/BarCharts.htm">tutorial on bar charts</a>  we can construct the data space <code>d</code>:</p>
        <pre><code>      v←⊂'Project'('A2' '18' 'Q5' 'T6' 'T8' '32')
      v,←⊂'Last Year'(6 18 27 31 40 43)
      v,←⊂'This Year'(17 33 42 54 71 78)
      d←⎕NS''
      d.(Names Values)←↓⍉⊃v
</code></pre>
        <p>Defining a chart is then an exercise in specifying properties:  </p>
        <pre><code>      c←New 0
      c.ChartType←'BarChart'
      c.Heading←'Comparative Spend 2004-5'
      c.BarChartStyle←'TicksBetween,ValueTags,ForceZero'
      c.XAxisStyle←'XAxisStyles.MiddleLabels,XAxisStyles.GridLines'
      c.ValueTagStyle←'Vertical,Inside,SectorValues,RecolorOutside'
      c.ValueFont←'"Arial" 10 FontStyle.Bold Color.LightYellow'
      c.ValueTagFormat←'###0 Units'
      c.Gap←0
      c.GroupGap←0.5
      c.Colors←'Color.Green Color.Maroon'
      c.XLabelFormat←'Proj-XX'
      c
</code></pre>
        <p>Where <code>New</code> just creates a namespace with a few default properties:</p>
        <pre><code>New←{
     p←⎕NS''
     p.Size←360 240
     p.Multi←0
     p.Scale←'Shadowed'
     p.Select←''
     p
 }
</code></pre>
        <p>Let's note a few things about this chart definition, comparing it  to the <a href="https://sharpplot.com/BarCharts.htm">C# definition</a>. </p>
        <p>First, all property values are simple numeric or text vectors or scalars.</p>
        <p>Second, SharpPlot methods like <code>SetValueFont</code> and <code>SetColors</code> are called by setting the properties <code>ValueFont</code> and <code>SetColors</code>.</p>
        <p>Third, a text vector will be evaluated if the property it is defining is a cover for an underlying SharpPlot method, as is the case for for <code>ValueFont</code>. </p>
        <p>Fourth, in evaluated property values, double quotes are replaced by single quotes before evaluation. </p>
        <p>Fifth, the various style properties that are normally specified as  the sum of one or more enums, like <code>BarChartStyle</code> and <code>YAxisStyle</code>, are specified as comma or space delimited strings. In addition, the dot-qualifying name may be elided if it refers to the name as the property itself.</p>
        <p>Finally, the <code>ChartType</code> property determines which draw method is executed.  </p>
        <p>Now, given the chart definition space <code>c</code> and the data space <code>d</code>, we can create the SVG <code>v</code> with:</p>
        <pre><code>      v←c BuildChart d
</code></pre>
        <p>Note that the <code>ChartType</code> property defines how the data is interpreted, and how specific properties will be automatically set. Any property set by default for the chart type by may also be set by the chart definition. For example, for a bar chart, the <code>XLabels</code> (cover for <code>SetXLabels</code> method) property is automatically set using the values from the first column of the data. Nothing prevents the user from specifying the <code>XLabels</code> property explicitly in the chart definition, overiding the default behavior.</p>
        <h2>The Input Data Table and the Chart Type</h2>
        <p>In the example above, the input data table consisted of 3 columns, <code>Project</code>, <code>Last Year</code>, and <code>This Year</code>. Each <code>ChartType</code> processes the input data table by default in a certain way. For a bar chart, the first column is taken to be the category, and all subsequent columns are taken to be values passed to the <code>DrawBarChart</code> method. Thus, in the case above we get a multi-bar chart, with two bars per category. Most of the time it is easy enough to simply pass the proper table with the proper columns in the proper order to the <code>BuildChart</code> function, from the calling application. Sometimes, however, we have certain columns we want to ignore, or that will be used to split or group data inside SharpPlot. Alternatively the columns may not be in correct order. To facilitate this, we provide a <code>Select</code> method that specifies a list of column names. This is used to select, re-order, and by definition, omit, columns from the input data table for the default processing of the chart type.     </p>
        <h2>Multi Charts</h2>
        <p>One nice feature of SharpPlot is the ability, for certain chart types, to do <a href="https://sharpplot.com/Multiples.htm">multiple mini charts</a> in one go. We add a Boolean property <code>Multi</code> to cover this. If set to <code>1</code>, then each series is drawn on it's own chart. </p>
        <h2>A Fly in the Ointment</h2>
        <p>The chart definition outlined above is just a set of name/value pairs. They can be executed in any order, as they just set the state of the SharpPlot chart object before the appropriate draw method is executed. But there are times when we may want to draw additional things on charts, additional graphs, or lines, perhaps in different colors, and it is important that additional properties are set after the draw method is executed, and then we need to specify the next draw method. Order becomes an issue here. One solution is for <code>BuildChart</code> to accept a list of name/value pairs rather than a namespace. As a chart definition needs to be stored to disk somehow, and a namespace is no good for that, we will need this feature anyway. Now we will have order. The namespace is then just a convenience for writing charts in code, rather than defining the chart in an array of name/value pairs. The result of the wizard should be this array. </p>
        <h2>Next Steps</h2>
        <p>Now that we have a tidy way of defining charts in code or as an array, we can think about a GUI to make it really easy. This is perhaps a good opportunity to look at the HTMLRenderer for a cross-platform solution. </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/testing-guis-wrestling-with-events">Testing
            GUIs: Wrestling with Events</a>
          </h1>
          <h2>August 18, 2023</h2>
        </header>
        <p>GUI applications are complicated. Callbacks are attached to events and processed by <code>⎕DQ</code>. Events can get queued up by their nature. For example, a single user action on a grid can fire a <code>GridKeyPress</code> event, followed by a <code>CellChange</code> event followed by a <code>CellChanged</code> event. Events can also get queued up because a callback explicitly calls <code>⎕NQ</code> adding another event to the queue. During the normal course of using the application, this all just works (hopefully!). However, the moment we try to write automated tests that exercise the GUI, the complexity manifests itself.</p>
        <p>The first problem that arises is that when testing, we cannot run <code>⎕DQ</code> at all. If we <code>⎕DQ</code> the main form, we cannot then run a test function.</p>
        <blockquote>
          <p>Note that it is possible to either write your tests into the application itself, so that they run under the main <code>⎕DQ</code> of the application, or to run  each test under a temporary invocation of <code>⎕DQ</code> - by using <code>⎕NQ</code> to put a test into the queue. But these techniques are overly complicated and add nothing useful. They make writing and tracing tests more difficult, and they don't solve  a secondary problem of modal subforms like dialog boxes.</p>
        </blockquote>
        <p>This is easy to solve. We just use the implicit <code>⎕DQ</code> that runs when the session is wait mode. We should also avoid all uses of <code>⎕DQ</code> to wait on modal forms. A simply <code>TestMode</code>  flag in our application facilitates this. </p>
        <p>The second and more difficult problem to solve is that in a GUI test function we want to fire events and make assertions, and fire more events and make more assertions, and this must behave exactly as it does in a runtime situation under <code>⎕DQ</code>. But firing a single event can stack up multiple events, and these will not fire in real time during the execution of the test function. This is because when the test function runs, there is no opportunity for queued up callbacks to execute. When the interpreter drops into immediate execution mode, then the queued up events can be processed by the session's implicit <code>⎕DQ</code>. We have the strange situation where an assertion fails and the test stops, and then the assertion can be re-executed and it passes, as the very fact of failure has allowed the interpreter to pause and process the queued up events. How then is this problem solved? We must have a way of giving the interpreter an opportunity on every line of the test function, or at least on every line that fires an event, to process all of the events that may occur as a result of the primary event that was fired.</p>
        <p>The magic that does this is:</p>
        <pre><code>Fire←{
     _←⎕NQ ⍵
     0⊣{⎕DQ ⍵⊣⎕NQ ⍵ 999}¨⍺.DequeueTimes⍴⍺ 
 }  
</code></pre>
        <p><code>⍺</code> is the primary form.    </p>
        <p>We fire the primary event with <code>⎕NQ</code>. We then enter and exit an explict <code>⎕DQ</code> as many times as necessary to process the queued up events right on the spot. The <code>⎕NQ</code> fires a 999 event which is set to exit <code>⎕DQ</code>.  It is not always clear    how many times we must enter and exit <code>⎕DQ</code> to clear the queue. And of course it is different for different primary events. Luckily it appears we can set it to an arbitrarily high number, say 10, with no performance penalty.</p>
        <p>The sample GUI app in Provanto contains an example of explicitly using <code>⎕NQ</code> in callbacks to create a chain of 7 events. It can be observed that we must enter and exit <code>⎕DQ</code> exactly 7 times to process all the events. In a real-life large GUI application the magic number appeared to be 4. </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/testing-guis">Testing GUIs</a>
          </h1>
          <h2>August 14, 2023</h2>
        </header>
        <p>I'm currently in the process of extracting a GUI testing framework from a private project  and adding it to <a href="https://github.com/the-carlisle-group/provanto">Provanto</a>.  Writing automated GUI tests for <code>⎕WC</code> applications is somewhat of a dark art. Nowhere is the principle of Test Driven Development (TDD) more important than with GUI programming and <code>⎕WC</code>. Writing GUI code without forethought will invariably yield code that is simply untestable. Of course we don't have forethought until we have written a bunch of GUI code first, and then attempted to write test code,  so we are generally doomed to have untestable GUI code that must be rewritten.</p>
        <p>Future posts will explore the underlying framework code in detail. Here we just take a look at the overall basics, what a test function looks like, and how to write one. Once the dark art is mastered and buried in the framework, and we learn how to write testable GUI apps, the tests themselves are clean, neat, and simple to write, read, and maintain.</p>
        <p>Testing a GUI starts with a reference to the primary form object of an application. The <code>Init</code> function takes this form, instantiates a few properties in it, and then injects a few functions back into the test namespace:</p>
        <pre><code>Init←{
     ⍵.on999←1
     ⍵.DequeueTimes←4
     ⍵.ActionDelay←0
     ⍵.KeyPressDelay←0
     t←⊃⎕RSI
     t.Keys←KeySpace 0
     t.G←⎕THIS
     _←⍵ Fix¨API 0
     0
 }
</code></pre>
        <p>In addition to <code>Assert</code> and <code>Try</code> (the functions that Provanto injects into the test space), we now will have two more reserved words: <code>Enter</code> and <code>Get</code>. Both of these functions are bound with the reference to the form, so it is not needed as an argument.</p>
        <p>The <code>Init</code> function may be called in the <code>Startup</code> function for a suite of tests, or  directly in a test function.  </p>
        <p>Provanto includes a sample GUI application and a few tests to show how it is done. A typical GUI test fires events on objects, then inspects the state of the GUI and the application and makes assertions. Let's take a look at one:</p>
        <pre><code>TestAllowDigitsProperty←{
     s←GetAppState 0
     e←Get'Name'
     Assert~s.AllowDigits:
     Enter'Name' 'A12B345C':
     Assert e.Text≡'ABC':
     Enter'AllowDigits':
     Assert s.AllowDigits:
     Enter'Name' '12345':
     Assert e.Text≡'ABC12345':
     Enter'AllowDigits':
     Assert~s.AllowDigits:
     0
 }
</code></pre>
        <p>This function assumes that <code>Init</code> has already been called. <code>GetAppState</code> is an application specific helper function that returns a namespace with a few variables representing the state of the application.  Of course in a real application, the application state may be represented by a complex object model, or a folder on disk, or both and more. </p>
        <p>The <code>Get</code> function takes the name of a GUI object and returns a reference to it, providing access to the state of the GUI.</p>
        <p>The <code>Enter</code> function allows us to fire events at the GUI.  To click on a push button or menu item, or to change the state of a radio button or check box, we simply call the <code>Enter</code> function with the name of the object. To enter text in an edit box, we call <code>Enter</code> with both the name of the object and the text to enter.</p>
        <p>We can also fire specific events. For example, to double click on the <code>Name</code> edit object:</p>
        <pre><code>Enter 'Name' (⊂'MouseDblClick')
</code></pre>
        <p>A full event message may be provided as well:</p>
        <pre><code>Enter 'Name' ('KeyPress' 'RC' 0 39 0) 
</code></pre>
        <p><code>KeyPress</code> events are very common, so a namespace with <code>KeyPress</code> events is provided, to make it easy to fire specific keys on objects:</p>
        <pre><code>Enter 'Name' Keys.RightCursor  
</code></pre>
        <p>The above test is implement as a dfn, and thus naked guards are necessary to prevent the function from exiting on the lines that lack an assignment, specifically the lines calling <code>Enter</code>. We could of course assign a useless result instead, but it adds a lot of clutter. The naked guard is already used on the lines making assertions, so it's not that much of stretch, but some might find it objectionable. I'm not entirely sure how I feel about it. A trad function works just as well, arguably cleaner if there are not too many local variables:</p>
        <pre><code> z←TestAllowDigitsProperty x;s;e
 s←GetAppState 0
 e←Get'Name'
 Assert~s.AllowDigits
 Enter'Name' 'A12B345C'
 Assert e.Text≡'ABC'
 Enter'AllowDigits'
 Assert s.AllowDigits
 Enter'Name' '12345'
 Assert e.Text≡'ABC12345'
 Enter'AllowDigits'
 Assert~s.AllowDigits
 z←0 
</code></pre>
        <p>The main point is that both of these functions, the dfn and trad fn, have little to no extraneous code. The functions are easy to write and read. The two API functions <code>Enter</code> and <code>Get</code> provide almost all that is needed. The test functions are also easy to trace, and you can see exactly what the GUI is doing while stepping through them.</p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2023 Paul S. Mansour</p>
    </footer>
  </body>
</html>
