<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/modal-dialog-boxes-confirm">Modal Dialog Boxes
            2: Confirm</a>
          </h1>
          <h2>April 30, 2024</h2>
        </header>
        <p>The Abacus <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/ConfirmBox">ConfirmBox</a>  component displays a message and one or more buttons, allowing the user to make a choice and for the programmer to control the flow  of execution of an APL function. To implement this, on the server-side APL, Abacus must be able to wait in a suspended function, while over in the client browser, the user is pondering a modal dialog box with multiple choices. When the user makes a choice, the suspended APL function must be notified of the choice and allowed to continue execution.</p>
        <p>Let's look at some code:</p>
        <pre><code>Show←{
     ⍺ ##.ShowModalAndWait New ⍵
 }
 
 ShowModalAndWait←{
     ⍝ ⍺ ←→ Document
     ⍝ ⍵ ←→ dialog element
     b←GetBody ⍺
     _←⍺ SetDefaultId Elements ⍵
     _←b AppendChild ⍵
     _←⍵ ExecuteOnElement'showModal()'
     ⊃⎕TGET ⎕TID
 }
  New←{
     ⍝ ⍵ ←→ Title Caption [Options]
     ⍝ ← ←→ new dialog element
     t c o←3↑⍵,⊂'Yes' 'No'
     d←A.New'dialog'
     d.class←'confirm-box'
     d.Onclose←A.FQP'OnClose'
     d.Unqueued←1
     d.Tid←⎕TID
     h1←d A.New'h1't
     p←d A.New'p'c
     m←d A.New'menu'
     b←m A.New¨{'button'⍵}¨o
     b.Name←o
     b.Onclick←⊂A.FQP'OnSelect'
     b.Unqueued←1
     d
 }    
 
OnSelect←{
     d←⍵.CurrentTarget ##.GetNearest'dialog'
     _←##.DeleteElement d
     v←⍵.CurrentTarget.Name
     0⊣v ⎕TPUT d.Tid
 }
</code></pre>
        <p>The <code>New</code> function takes a title, caption, and optional list of one or more  button captions, which defaults to <code>Yes</code> and <code>No</code>. The thread ID is noted in the dialog element. This will be used as a token when the user clicks on one of the choices. The button elements are flagged as being <em>Unqueued</em> (as is the parent dialog, which  has an onclose event handler). This is critical. Normally browser events are handled serially  on the APL server side. If <code>Unqueued</code> is not to set to <code>1</code>, then the <code>OnSelect</code> (and <code>OnClose</code>) handler will wait until the handler function that called <code>ShowModalAndWait</code> is complete, which is waiting for token from <code>OnSelect</code>, which is waiting for... well you get the idea, and it's not good. Setting <code>Unqueued</code> to <code>1</code> tells Abacus to execute the APL event handler immediately. This allows it to put the token into the pool that satisfies the <code>⎕TGET</code> in <code>ShowModalAndWait</code>. The token value, the name or caption of the button, is returned by <code>ShowModalAndWait</code>.</p>
        <p>Note the advantage of having an APL DOM that can store all kinds of useful info like  <code>Tid</code>, <code>Unqueued</code>, and <code>Name</code> - none of which are in the browser DOM.   </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/modal-dialog-boxes-1">Modal Dialog Boxes 1:
            Alert</a>
          </h1>
          <h2>April 29, 2024</h2>
        </header>
        <p>JavaScript provides at least three methods for small, utility, modal dialog boxes: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/alert">alert</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm">confirm</a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt">prompt</a>.</p>
        <p>While handy, these methods have limitations. At a minimum we want to be able to style these dialog boxes, and that cannot be done as they are implemented by the underlying operating system. More importantly, we need additional behaviors. For example, the <code>confirm</code> method provides two buttons, <em>Yes</em> and <em>No</em>, and we may want different labels or more than two choices. In addition, we may want to be able to pause an APL function mid execution, server-side, waiting for the response to a set of choices from the user.</p>
        <p>Abacus thus provides 3 analogous components: <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/AlertBox">AlertBox</a>, <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/ConfirmBox">ConfirmBox</a>, and <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/PromptBox">PromptBox</a>. These are all built with the native HTML <code>&lt;dialog&gt;</code> element. All three of these components are modal from the perspective of the user - that is, the use cannot access any other part of the page or app until the dialog box is closed. However, from the programmer's perspective, they behave very differently.</p>
        <p>The simplest is the <code>AlertBox</code> component. It provides a message to the user in a modal dialog that may dismissed by pressing the <code>OK</code> button or the <code>Esc</code> key. </p>
        <blockquote>
          <p>Abacus components are not formally classes, just a few functions in a namespace, inlcuding <code>New</code> to create a new instance and <code>CSS</code> to define the styling. Depending on the component, additional functions like <code>Show</code>, <code>Run</code>, or <code>Init</code> may be defined.</p>
        </blockquote>
        <p>The AlertBox is called using its <code>Show</code> method:</p>
        <pre><code>      d A.AlertBox.Show 'Hello world!'
</code></pre>
        <p>The important thing to note about this is that your code does not wait here. The alert box is displayed, and the calling APL function keeps on running. So you cannot use alerts as a debugging tool to pause and display state, as you might have done with <code>MsgBox</code> using <code>⎕WC</code>. The behavior of <code>AlertBox</code> is in contrast to, as we shall see in the next post, the way the <code>ConfirmBox</code> component behaves. It would be easy enough to make the alert box modal with a capital M and to wait in the APL code for the user to click <code>OK</code>. However, as far as I can tell, there is no real use case for this, other than perhaps debugging, for which we already have much better tools. Furthermore, the confirm box with a single button works this way, so it can be used to pause and display state if necessary.</p>
        <p>The left argument <code>Show</code> is the application document, the right argument is the message to display. The <code>Show</code> method calls the <code>New</code> method to construct the component, and then the <code>ShowModal</code> function to insert it into the document and to display it:</p>
        <pre><code>Show←{
     ⍺ A.ShowModal New ⍵
 }
New←{
     ⍝ ⍵ ←→ Message
     ⍝ ← ←→ New dialog element
     m←⍵
     A←##
     d←A.New'dialog'
     d.class←'alert-box'
     p←d A.New'p'm
     b←d A.New'button' 'OK'
     b.Onclick←A.FQP'OnOK'
     d.Onclose←A.FQP'OnOK'
     d
 }
ShowModal←{
     ⍝ ⍺ ←→ Document
     ⍝ ⍵ ←→ dialog element
     b←GetBody ⍺
     _←⍺ SetDefaultId Elements ⍵
     _←b AppendChild ⍵
     ⍵ ExecuteOnElement'showModal()'
 }
</code></pre>
        <p>In Abacus, dialog boxes are created and disposed of every time they are called on to appear. So, for the alert box, we use the same callback for the click event and the close event, which deletes the component from the DOM:</p>
        <pre><code>OnOK←{
     d←⍵.CurrentTarget ##.GetNearest'dialog'
     ##.DeleteElement d
 }
</code></pre>
        <p>The alert box is a simple component. It has no knowledge of the state of the server, or the client for that matter. It puts a message on the screen and forces the user to acknowledge it for continuing to use the app. </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/abacus-threading-model">The Abacus Threading
            Model</a>
          </h1>
          <h2>April 28, 2024</h2>
        </header>
        <p>Way back in September 2022 we looked  at <a href="/posts/threading-the-htmlrenderer">threading the HTMLRenderer</a>. A few changes have happened since then including some additional requirements around modal dialogs, progress bars, and confirmation boxes. Let's take a look.</p>
        <p>To review, Abacus uses websockets for two-way asynchronous communication between the browser (whether the <code>HTMLRenderer</code> or a remote, independent client browser) and an APL session.</p>
        <p>There are four different types of client-server interaction that must be considered.  </p>
        <p>The first two types of interaction originate on the client side, from the user taking action in the browser. These interactions are asynchronous - the client sends a message to the server and goes on its merry way. The server may send back 0 or more messages at some point.</p>
        <p>The 1st interaction type is the normal case of handling basic user actions like clicking a button, entering text in an input field or scrolling though a datagrid. These messages are <strong>threaded and queued</strong>. Each message executes an APL handler function in its own thread, but each thread must wait for the previous thread to complete before it starts. This queue is managed by <code>⎕TSYNC</code>. Why are these messages threaded only to be queued and run sequentially?  Because we always want the websocket messages to be handled immediately (thus the threading), but in the normal case we want user generated events handled in order (thus the queue). The APL handler function will in this case almost always send some HTML back to the browser.</p>
        <p>Note that these threaded-and-queued messages can, if they need to, kick off long-running processes in yet another thread and report back immediately to the client, and avoid tying up the server.</p>
        <blockquote>
          <p>There is at least one other technique for handling threaded and queued messages. There is no reason that we need a new thread for each message. Messages must be dispatched in a thread other than 0, but since they are queued they do not need to be in different threads from each other. Thus, when the app starts, we could create one permanent thread with <code>⎕TGET</code> in a loop, and have the main thread chuck messages into it using <code>⎕TPUT</code>. You would think this might be more efficient than creating a new short-lived thread for every single message. But you might be wrong.</p>
        </blockquote>
        <p>The 2nd interaction type is the case of handling user actions that control or modify a previous user action. Consider a confirmation dialog box. This is Modal with a capital M - that is a function executing in APL is paused on a particular line, waiting for the user in the browser to take some action, like <em>Continue</em> or <em>Cancel</em>. This message cannot wait for the previous request to finish, because the previous request is asking the user if he wants to continue or cancel the previous request. Therefore it must execute immediately and without delay on the server. Or consider a progress bar dialog that must let the server  know that the process kicked off by the previous message should be canceled or paused. This too cannot wait for the previous message to complete. These messages are <strong>unthreaded and unqueued</strong>. These messages generally do not send any HTML back to the client - that is done by the message they are modifying.  </p>
        <blockquote>
          <p>There are also modal dialog boxes with a lower case m. These are modal only in the sense that the user cannot interact with the rest of the page until the modal is dismissed. There is no pendant or waiting APL function over on the server. Generally modal dialogs should be avoided, and Modal dialogs with a capital M avoided even more, but they both have their proper place, and it is important that we can create them and have automated tests that exercise them.</p>
        </blockquote>
        <p>The 3rd and 4th types of interaction originate on the server and simulate synchronous behavior. That is, a function on the server sends a message to the client and waits, using <code>⎕TGET</code>, for a response. Both of these types are generally used only for automated testing. There is generally no reason for an application to need this functionality in the normal course.    </p>
        <p>The 3rd type is the case of handling synchronous JavaScript. The server sends a JavaScript snippet to the client for execution and waits for a response. The server will send the <code>TID</code> with the request as an identifier, and the client will send it back. This allows the server to use <code>⎕TGET</code> and <code>⎕TPUT</code> to implement synchronous behavior. The prime use of synchronous JavaScript requests is testing: the server needs to get the <code>innerHTML</code> of some element to inspect the state of the client. The result message from the client is not threaded or queued, and requires no real processing of any sort; it is simply chucked to the waiting server thread using <code>⎕TPUT</code>.</p>
        <p>The 4th type of interaction is the server firing an event on the client, which in turn is handled by the server. When a function on the server sends an event to be fired back on the client, it must wait (in a thread, so as not to block) for the client to send a request back, and for that request to complete. Then, and only then, can the server function inspect the state  of the server and/or the client to make sure the intended thing actually happened.  When the server handles the message that the server has asked the client to send, it handles it just as if the user initiated the event, with the exception that when the task completes, the thread handling the task must notify the waiting thread of completion.  Again, this is generally only used for automated testing.</p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2024 Paul S. Mansour</p>
    </footer>
  </body>
</html>
