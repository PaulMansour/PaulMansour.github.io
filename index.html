<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/modal-dialog-boxes-prompt">Modal Dialog Boxes
            3: Prompt</a>
          </h1>
          <h2>May 6, 2024</h2>
        </header>
        <p>The Abacus <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/PromptBox">PromptBox</a>  component allows the user to enter a string, and then select <code>OK</code> or <code>Cancel</code>. This dialog behaves like the  <code>AlertBox</code> dialog as opposed to the <code>ConfirmBox</code> dialog; it does not suspend or wait. It takes action via a handler function attached to the <code>OK</code> button. Let's go to the code:</p>
        <pre><code>Show←{
     ⍺ ##.ShowModal New ⍵
 }
  New←{
     ⍝ ⍵ ←→ Title, Label, Value, OKHandler
     ⍝ ← ←→ new dialog element
     tv lv iv cb←⍵
     d←A.New'dialog'
     d.class←'prompt-box'
     d.OnOK←cb
     h1←d A.New'h1'tv
     l←d A.New'label'lv
     i←d A.New'input'
     i.id←'Prompt'
     i.value←iv
     i.Oninput←A.FQP'OnInput'
     m←d A.New'menu'
     b←m A.New¨{'button'⍵}¨'OK' 'Cancel'
     b.id←'OK' 'Cancel'
     b.Onclick←A.FQP¨'OnOK' 'OnCancel'
     d
 }
 OnInput←{
     i←⍵.CurrentTarget
     i.value←⍵.Value
     0
 }
 OnOK←{
     t←⍵.CurrentTarget
     d←t A.GetNearest'dialog'
     i←d A.ElementByTag'input'
     v←i.value
     f←⍎d.OnOK
     r←⍵.Document f v
     r:0
     A.DeleteElement d
 }
 OnCancel←{
     d←⍵.CurrentTarget A.GetNearest'dialog'
     ##.DeleteElement d
 }
</code></pre>
        <p>The <code>OnOK</code> function covers the handler supplied as an argument to <code>Show</code>. If the supplied handler returns  a <code>0</code>, it is considered a success, and the prompt box is deleted. If it returns a <code>1</code>, it is considered a failure and the prompt box is left up for the user to interact with.</p>
        <p>The prompt box functionality could be implemented to wait and suspend the calling APL function, just like we do with <code>ConfirmBox</code>, but there is generally no need to maintain state, and suspending the calling function is more complex and makes testing more difficult. The same is true for more general dialog boxes, with many more controls. It is better to have callback or handler functions to take action rather than inspecting the result of a <code>Show</code> function to see what action to take.  </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/modal-dialog-boxes-confirm">Modal Dialog Boxes
            2: Confirm</a>
          </h1>
          <h2>April 30, 2024</h2>
        </header>
        <p>The Abacus <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/ConfirmBox">ConfirmBox</a>  component displays a message and one or more buttons, allowing the user to make a choice and for the programmer to control the flow  of execution of an APL function. To implement this, on the server-side APL, Abacus must be able to wait in a suspended function, while over in the client browser, the user is pondering a modal dialog box with multiple choices. When the user makes a choice, the suspended APL function must be notified of the choice and allowed to continue execution.</p>
        <p>Let's look at some code:</p>
        <pre><code>Show←{
     ⍺ ##.ShowModalAndWait New ⍵
 }
 
 ShowModalAndWait←{
     ⍝ ⍺ ←→ Document
     ⍝ ⍵ ←→ dialog element
     b←GetBody ⍺
     _←⍺ SetDefaultId Elements ⍵
     _←b AppendChild ⍵
     _←⍵ ExecuteOnElement'showModal()'
     ⊃⎕TGET ⎕TID
 }
  New←{
     ⍝ ⍵ ←→ Title Caption [Options]
     ⍝ ← ←→ new dialog element
     t c o←3↑⍵,⊂'Yes' 'No'
     d←A.New'dialog'
     d.class←'confirm-box'
     d.Onclose←A.FQP'OnClose'
     d.Unqueued←1
     d.Tid←⎕TID
     h1←d A.New'h1't
     p←d A.New'p'c
     m←d A.New'menu'
     b←m A.New¨{'button'⍵}¨o
     b.Name←o
     b.Onclick←⊂A.FQP'OnSelect'
     b.Unqueued←1
     d
 }    
 
OnSelect←{
     d←⍵.CurrentTarget ##.GetNearest'dialog'
     _←##.DeleteElement d
     v←⍵.CurrentTarget.Name
     0⊣v ⎕TPUT d.Tid
 }
</code></pre>
        <p>The <code>New</code> function takes a title, caption, and optional list of one or more  button captions, which defaults to <code>Yes</code> and <code>No</code>. The thread ID is noted in the dialog element. This will be used as a token when the user clicks on one of the choices. The button elements are flagged as being <em>Unqueued</em> (as is the parent dialog, which  has an onclose event handler). This is critical. Normally browser events are handled serially  on the APL server side. If <code>Unqueued</code> is not to set to <code>1</code>, then the <code>OnSelect</code> (and <code>OnClose</code>) handler will wait until the handler function that called <code>ShowModalAndWait</code> is complete, which is waiting for token from <code>OnSelect</code>, which is waiting for... well you get the idea, and it's not good. Setting <code>Unqueued</code> to <code>1</code> tells Abacus to execute the APL event handler immediately. This allows it to put the token into the pool that satisfies the <code>⎕TGET</code> in <code>ShowModalAndWait</code>. The token value, the name or caption of the button, is returned by <code>ShowModalAndWait</code>.</p>
        <p>Note the advantage of having an APL DOM that can store all kinds of useful info like  <code>Tid</code>, <code>Unqueued</code>, and <code>Name</code> - none of which are in the browser DOM.   </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/modal-dialog-boxes-1">Modal Dialog Boxes 1:
            Alert</a>
          </h1>
          <h2>April 29, 2024</h2>
        </header>
        <p>JavaScript provides at least three methods for small, utility, modal dialog boxes: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/alert">alert</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm">confirm</a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt">prompt</a>.</p>
        <p>While handy, these methods have limitations. At a minimum we want to be able to style these dialog boxes, and that cannot be done as they are implemented by the underlying operating system. More importantly, we need additional behaviors. For example, the <code>confirm</code> method provides two buttons, <em>Yes</em> and <em>No</em>, and we may want different labels or more than two choices. In addition, we may want to be able to pause an APL function mid execution, server-side, waiting for the response to a set of choices from the user.</p>
        <p>Abacus thus provides 3 analogous components: <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/AlertBox">AlertBox</a>, <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/ConfirmBox">ConfirmBox</a>, and <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/PromptBox">PromptBox</a>. These are all built with the native HTML <code>&lt;dialog&gt;</code> element. All three of these components are modal from the perspective of the user - that is, the use cannot access any other part of the page or app until the dialog box is closed. However, from the programmer's perspective, they behave very differently.</p>
        <p>The simplest is the <code>AlertBox</code> component. It provides a message to the user in a modal dialog that may dismissed by pressing the <code>OK</code> button or the <code>Esc</code> key. </p>
        <blockquote>
          <p>Abacus components are not formally classes, just a few functions in a namespace, inlcuding <code>New</code> to create a new instance and <code>CSS</code> to define the styling. Depending on the component, additional functions like <code>Show</code>, <code>Run</code>, or <code>Init</code> may be defined.</p>
        </blockquote>
        <p>The AlertBox is called using its <code>Show</code> method:</p>
        <pre><code>      d A.AlertBox.Show 'Hello world!'
</code></pre>
        <p>The important thing to note about this is that your code does not wait here. The alert box is displayed, and the calling APL function keeps on running. So you cannot use alerts as a debugging tool to pause and display state, as you might have done with <code>MsgBox</code> using <code>⎕WC</code>. The behavior of <code>AlertBox</code> is in contrast to, as we shall see in the next post, the way the <code>ConfirmBox</code> component behaves. It would be easy enough to make the alert box modal with a capital M and to wait in the APL code for the user to click <code>OK</code>. However, as far as I can tell, there is no real use case for this, other than perhaps debugging, for which we already have much better tools. Furthermore, the confirm box with a single button works this way, so it can be used to pause and display state if necessary.</p>
        <p>The left argument <code>Show</code> is the application document, the right argument is the message to display. The <code>Show</code> method calls the <code>New</code> method to construct the component, and then the <code>ShowModal</code> function to insert it into the document and to display it:</p>
        <pre><code>Show←{
     ⍺ A.ShowModal New ⍵
 }
New←{
     ⍝ ⍵ ←→ Message
     ⍝ ← ←→ New dialog element
     m←⍵
     A←##
     d←A.New'dialog'
     d.class←'alert-box'
     p←d A.New'p'm
     b←d A.New'button' 'OK'
     b.Onclick←A.FQP'OnOK'
     d.Onclose←A.FQP'OnOK'
     d
 }
ShowModal←{
     ⍝ ⍺ ←→ Document
     ⍝ ⍵ ←→ dialog element
     b←GetBody ⍺
     _←⍺ SetDefaultId Elements ⍵
     _←b AppendChild ⍵
     ⍵ ExecuteOnElement'showModal()'
 }
</code></pre>
        <p>In Abacus, dialog boxes are created and disposed of every time they are called on to appear. So, for the alert box, we use the same callback for the click event and the close event, which deletes the component from the DOM:</p>
        <pre><code>OnOK←{
     d←⍵.CurrentTarget ##.GetNearest'dialog'
     ##.DeleteElement d
 }
</code></pre>
        <p>The alert box is a simple component. It has no knowledge of the state of the server, or the client for that matter. It puts a message on the screen and forces the user to acknowledge it for continuing to use the app. </p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2024 Paul S. Mansour</p>
    </footer>
  </body>
</html>
