<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/text-to-date">Converting Text to Date</a>
          </h1>
          <h2>January 23, 2023</h2>
        </header>
        <p>Problem #6 from <a href="https://www.dyalog.com/uploads/files/student_competition/2022_problems_phase2.pdf">Phase 2 of the Dyalog 2020 APL Problem Solving Comptetition</a> is titled <strong><em>Its a Date!</em></strong> The task was to write a function <code>DDN</code> which basically does the inverse of the date format function <code>1200⌶</code>. </p>
        <p>Apparently the problem as specified was quite difficult, and no complete or even nearly complete solutions were submitted.</p>
        <p>This being the <strong>APL for the Practical Man</strong> blog, we are interested in how the problem  should be framed to make the solution useful in a commercial application. And of course the general problem is encountered all the time. Dates are common data elements. Data are in files. Files are often text. So here we propose a function <code>Text2Date</code>, to compare and contrast with <code>DDN</code>.</p>
        <p>First and foremost, in the original specification, the function <code>DDN</code> is expected to operate on a single string  or character vector, converting one string to one date, one at a time. But it will not do to use the <code>each</code> operator on millions of dates.  <code>Text2Date</code> must operate on a character matrix where each row represents a date. This has the extra benefit of making the problem more array oriented - an issue that was noted  in the <a href="https://dyalog.tv/Dyalog22/?v=018ZUHrFSM8">presentation of the contest winners</a> at the recent conference in Portugal. </p>
        <p>Second, <code>DDN</code> is expected to handle strings that do not produce a unique Dyalog Date Number, like <code>'07'</code>, <code>'Thursday'</code>, and  <code>'Feb 29th'</code>, all potential outputs from <code>1200⌶</code>. This adds complexilty but provides little to no value. We can only elide consecutive trailing elements in <code>⎕TS</code>, which default to <code>1</code> or <code>0</code> as appropriate, and no one would reasonably expect otherwise:</p>
        <pre><code>       ¯1 1 ⎕DT⊂,2022 
44561
       ¯1 1 ⎕DT⊂2022 28 
DOMAIN ERROR: Invalid date-time
      ¯1 1 ⎕DT⊂2022 28
           ∧
      ¯1 1 ⎕DT⊂2022 ⍬ 28
DOMAIN ERROR: Invalid date-time
      ¯1 1 ⎕DT⊂2022 ⍬ 28
           ∧
      ¯1 1 ⎕DT⊂2022 0 28
DOMAIN ERROR: Invalid date-time
      ¯1 1 ⎕DT⊂2022 0 28
           ∧
</code></pre>
        <p>Thus <code>Text2Date</code> should only be required to handle strings that produce a unique Dyalog Date Number, with the exception that 2 digit years are resolved using a fixed or sliding century window, which  may be provided as an optional argument.</p>
        <p>Third, the spec for <code>DDN</code> states that:</p>
        <blockquote>
          <p>No variable length numeric fields will be placed immediately next to another numeric field.</p>
        </blockquote>
        <p>For example, <code>MDDYY</code>, <code>YYMD</code> and <code>MDY</code> would be disallowed. This is almost, but not quite, saying that variable length formats must be delimited. It allows, for example, <code>MMYY-D</code>. This constraint is both too restrictive and not restrictive enough.  Leading variable length elements should be allowed immediatly adjacent to a fixed element, but otherwise the elements in a variable length format must be strictly delimited.  Thus <code>Text2Date</code> should properly handle the string <code>'DMMYY'</code>, but should not handle <code>'YYMM-D'</code>.  The reason for the former is that undelimited dates in text files are often missing a leading zero due to type conversions somewhere upstream. The reason for the latter is that allowing  delimited variable length elements in the same format with undelimited fixed width elements  adds much complexity for very little if any practical gain. </p>
        <p>If we combine the restriction that any variable length format must be fully delimited, with the further <code>DDN</code> restriction that:</p>
        <blockquote>
          <p>the only alphanumeric characters will be formatted elements of the date/time</p>
        </blockquote>
        <p>then specifying a variable length format becomes merely a matter of specifying the order in which the elements occur. That is, there is no need to specify '<code>M-YY-D</code>' when simply <code>MYD</code> will do. The string must contain three separated numbers (leaving aside months as text like Jan, Feb, etc.). The particular separator or length of separator is immaterial. </p>
        <p>This brings up the question of whether the format specifier for <code>1200⌶</code> is really the best unformat specifier. Is a true inverse really what we need? Certainly they are related, but in a real application we would probably want <code>'12/31/2022'</code>, <code>'1-1-2023'</code>, and <code>'7/4/21'</code> to all convert properly with the same format string.</p>
        <p>Thus there are at least two issues that make to-and-from text fundamentally different from all the other date formats.  <code>1200⌶</code> will create "invalid" dates, that is, strings that cannot be converted back to a unique Dyalog Date Number. And conversely, there are multiple strings that could only be created using multiple formats, but that should all convert back to a Dyalog Date Number using a single format. This may be an argument to keep <code>1200⌶</code> out of <code>⎕DT</code>.</p>
        <p>A further complication is handling bad data. To be useful, <code>Text2Date</code> must not fail when it cannot yield a valid Dyalog Data Number for a string. There are then only two options: return a value that indicates failure, or take the route of <code>⎕VFI</code>, and return a Boolean mask indicating valid results. A zero might be useful for a failure value. If not, a zero is perfect for a fill value, with the Boolean mask indicating valid results, just like <code>⎕VFI</code>.  If <code>1200⌶</code> is folded in to <code>⎕DT</code>, perhaps a variant could be added that changes the result to a <code>⎕VFI</code> style result. This might be useful for numeric-to-numeric conversions as well.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/an-issue-with-xml-revisited">An Issue With
            ⎕XML Revisited</a>
          </h1>
          <h2>January 9, 2023</h2>
        </header>
        <p>In a <a href="/posts/two-issues-with-xml">previous post</a> I looked at a couple of issues with <code>⎕XML</code>. One issue was formatting when converting to XML: I wanted indentation and removal of whitespace for most elements, but not all. I dont know how I missed it, but there is a way to do this built into the XML spec and <code>⎕XML</code> supports it. Simply add a special attribute to the elements in question. It's right there <a href="https://help.dyalog.com/latest/index.htm#Language/System%20Functions/xml.htm">in the docs</a>:</p>
        <pre><code>xml:space="preserve"
</code></pre>
        <p>Thus, if the overall variant is <code>'Whitespace' 'Strip'</code>, individual elements will preserve whitespace with this attribute specified.</p>
        <p>This is more than cosmetic given the differences between XML and HTML. A paragraph with in-line markup, like bold, code, etc., must have whitespace preserved when generated using <code>⎕XML</code> otherwise an additional space will be added due to the formatting. Of course <code>pre</code> elements should also have whitespace preserved. So far I apply <code>xml:space="preserve"</code> to the <code>p</code>, <code>pre</code>, and <code>tr</code> elements. The latter formats tables nicely, with each row on its own line.</p>
        <p>Unfortunately the generated XML has <code>xml:space="preserve"</code> littered throughout the character vector which provides no use, and increases the size of the array. Oddly enough, I don't think I have ever written code to remove all the occurrences of a given substring from a string - or at least I can't remember doing it. It seems like it would be a very common task. Let's do it without using regular expressions.</p>
        <p>First, let's find the substrings, easy with the <a href="https://help.dyalog.com/latest/index.htm#Language/Primitive%20Functions/Find.htm">find</a> primitive. This marks the beginning of each substring <code>⍺</code> in the target string <code>⍵</code>:</p>
        <pre><code>     'ere'{⍺⍷⍵}'here there where'
0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0
</code></pre>
        <p>Next lets extend each 1 by the length of the substring, using n-wise or-reduction, fully marking each found substring:</p>
        <pre><code>      'ere'{(≢⍺)∨/⍺⍷⍵}'here there where'
1 1 0 0 0 1 1 1 0 0 0 1 1 1
</code></pre>
        <p>Two related problems arise. First, as always with n-wise reduction, the result is shorter than the right argument. Second, when a substring is found at or near the beginning of the string, we don't get enough 1s. We can fix this by appending the substring to the  target string before searching:</p>
        <pre><code>      'ere'{(≢⍺)∨/⍺⍷⍺,⍵}'here there where'
1 0 1 1 1 0 0 0 1 1 1 0 0 0 1 1 1
</code></pre>
        <p>Note that it is merely a convenience to append the substring itself, as it is, by definition, the proper length. We could also append an appropriate number of zeros to the result of <code>find</code> before applying the reduction. </p>
        <p>Now we have only one problem: the Boolean mask is too long, by 1. So we drop off the first element:</p>
        <pre><code>      'ere'{1↓(≢⍺)∨/⍺⍷⍺,⍵}'here there where'
0 1 1 1 0 0 0 1 1 1 0 0 0 1 1 1
</code></pre>
        <p>The Boolean mask flags what we want to remove, not what we want to keep, so we negate it, flipping 1s to 0s and vice versa: </p>
        <pre><code>      'ere'{~1↓(≢⍺)∨/⍺⍷⍺,⍵}'here there where'
1 0 0 0 1 1 1 0 0 0 1 1 1 0 0 0
</code></pre>
        <p>Finally, we apply <a href="https://help.dyalog.com/latest/index.htm#Language/Primitive%20Functions/Replicate.htm">compress or replicate</a>, with <a href="https://help.dyalog.com/latest/index.htm#Language/Primitive%20Operators/Commute.htm">commute</a> to avoid parentheses, to keep everything but the substrings:</p>
        <pre><code>      'ere'{⍵/⍨~1↓(≢⍺)∨/⍺⍷⍺,⍵}'here there where'
h th wh
</code></pre>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/anatomy-of-a-query-iii">Anatomy of a Query,
            Part 3</a>
          </h1>
          <h2>December 27, 2022</h2>
        </header>
        <p>In the second part of this series, <a href="/posts/anatomy-of-a-query-ii">Anatomy of a Query, Part 2</a>, we covered how columns from multiple tables are accessed in a single query. Unlike SQL, which requires joins at the table level, in FlipDB we can join data on a column-by-column basis, keeping our ability to trace FlipDB queries step-by-step, one name and one value at a time. In addition, this means pure APL solutions translate directly into FlipDB. The examples focused on column join syntax that generally requires a database with pre-specified foreign keys. In much ad hoc, real-world analysis, we have no such luxury; there is simply data, in a bunch of tables.</p>
        <p>There is one join syntax that does allow for complete generality, with no pre-specified keys, the <em>general join</em> syntax:</p>
        <pre><code>   T[X;Y].Z
</code></pre>
        <p>Where, where given the context of some starting table (let's call it <code>S</code>), then <code>T</code> is the name of some other table in the same database, X is one or more column names in S, defining the key in S, and Y is one or more column names in T, defining the the key in T.  X and Y must conform in number and in type. The names may be different. Y may be elided if the names are the same. Z is a column name in T. This syntax materializes column Z from table T in the table S, by doing the lookup specified by the keys. The result will be simple or partitioned depending on whether the runtime relationship is many-to-one or not.</p>
        <p>This is useful, but there are times when we may want to explicitly do look ups, to preserve the indices for further computation. FlipDB provides a <code>getColumn</code> function which will directly fetch a column from another table:</p>
        <pre><code>getColumn 'Table2.ColumnA'
</code></pre>
        <p>from another database:</p>
        <pre><code>getColumn 'Database2.Table2.ColumnA' 
</code></pre>
        <p>or from the same very same table, reaching out of the current context and getting the entire column:</p>
        <pre><code>getColumn 'ColumnA'
</code></pre>
        <p>Thus, in any query, at any point (in the where clause, the select clause, the having clause, etc.) an expression can just grab a column from anywhere. A column accessed this way is generally non-conforming; it's not going to line up with our starting table. This does not hinder its usefulness.  A typical use is simply to check if values exist in some list. For example, say in the Suppliers and Parts database we added a <code>Sanction</code> table that contains a list of cities that are sanctioned. In order to find existing suppliers in unsanctioned cities, starting in the Supplier table <code>S</code>, it's just simple APL:</p>
        <pre><code>not CITY in getColumn 'Sanction.CITY'
</code></pre>
        <p>Because FlipDB queries are just sets of names and expressions, the expression can do virtually anything. We can get an entire table using the <code>getTable</code> function. So starting in the supplier table <code>S</code>, we can materialize the parts table:</p>
        <pre><code>      getTable 'P'
── SandP.P ────────────────────────────────────────────
 ┌PNO────┐  ┌PNAME──┐  ┌COLOR──┐  ┌WEIGHT┐  ┌CITY────┐ 
 ↓P1     │  ↓Nut    │  ↓Red    │  ↓12    │  ↓London  │ 
 │P2     │  │Bolt   │  │Green  │  │17    │  │Paris   │ 
 │P3     │  │Screw  │  │Blue   │  │17    │  │Oslo    │ 
 │P4     │  │Screw  │  │Red    │  │14    │  │London  │ 
 │P5     │  │Cam    │  │Blue   │  │12    │  │Paris   │ 
 │P6     │  │Cog    │  │Red    │  │19    │  │London  │ 
 └Char(2)┘  └Char(5)┘  └Char(5)┘  └Int8──┘  └Char(10)┘ 
── 6 rows by 5 columns ────────────────────────────────
</code></pre>
        <p>The <code>transpose</code> function converts the table into a FlipDB <em>property space</em> (analogous  to a k dictionary): </p>
        <pre><code>      P=transpose D.GetTable 'P'
      P
┌PropertySpace───────────────┐
│ Name             Type      │
│ -------------    --------- │
│ TWID             Integer   │
│ APPENDTYPE       Integer   │
│ PNO              Char      │
│ AUTOKEY          Integer   │
│ PNAME            Char      │
│ COLOR            Char      │
│ WEIGHT           Integer   │
│ CITY             Char      │
│ TransDateTime    DateTime  │
└────────────────────────────┘
</code></pre>
        <p>which then provides convenient dot access to the columns:</p>
        <pre><code>     P.COLOR 
┌COLOR──┐
↓Red    │
│Green  │
│Blue   │
│Red    │
│Blue   │
│Red    │
└Char(5)┘
</code></pre>
        <p>We can use the  <code>indexOf</code> and <code>index</code> functions, both analagous to their APL counterparts, to conform columns from one table to another. Entire tables can be made to line up by using the <code>conform</code> function. The full power of APL techniques and solutions is directly available to us in the expressions.    </p>
        <p>Because FlipDB queries are sets of names and expressions, each set applied in a certain way and in certain  context, and expressions, by definition, can do anything the FlipDB language can do, it follows that  a query can do pretty much anything. For example a query can do operating system commands like creating a folder, read a file, or write to a log. These are things that would normally be done in scripts or stored procedures. A query becomes a highly structured script, executed in the  context of some table in some database.</p>
        <p>In our next and final part in this series, we will look at how FlipDB allows multiple queries to run as a set and how each query can refer to values in previously executed queries.</p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2023 Paul S. Mansour</p>
    </footer>
  </body>
</html>
