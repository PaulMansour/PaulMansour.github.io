<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/the-dom-via-json">The DOM via JSON</a>
          </h1>
          <h2>April 11, 2023</h2>
        </header>
        <p>In a <a href="/posts/a-document-object-model-in-apl">A Document Object Model in APL</a> the usefulness of  an APL DOM was discussed, and a function <code>HTML2DOM</code> demonstrated:</p>
        <pre><code>HTML2DOM←{
     ⍝ ⍵ ←→ HTML
     ⍝ ← ←→ DOM
     0=≢⍵:⍬
     {⍵⌷⍨⍳1=⍴⍵}0{
         m←⍵
         0=≢m:⍺
         b←m[;0]=0
         p←⍺{⍺ New 3↑1↓⍵}¨↓b⌿m
         m[;0]-←1
         p⊣p ∇¨1↓¨b⊂[0]m
     }⎕XML ⍵
 }    
</code></pre>
        <p>This function takes HTML and recursively works through the <code>⎕XML</code> matrix using the <code>New</code> function, building a tree of element namespaces. The <code>New</code> function is the same function used to build up a document from scratch. All of this code is in the <a href="https://github.com/th-carlisle-group/abacus">Abacus</a> project.</p>
        <p>In a recent discussion on <a href="https://chat.stackexchange.com/rooms/52405/the-apl-orchard">The APL Orchard</a>, it was noted that <code>⎕JSON</code> could be used to create a namespace tree from HTML. While it is no secret that <code>⎕JSON</code> creates a namespace tree from JSON (that's what it does!), it never occurred to me to use it for creating an HTML DOM. It seems it should be faster than doing it by "hand", but there is some additional overhead in going from HTML to JSON and then to a namespace tree. Let's see how to do it.</p>
        <p>The problem boils down to converting a <code>⎕XML</code>-style matrix to a <code>⎕JSON</code>-style matrix. We know what  a <code>⎕XML</code> matrix looks like, and we know how the DOM is stuctured (which is good, as half the battle is simply knowing the destination), but what on Earth does the corresponding <code>⎕JSON</code> matrix look like? Fortunately, we can create a simple document fragment:   </p>
        <pre><code>      A←#.Abacus.Main
SimpleDoc←{
     d←A.New'section'
     d.class←'post'
     d.id←'p20230411'
     h←d A.New'h1' 'Simple Doc'
     l←d A.New'ul'
     l.Content←{A.New'li'⍵}¨'One' 'Two' 'Three'
     _←(A.Elements d).⎕EX⊂'Parent'⍝ Not good for JSON
     d
 } 
      d←SampleDoc 0
      h←A.DOM2HTML d
      h
&lt;section class="post" id="p20230411"&gt;
  &lt;h1&gt;Simple Doc&lt;/h1&gt;                
  &lt;ul&gt;                               
    &lt;li&gt;One&lt;/li&gt;                     
    &lt;li&gt;Two&lt;/li&gt;                     
    &lt;li&gt;Three&lt;/li&gt;                   
  &lt;/ul&gt;                              
&lt;/section&gt;   
</code></pre>
        <p>And see what the familiar source <code>⎕XML</code> matrix looks like:</p>
        <pre><code>      ⎕XML h
0  section               class  post        3
                         id     p20230411    
1  h1       Simple Doc                      5
1  ul                                       3
2  li       One                             5
2  li       Two                             5
2  li       Three                           5
</code></pre>
        <p>And the corresponding unfamiliar target <code>⎕JSON</code> matrix:</p>
        <pre><code>      ⎕JSON⍠'M'⊢⎕JSON d
0                       1
1  Content              2
2                       1
3  Content              2
4           Simple Doc  4
3  Tag      h1          4
2                       1
3  Content              2
4                       1
5  Content              2
6           One         4
5  Tag      li          4
4                       1
5  Content              2
6           Two         4
5  Tag      li          4
4                       1
5  Content              2
6           Three       4
5  Tag      li          4
3  Tag      ul          4
1  Tag      section     4
1  class    post        4
1  id       p20230411   4
</code></pre>
        <p>The are indeed a little different. By inspection, and some trial and error, we can write a function to go directly from the <code>⎕XML</code> matrix to the <code>⎕JSON</code> matrix:</p>
        <pre><code>XM2JM←{
     ⍝ ⍵ ←→ ⎕XML matrix
     ⍝ ← ←→ ⎕JSON matrix
     ⊃⍪/{
         d e t a←4↑⍵
         k←2×d
         j←k+1
         e≡'':⍉⍪k''t 4         ⍝ Data        1 row OR...
         z←⊂k'' '' 1           ⍝ Object      (1 row)+
         z,←⊂j'Tag'e 4         ⍝ Element     (1 row)+
         z,←4,⍨¨j,¨↓a          ⍝ Attributes  (0 or more rows)+
         z,←⊂j'Content' '' 2   ⍝ Content     (1 row)+
         z,←(0&lt;≢t)/⊂(j+1)''t 4 ⍝ Text        (0 or 1 row)
         ↑z}¨↓⍵
 }
</code></pre>
        <p>This loops through each row of the <code>⎕XML</code> matrix, which is less than desirable (but surprisingly not particularly slow). However it provides us insight into how to take a more array oriented approach:</p>
        <pre><code>XM2JM←{
     ⍝ ⍵ ←→ ⎕XML matrix
     ⍝ ← ←→ ⎕JSON matrix
     (o t)←↓⍉~⍵[;1 2]∊⊂''                     ⍝ Object, text
     l←≢¨⍵[;3]                                ⍝ Number of attributes
     n←o*⍨3+t+l                               ⍝ Target rows per source row
     s←0,+\¯1↓n                               ⍝ Starting index of source in target
     j←(o∧t)/3+s+l                            ⍝ Text index
     m←0 '' '' 1⍴⍨4,⍨+/n                      ⍝ Initialize result
     m[o/1+s;1 2 3]←(⊂'Tag'),4,⍨⍪o/⍵[;1]      ⍝ Tag row
     m[2+∊s+⍳¨l;1 2 3]←4,⍨⊃⍪/⍵[;3]            ⍝ Possible attribute rows
     m[o/2+s+l;1 2 3]←(+/o)⌿⍉⍪'Content' '' 2  ⍝ Content row
     m[j;2 3]←4,⍨⍪⍵[;2]/⍨o∧t                  ⍝ Possible Text row
     m[s/⍨~o;2 3]←4,⍨⍪⍵[;2]/⍨~o               ⍝ Text row
     m[;0]←(n/2×⍵[;0])+(~m[;1]∊⊂'')+2×j∊⍨⍳≢m  ⍝ Depth
     m
 }
</code></pre>
        <p>With the exception of the depth column, the target matrix is filled in over about 6 steps. There may be a way to fill in each column in one go, as the depth is done on the penultimate line.    </p>
        <p>In the next post we will investigate the relative performance of these various techniques.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/validating-dates">Validating Dates</a>
          </h1>
          <h2>March 27, 2023</h2>
        </header>
        <p>One of the features of <code>⎕DT</code> is that it validates timestamps and time numbers.</p>
        <p>Verifying type 60 and 61 time numbers, as well as timestamps (<code>⎕TS</code> style) takes a bit of computation. Leap years must be determined, there are different day counts for different months, no more than 12 months in a year, 24 hours in a day, etc:</p>
        <pre><code>      60 0 ⎕DT 20230101.235959 20010229 20000229 20231301
1 0 1 0
</code></pre>
        <p>For time numbers that are a (potentially fractional) number of days from some epoch, the testing is much simpler. In fact it is hard to come up with an invalid value when almost any input yields a valid date:</p>
        <pre><code>      1 0 ⎕DT ¯1 0 1 35654 12345.123456789123456789 123456789123456789.123
1 1 1 1 1 1    
</code></pre>
        <p>There is no need to check much of anything except perhaps the range, which appears to be somewhere near:</p>
        <pre><code>      1 0 ⎕DT ¯2 2*22 62
1 1
</code></pre>
        <p>For a relatively large array, <a href="https://github.com/the-carlisle-group/Text2Date">Text2Date</a> is taking an inordinate amount of time using <code>⎕DT</code> to validate type 60 time numbers. To investigate, some slighty modified old code (from the pre <code>⎕DT</code> era) that handles time numbers in the form <code>YYYYMMDD.HHMMSS</code>:</p>
        <pre><code>Val←{
     k←(0,5⍴100)⊤⍵×10*6
     f c←(1752 1 1 0 0 0)(4000 13 32 24 60 60)
     l←(k[1;]=2)∧(0=4|k[0;])=(0=100|k[0;])=0=400|k[0;]
     g←(k[2;]&gt;0)∧k[2;]≤l+31 28 31 30 31 30 31 31 30 31 30 31[11⌊0⌈k[1;]-1]
     (k[5;]=⌈k[5;])∧g∧∧⌿(f(≤⍤¯1)k)∧c(&gt;⍤¯1)k
 } 
</code></pre>
        <p>For comparison, let's define <code>ValDT</code>:</p>
        <pre><code>ValDT←{
     60 0 ⎕DT ⍵
 }
</code></pre>
        <p>And run on 50 million integer dates:</p>
        <pre><code>      d←18000000+?50E6⍴22E6
      cmpx 'Val d' 'ValDT d'
  Val d   → 5.2E0  |    0% ⎕⎕⎕⎕⎕⎕                                  
  ValDT d → 3.4E1  | +552% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕
</code></pre>
        <p>And <code>Val</code> has not been optimized. If we rewrite it for integers only:</p>
        <pre><code>ValInt←{
     k←(0,2⍴100)⊤⍵
     f c←(1752 1 1)(4000 13 32)
     l←(k[1;]=2)∧(0=4|k[0;])=(0=100|k[0;])=0=400|k[0;]
     g←(k[2;]&gt;0)∧k[2;]≤l+31 28 31 30 31 30 31 31 30 31 30 31[11⌊0⌈k[1;]-1]
     g∧∧⌿(f(≤⍤¯1)k)∧c(&gt;⍤¯1)k
 }
</code></pre>
        <p>Then we get:</p>
        <pre><code>      cmpx 'ValInt d' 'ValDT d'
  ValInt d   → 1.4E0  |     0% ⎕                                       
  ValDT d    → 3.8E1  | +2628% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕
</code></pre>
        <p>Something is not right here. Maybe there is some check I'm not doing, but it looks like there is more going on than that.</p>
        <p>Even more inexplicable is how long <code>⎕DT</code> takes to validate a Dyalog Date Number when the array gets large. Unless I'm missing something, the check should be almost trivial. Maybe it is some sort of memory issue rather than computational inefficiency.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/grade-up-of-grade-down">Grade Down of Grade
            Up</a>
          </h1>
          <h2>March 21, 2023</h2>
        </header>
        <p>One of the amazing things about old APL books is that no matter how many years have passed, no matter how many new language features have been added, there are invariably many useful nuggets to be gleaned from them. A lot of very smart people used APL back in the day.</p>
        <p>Consider the case of <code>⍒⍋</code> and its twin <code>⍒⍒</code>. A while back on the <a href="https://aplwiki.com/wiki/APL_Farm">APL Farm</a> there was a discussion of the interpretation and usefulness of these combinations, which culminated with:  </p>
        <blockquote>
          <p>So the conclusion is that if we are only dealing in permutations <code>⍒⍋</code> is  worthless since it's simply a slower <code>⌽</code>, and if we are not dealing in  permutations even Adám doesn't know what <code>⍒⍋</code> does so it is probably equally worthless.</p>
        </blockquote>
        <p>I read this at the time with an uneasy feeling that somewhere, sometime, I had a use for <code>⍒⍋</code>, but promptly forgot about the whole thing. And then just the other day I was refactoring a test for a function that computes the <a href="https://support.microsoft.com/en-us/office/rank-avg-function-bd406a6f-eb38-4d73-aa8e-6d1c3c72e83a">average rank</a>. And lo and behold:</p>
        <pre><code>      averageRankUp←{0.5×(⍋⍋⍵)+⍒⍋⌽⍵}
</code></pre>
        <p>and its sibling:</p>
        <pre><code>      averageRankDown←{0.5×(⍋⍒⍵)+⍒⍒⌽⍵}
</code></pre>
        <p>I wonder if and how average rank could be computed as efficiently or succinctly without <code>⍒⍋</code>. I know it can be computed using two outer products, but that is very expensive in time, space, and tokens. I also wonder if there are any other documented uses of these pairings. Given the discussion in the APL Farm where it was observed that <code>⍒⍋p</code> is <code>⌽p</code> for permutation <code>p</code>, it is probably no accident that this application of <code>⍒⍋</code> involves <code>⌽</code>.</p>
        <p>I was pretty sure I did not come up with these expressions on my own, and a short search of my library revealed that I had most likely lifted it from <a href="https://www.amazon.com/Depth-Springer-Statistics-Norman-Thomson/dp/0387942130/ref=sr_1_1?crid=MEY9ZS4JFYYO&amp;keywords=apl2+in+depth&amp;qid=1679418843&amp;sprefix=apl2+in+depth%2Caps%2C180&amp;sr=8-1&amp;ufe=app_do%3Aamzn1.fos.f5122f16-c3e8-4386-bf32-63e904010ad0">APL2 in Depth</a> , a 1995 text by legends <a href="https://www.youtube.com/watch?v=jPujK-GvHGQ&amp;list=PLYKQVqyrAEj91hZHbJiWOENHZP4JT8VFv&amp;index=1">Norman Thompson</a> and <a href="https://www.youtube.com/watch?v=w1VMeSzJLyE&amp;list=PLYKQVqyrAEj91hZHbJiWOENHZP4JT8VFv&amp;index=12">Ray Polivka</a>. Don't get rid of those old APL books!</p>
        <p> </p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2023 Paul S. Mansour</p>
    </footer>
  </body>
</html>
