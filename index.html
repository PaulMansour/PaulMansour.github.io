<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/leetcode-601">LeetCode 601: Human Traffic of
            Stadium</a>
          </h1>
          <h2>July 9, 2022</h2>
        </header>
        <p>
          In
          <a href="https://leetcode.com/problems/human-traffic-of-stadium/">this
          LeetCode problem</a>
          , we are given the following table:
        </p>
        <pre>
          <code> t.Display 0
── LeetCode601.Numbers ─────────
 ┌ID──┐  ┌VisitDate─┐  ┌People┐ 
 ↓1   │  ↓2017-01-01│  ↓10    │ 
 │2   │  │2017-01-02│  │109   │ 
 │3   │  │2017-01-03│  │150   │ 
 │4   │  │2017-01-04│  │99    │ 
 │5   │  │2017-01-05│  │145   │ 
 │6   │  │2017-01-06│  │1,455 │ 
 │7   │  │2017-01-07│  │199   │ 
 │8   │  │2017-01-09│  │188   │ 
 └Int8┘  └Date──────┘  └Int16─┘ 
── 8 rows by 3 columns ─────────
</code>
        </pre>
        <p>And informed that:</p>
        <blockquote>
          <p>VisitDate is the primary key for this table. Each row of this
          table contains the visit date and visit id to the stadium with
          the number of people during the visit. No two rows will have
          the same VisitDate, and as the ID increases, the dates increase
          as well.</p>
        </blockquote>
        <p>And then charged with:</p>
        <blockquote>
          <p>Write an SQL query to display the records with three or more
          rows with consecutive id's, and the number of people is greater
          than or equal to 100 for each. Return the result table ordered
          by VisitDate in ascending order.</p>
        </blockquote>
        <p>Let's take a look at how to the solve this in APL, and then
        translate to a FlipDB solution. First some variables:</p>
        <pre>
          <code>      i←1+⍳8
      p←10 109 150 99 145 1455 199 188 
</code>
        </pre>
        <p>Note that the visit date adds nothing of interest to this problem.
        Also note we assume, for now, the IDs are already in ascending
        order. Selecting out IDs where the number of People is greater
        than 100:</p>
        <pre>
          <code>      j←(p&gt;100)/i
      j
2 3 5 6 7 8
</code>
        </pre>
        <p>
          This yields non-consecutive IDs, which is the heart of the problem.
          We now need to identify runs of non-consecutive IDs, which is
          easy using the rank idiom (
          <code>⍋⍋</code>
          ):
        </p>
        <pre>
          <code>      j-⍋⍋j
2 2 3 3 3 3 
</code>
        </pre>
        <p>We might reach for pair-wise reduction here instead, to find
        where the IDs increase by more than one, but that leads to a more
        complicated solution. Now partition or group the IDs by their runs:</p>
        <pre>
          <code>     g←(j-⍋⍋j)⊆j 
     g
┌───┬───────┐
│2 3│5 6 7 8│
└───┴───────┘
</code>
        </pre>
        <p>And finally, get a simple vector of all IDs that exist in groups
        of 3 or more:</p>
        <pre>
          <code>       k←∊(3≤≢¨g)/g
       k
5 6 7 8 
</code>
        </pre>
        <p>A boolean where clause to apply to the original table is then:</p>
        <pre>
          <code>      i∊k
0 0 0 0 1 1 1 1
</code>
        </pre>
        <p>And we are pretty much done. We can write this as a one-liner
        using a couple of dfns if we want an expression that maps to a
        single FlipDB where statement:</p>
        <pre>
          <code>      i∊∊{(2&lt;≢¨⍵)/⍵}{(⍵-⍋⍋⍵)⊆⍵}(p&gt;100)/i
0 0 0 0 1 1 1 1
</code>
        </pre>
        <p>Now we can almost transliterate into FlipDB:</p>
        <pre>
          <code>      ID in {z where 2 &lt; count z} {(z-rankUp z) partition z} ID where People &gt; 100
</code>
        </pre>
        <p>
          Note that the
          <code>where</code>
          appearing twice above is not a where clause, which is the entire
          statement, but the
          <code>where</code>
          function - a FlipDB structural function. Of course in FlipDB
          we might break the problem down a bit, and define some computed
          values first in our query, and we should probably sort the IDs
          to ensure ascending order:
        </p>
        <table>
          <thead>
            <tr>
              <th class="left">Name</th>
              <th class="left">Expression</th>
              <th class="center"></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="left">
                <code>Over100</code>
              </td>
              <td class="left">
                <code>sortUp ID where People &gt; 100</code>
              </td>
              <td class="center"></td>
            </tr>
            <tr>
              <td class="left">
                <code>Groups</code>
              </td>
              <td class="left">
                <code>{(z - rankUp z) partition z} Over100</code>
              </td>
              <td class="center"></td>
            </tr>
            <tr>
              <td class="left">
                <code>Threes</code>
              </td>
              <td class="left">
                <code>Groups where 2 &lt; count Groups</code>
              </td>
              <td class="center"></td>
            </tr>
          </tbody>
        </table>
        <p>and then write a simple where statement:</p>
        <pre>
          <code>      ID in Threes
</code>
        </pre>
        <p>This keeps it clean, simple, and usefully traceable in the FlipDB
        tracer.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/trains">Trains</a>
          </h1>
          <h2>July 8, 2022</h2>
        </header>
        <p>
          In a
          <a href="/posts/leetcode-571">previous post</a>
          we computed the median on grouped data by replicating it and
          applying a
          <code>median</code>
          function that works on ungrouped data. I assumed that there was
          a way to compute the median without replicating the data, and
          sure enough,
          <a href="http://tamstat.com">Brother Statistician Steve</a>
          sent me this old (pre-interval index) solution (slightly modified
          for explanatory purposes):
        </p>
        <pre>
          <code>median1←{
    ⍝ ⍺ ←→ Frequency
    ⍝ ⍵ ←→ Values
    c←(+\⍺)÷+/⍺
    i←(0.5≤c)⍳1
    ⍵[i+0,0.5∊c]+.÷2
}
</code>
        </pre>
        <p>Looking at:</p>
        <pre>
          <code>      (+\⍺)÷+/⍺
</code>
        </pre>
        <p>the function train jumps right off the monitor:</p>
        <pre>
          <code>      +\÷+/
</code>
        </pre>
        <p>
          As an aside, trains come in two styles. First is the
          <strong>Orange Blossom Special</strong>
          style, of which this is a prime example. These trains are elegant,
          a great pleasure to ride. Then we have the
          <strong>Amtrak</strong>
          style, which is a mess of tacks, jots, and tildes diaeresis.
          (I'm guessing that is the proper plural form, and not tilde diaereses.)
          These trains are all glue and duct tape. A terrible travel experience.
          One is better off taking the dfn.
        </p>
        <p>But the point of this post is that it never occurred to me that
        trains work in FlipDB. And why wouldn't they?! In the FlipDB session:</p>
        <pre>
          <code>      (sum running / sum) 7 1 3 1
┌────────────┐
↓0.5833333333│
│0.6666666667│
│0.9166666667│
│1           │
└Float───────┘
</code>
        </pre>
        <p>So we can use trains anywhere, in a where clause, a select clause,
        a having clause, anywhere a FlipDB expression is called for.</p>
        <p>Ten minutes after Steve sent over the solution above he sent
        a new one using interval index, and catching the train too.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/leetcode-569">LeetCode 569: Median Employee
            Salary</a>
          </h1>
          <h2>July 7, 2022</h2>
        </header>
        <p>This problem is poorly constructed and annoying for multiple
        reasons. It's also hard to solve - and that makes it even more
        annoying. We are given the following table:</p>
        <pre>
          <code>      t.Display 0
── LeetCode569.Employee ─────
 ┌ID──┐  ┌Company┐  ┌Salary┐ 
 ↓1   │  ↓A      │  ↓2,341 │ 
 │2   │  │A      │  │341   │ 
 │3   │  │A      │  │15    │ 
 │4   │  │A      │  │15,314│ 
 │5   │  │A      │  │451   │ 
 │6   │  │A      │  │513   │ 
 │7   │  │B      │  │15    │ 
 │8   │  │B      │  │13    │ 
 │9   │  │B      │  │1,154 │ 
 │10  │  │B      │  │1,345 │ 
 │11  │  │B      │  │1,221 │ 
 │12  │  │B      │  │234   │ 
 │13  │  │C      │  │2,345 │ 
 │14  │  │C      │  │2,645 │ 
 │15  │  │C      │  │2,645 │ 
 │16  │  │C      │  │2,652 │ 
 │17  │  │C      │  │65    │ 
 └Int8┘  └Char(1)┘  └Int16─┘ 
── 17 rows by 3 columns ─────
</code>
        </pre>
        <p>And tasked with:</p>
        <blockquote>
          <p>Each row of this table indicates the company and the salary
          of one employee. Write an SQL query to find the median salary
          of each company.</p>
        </blockquote>
        <p>
          If we did not have an example to the contrary, and we wanted
          to
          <em>find the median salary of each company</em>
          as the instructions say, then this is an easy query, first grouping
          by company, and then applying the aggregate expression
          <code>median Salary</code>
          in the select clause.
        </p>
        <p>But the desired result is:</p>
        <pre>
          <code>      r.Display 0
── Key:ID ───────────────────
 ┌ID──┐  ┌Company┐  ┌Salary┐ 
 ↓5   │  ↓A      │  ↓451   │ 
 │6   │  │A      │  │513   │ 
 │9   │  │B      │  │1,154 │ 
 │12  │  │B      │  │234   │ 
 │14  │  │C      │  │2,645 │ 
 └Int8┘  └Char(1)┘  └Int16─┘ 
── 5 rows by 3 columns ──────
</code>
        </pre>
        <p>By inspection we see that the actual instructions should read
        something more like:</p>
        <blockquote>
          <p>Write an SQL query that returns the employees that earn the
          median salary if the median is not an interpolated value, or
          the two salaries that are averaged to compute the median, for
          their respective companies. Remove employees that duplicate company/salary
          combinations from the result set.</p>
        </blockquote>
        <p>Yuck.</p>
        <p>
          Assume for moment we had a built-in structural function named
          <code>medians</code>
          that returned a one-item array or a two-item array containing
          the values that go into constructing the median. Then we could
          simply write the select clause:
        </p>
        <pre>
          <code>      Salary in medians each by Salary (group Company)
</code>
        </pre>
        <p>
          using the
          <code>each</code>
          and
          <code>by</code>
          operators which does everything we need except the final removal
          of duplicates. (I am resisting the urge to implement
          <code>medians</code>
          in FlipDB). Note that the
          <code>each</code>
          operator is necessary as
          <code>medians</code>
          is a structural function, not an aggregate, or scalar, or uniform
          function. (More on this in a future post). However, in FlipDB
          we can do in-line anonymous functions just like dfns in APL,
          so we can replace
          <code>medians</code>
          above with this mess of a one-liner:
        </p>
        <pre>
          <code>     {(floor (shape z) / 2)index each enclose(sortUp z)(sortDown z)}
</code>
        </pre>
        <p>
          There is probably a much neater way to get the medians. FlipDB
          uses
          <code>z</code>
          as the right argument, in place of
          <code>⍵</code>
          in APL. The
          <code>enclose</code>
          function in FlipDB converts a set of simple columns into a single
          nested column. If there are an odd-number of items, we will get
          the same item twice, but it does not matter for the problem.
        </p>
        <p>With this in hand we can solve the problem:</p>
        <pre>
          <code>      q←t.Query''
      q.Where←'Salary in {(floor (shape z) / 2)index each enclose(sortUp z)(sortDown z)} each by Salary (group Company)'
      q.Having←'firstOccurrence Company laminate toChar Salary'
      r←q.Execute 0
      r.Display 0
── Key:ID ───────────────────
 ┌ID──┐  ┌Company┐  ┌Salary┐ 
 ↓5   │  ↓A      │  ↓451   │ 
 │6   │  │A      │  │513   │ 
 │9   │  │B      │  │1,154 │ 
 │12  │  │B      │  │234   │ 
 │14  │  │C      │  │2,645 │ 
 └Int8┘  └Char(1)┘  └Int16─┘ 
── 5 rows by 3 columns ──────
</code>
        </pre>
        <p>The having clause should probably be able to be written as:</p>
        <pre>
          <code>      firstOccurrence Company Salary
</code>
        </pre>
        <p>
          The
          <code>firstOccurrence</code>
          function is a cover for APL's unique mask function (monadic
          <code>≠</code>
          ). I don't think there is any reason it should not accept multiple
          columns. It could also take a table or datatable as an argument
          - on the todo list!
        </p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2022 Paul S. Mansour</p>
    </footer>
  </body>
</html>
