<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/modal-dialog-boxes-1">Modal Dialog Boxes 1:
            Alert</a>
          </h1>
          <h2>April 29, 2024</h2>
        </header>
        <p>JavaScript provides at least three methods for small, utility, modal dialog boxes: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/alert">alert</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm">confirm</a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt">prompt</a>.</p>
        <p>While handy, these methods have limitations. At a minimum we want to be able to style these dialog boxes, and that cannot be done as they are implemented by the underlying operating system. More importantly, we need additional behaviors. For example, the <code>confirm</code> method provides two buttons, <em>Yes</em> and <em>No</em>, and we may want different labels or more than two choices. In addition, we may want to be able to pause an APL function mid execution, server-side, waiting for the response to a set of choices from the user.</p>
        <p>Abacus thus provides 3 analogous components: <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/AlertBox">AlertBox</a>, <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/ConfirmBox">ConfirmBox</a>, and <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/PromptBox">PromptBox</a>. These are all built with the native HTML <code>&lt;dialog&gt;</code> element. All three of these components are modal from the perspective of the user - that is, the use cannot access any other part of the page or app until the dialog box is closed. However, from the programmer's perspective, they behave very differently.</p>
        <p>The simplest is the <code>AlertBox</code> component. It provides a message to the user in a modal dialog that may dismissed by pressing the <code>OK</code> button or the <code>Esc</code> key. </p>
        <blockquote>
          <p>Abacus components are not formally classes, just a few functions in a namespace, inlcuding <code>New</code> to create a new instance and <code>CSS</code> to define the styling. Depending on the component, additional functions like <code>Show</code>, <code>Run</code>, or <code>Init</code> may be defined.</p>
        </blockquote>
        <p>The AlertBox is called using its <code>Show</code> method:</p>
        <pre><code>      d A.AlertBox.Show 'Hello world!'
</code></pre>
        <p>The important thing to note about this is that your code does not wait here. The alert box is displayed, and the calling APL function keeps on running. So you cannot use alerts as a debugging tool to pause and display state, as you might have done with <code>MsgBox</code> using <code>⎕WC</code>. The behavior of <code>AlertBox</code> is in contrast to, as we shall see in the next post, the way the <code>ConfirmBox</code> component behaves. It would be easy enough to make the alert box modal with a capital M and to wait in the APL code for the user to click <code>OK</code>. However, as far as I can tell, there is no real use case for this, other than perhaps debugging, for which we already have much better tools. Furthermore, the confirm box with a single button works this way, so it can be used to pause and display state if necessary.</p>
        <p>The left argument <code>Show</code> is the application document, the right argument is the message to display. The <code>Show</code> method calls the <code>New</code> method to construct the component, and then the <code>ShowModal</code> function to insert it into the document and to display it:</p>
        <pre><code>Show←{
     ⍺ A.ShowModal New ⍵
 }
New←{
     ⍝ ⍵ ←→ Message
     ⍝ ← ←→ New dialog element
     m←⍵
     A←##
     d←A.New'dialog'
     d.class←'alert-box'
     p←d A.New'p'm
     b←d A.New'button' 'OK'
     b.Onclick←A.FQP'OnOK'
     d.Onclose←A.FQP'OnOK'
     d
 }
ShowModal←{
     ⍝ ⍺ ←→ Document
     ⍝ ⍵ ←→ dialog element
     b←GetBody ⍺
     _←⍺ SetDefaultId Elements ⍵
     _←b AppendChild ⍵
     ⍵ ExecuteOnElement'showModal()'
 }
</code></pre>
        <p>In Abacus, dialog boxes are created and disposed of every time they are called on to appear. So, for the alert box, we use the same callback for the click event and the close event, which deletes the component from the DOM:</p>
        <pre><code>OnOK←{
     d←⍵.CurrentTarget ##.GetNearest'dialog'
     ##.DeleteElement d
 }
</code></pre>
        <p>The alert box is a simple component. It has no knowledge of the state of the server, or the client for that matter. It puts a message on the screen and forces the user to acknowledge it for continuing to use the app. </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/abacus-threading-model">The Abacus Threading
            Model</a>
          </h1>
          <h2>April 28, 2024</h2>
        </header>
        <p>Way back in September 2022 we looked  at <a href="/posts/threading-the-htmlrenderer">threading the HTMLRenderer</a>. A few changes have happened since then including some additional requirements around modal dialogs, progress bars, and confirmation boxes. Let's take a look.</p>
        <p>To review, Abacus uses websockets for two-way asynchronous communication between the browser (whether the <code>HTMLRenderer</code> or a remote, independent client browser) and an APL session.</p>
        <p>There are four different types of client-server interaction that must be considered.  </p>
        <p>The first two types of interaction originate on the client side, from the user taking action in the browser. These interactions are asynchronous - the client sends a message to the server and goes on its merry way. The server may send back 0 or more messages at some point.</p>
        <p>The 1st interaction type is the normal case of handling basic user actions like clicking a button, entering text in an input field or scrolling though a datagrid. These messages are <strong>threaded and queued</strong>. Each message executes an APL handler function in its own thread, but each thread must wait for the previous thread to complete before it starts. This queue is managed by <code>⎕TSYNC</code>. Why are these messages threaded only to be queued and run sequentially?  Because we always want the websocket messages to be handled immediately (thus the threading), but in the normal case we want user generated events handled in order (thus the queue). The APL handler function will in this case almost always send some HTML back to the browser.</p>
        <p>Note that these threaded-and-queued messages can, if they need to, kick off long-running processes in yet another thread and report back immediately to the client, and avoid tying up the server.</p>
        <blockquote>
          <p>There is at least one other technique for handling threaded and queued messages. There is no reason that we need a new thread for each message. Messages must be dispatched in a thread other than 0, but since they are queued they do not need to be in different threads from each other. Thus, when the app starts, we could create one permanent thread with <code>⎕TGET</code> in a loop, and have the main thread chuck messages into it using <code>⎕TPUT</code>. You would think this might be more efficient than creating a new short-lived thread for every single message. But you might be wrong.</p>
        </blockquote>
        <p>The 2nd interaction type is the case of handling user actions that control or modify a previous user action. Consider a confirmation dialog box. This is Modal with a capital M - that is a function executing in APL is paused on a particular line, waiting for the user in the browser to take some action, like <em>Continue</em> or <em>Cancel</em>. This message cannot wait for the previous request to finish, because the previous request is asking the user if he wants to continue or cancel the previous request. Therefore it must execute immediately and without delay on the server. Or consider a progress bar dialog that must let the server  know that the process kicked off by the previous message should be canceled or paused. This too cannot wait for the previous message to complete. These messages are <strong>unthreaded and unqueued</strong>. These messages generally do not send any HTML back to the client - that is done by the message they are modifying.  </p>
        <blockquote>
          <p>There are also modal dialog boxes with a lower case m. These are modal only in the sense that the user cannot interact with the rest of the page until the modal is dismissed. There is no pendant or waiting APL function over on the server. Generally modal dialogs should be avoided, and Modal dialogs with a capital M avoided even more, but they both have their proper place, and it is important that we can create them and have automated tests that exercise them.</p>
        </blockquote>
        <p>The 3rd and 4th types of interaction originate on the server and simulate synchronous behavior. That is, a function on the server sends a message to the client and waits, using <code>⎕TGET</code>, for a response. Both of these types are generally used only for automated testing. There is generally no reason for an application to need this functionality in the normal course.    </p>
        <p>The 3rd type is the case of handling synchronous JavaScript. The server sends a JavaScript snippet to the client for execution and waits for a response. The server will send the <code>TID</code> with the request as an identifier, and the client will send it back. This allows the server to use <code>⎕TGET</code> and <code>⎕TPUT</code> to implement synchronous behavior. The prime use of synchronous JavaScript requests is testing: the server needs to get the <code>innerHTML</code> of some element to inspect the state of the client. The result message from the client is not threaded or queued, and requires no real processing of any sort; it is simply chucked to the waiting server thread using <code>⎕TPUT</code>.</p>
        <p>The 4th type of interaction is the server firing an event on the client, which in turn is handled by the server. When a function on the server sends an event to be fired back on the client, it must wait (in a thread, so as not to block) for the client to send a request back, and for that request to complete. Then, and only then, can the server function inspect the state  of the server and/or the client to make sure the intended thing actually happened.  When the server handles the message that the server has asked the client to send, it handles it just as if the user initiated the event, with the exception that when the task completes, the thread handling the task must notify the waiting thread of completion.  Again, this is generally only used for automated testing.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/making-sharpplot-charts-interactive">Making
            SharpPlot Charts Interactive</a>
          </h1>
          <h2>December 21, 2023</h2>
        </header>
        <p>Now that we know how to make attractive charts in <a href="https://sharpplot.com">SharpPlot</a>, the next step is add interactivity. SharpPlot has a <a href="https://sharpplot.com/Links.htm">brief tutorial</a> on this topic, and provides various methods for making charts interactive.  The <a href="https://sharpplot.com/SharpPlot-AddHyperlinks.htm">AddHyperlinks</a> method will add a hyperlink to any bar or point in a chart.  The <a href="https://sharpplot.com/SharpPlot-AddAttributes.htm">AddAttributes</a> method allows an arbitrary attribute and value to be inserted into  <a href="https://sharpplot.com/ScriptTarget.htm">various elements</a></p>
        <p>However, much of the techniques used are outdated given where CSS and SVG are  now and the existence of the HTMLRenderer. In addition, using SharpPlot itself to add interactivity might be useful if we were to rely on different output formats but our only concern is SVG. All we need to do is to be able to identify and address the elements of interest. One option to accomplish this is to use the <code>AddAttributes</code>  method to add an id to the elements. Unfortunately, <code>AddAttributes</code> adds an additional  <code>&lt;rect&gt;</code> element for every <code>&lt;text&gt;</code> element, (and then adds it own id as well).  For example, here is a snippet of SVG from a basic bar chart: </p>
        <pre><code>&lt;desc&gt;for X-axis labels&lt;/desc&gt;
 &lt;g font-family="Times New Roman" font-size="80" text-anchor="middle" &gt;
  &lt;text x="793" y="2096" &gt;North&lt;/text&gt;
  &lt;text x="1548" y="2096" &gt;South&lt;/text&gt;
  &lt;text x="2303" y="2096" &gt;East&lt;/text&gt;
  &lt;text x="3058" y="2096" &gt;West&lt;/text&gt;
 &lt;/g&gt;
</code></pre>
        <p>We want to be able to identify and manipulate these <code>&lt;text&gt;</code> elements, but when we add an id using the <code>AddAttributes</code> method we get:</p>
        <pre><code>&lt;desc&gt;for X-axis labels&lt;/desc&gt;
 &lt;rect x="699" y="2024" width="187" height="88" fill="none" pointer-events="visible" id="chart1_XLabels_1" myid="xlabel0" &gt; &lt;/rect&gt;
 &lt;rect x="1454" y="2024" width="187" height="88" fill="none" pointer-events="visible" id="chart1_XLabels_2" myid="xlabel1" &gt; &lt;/rect&gt;
 &lt;rect x="2209" y="2024" width="187" height="88" fill="none" pointer-events="visible" id="chart1_XLabels_3" myid="xlabel2" &gt; &lt;/rect&gt;
 &lt;rect x="2964" y="2024" width="187" height="88" fill="none" pointer-events="visible" id="chart1_XLabels_4" myid="xlabel3" &gt; &lt;/rect&gt;
 &lt;g font-family="Times New Roman" font-size="80" text-anchor="middle" pointer-events="none" &gt;
  &lt;text x="793" y="2096" &gt;North&lt;/text&gt;
  &lt;text x="1548" y="2096" &gt;South&lt;/text&gt;
  &lt;text x="2303" y="2096" &gt;East&lt;/text&gt;
  &lt;text x="3058" y="2096" &gt;West&lt;/text&gt;
 &lt;/g&gt;
</code></pre>
        <p>I'm sure there was a reason in the past for having the <code>&lt;rect&gt;</code> element, probably just to  apply the <code>pointer-visible</code> attribute, but I don't think there is any need for it today. This gets in the way of, say, making the text of one x axis value bold using CSS.  We need to identify the <code>&lt;text&gt;</code> element, not some associated <code>&lt;rect&gt;</code> element.  </p>
        <p>Luckily we can use <a href="https://github.com/the-carlisle-group/Abacus">Abacus</a> to create an APL DOM of the SVG text emitted by SharpPlot. Then we can easily manipulate elements, add attributes, and so on. The problem is that the SVG is full of largely unidentifiable <code>&lt;text&gt;</code> and <code>&lt;rect&gt;</code> elements. But there are comments embedded using the <code>&lt;desc&gt;</code> element, as can be seen above. We can do some crude coding and sort of find out where things are. For example, here is a function that identifies the basic elments of a single series bar chart, adding id and class attributes: </p>
        <pre><code>AddIdsToDOM←{
     ⍝ ⍵ ←→ DOM
     ⍝ Crude Technique that relies on comments
     ⍝ Will not work if AddAttributes is used in certain circumastances
     ⍝ ... as additional elements are inserted.
     ⍝ Works only on basic bar chart with one series
     A←#.Abacus.Main
     e←A.Elements ⍵
     n←'xlabel' 'ylabel' 'value' 'point'
     v←'for X-axis labels' 'Y-axis labels' 'Data value labels ...'('Start of Barchart ',11⍴'=')
     ⍵⊣n{
         p←⊃e A.ElementsWhere'Content'⍵
         c←(e⊃⍨1+e⍳p).Content
         c.class←⊂⍺
         c.id←⍺∘,¨⍕¨⍳≢c
         0
     }¨v
 }
</code></pre>
        <p>Which yields:</p>
        <pre><code>&lt;desc&gt;for X-axis labels&lt;/desc&gt;
    &lt;g font-family="Times New Roman" font-size="80" text-anchor="middle"&gt;
      &lt;text class="xlabel" id="xlabel0" x="793" y="2096"&gt;North&lt;/text&gt;
      &lt;text class="xlabel" id="xlabel1" x="1548" y="2096"&gt;South&lt;/text&gt;
      &lt;text class="xlabel" id="xlabel2" x="2303" y="2096"&gt;East&lt;/text&gt;
      &lt;text class="xlabel" id="xlabel3" x="3058" y="2096"&gt;West&lt;/text&gt;
    &lt;/g&gt;
</code></pre>
        <p>Now we can easily identify and manipulate all the relevant elements. (Of course SharpPlot knows exactly where and what everything is when it generates the SVG, and it would be much better if it added the id and class attributes itself.) Now we can construct a bar chart that operates like a pick list, allowing the user to scroll up and down, highlighting the current selection by placing a border around the bar and bolding and increasing the font size of the associated labels: </p>
        <svg baseProfile="full" ev="http://www.w3.org/2001/xml-events" height="262.67" tabindex="0" version="1.1" viewBox="0 0 6290 1970" width="838.67" xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg">
          <desc>Created by Causeway SVG engine - SharpPlot v3.71.0</desc>
          <g stroke-miterlimit="100">
            <rect fill="silver" height="1910" width="6210" x="80" y="60"></rect>
            <rect fill="white" height="1905" stroke="black" stroke-width="5" width="6205" x="43" y="33"></rect>
            <desc>Paint the paper =====</desc>
            <g fill="White">
              <rect height="1900" width="6200" x="45" y="35"></rect>
            </g>
            <desc>Border =====</desc>
            <desc>for X-axis labels</desc>
            <g font-family="Times New Roman" font-size="140" text-anchor="middle">
              <text class="xlabel" id="xlabel0" x="1653" y="1646">1,000</text>
              <text class="xlabel" id="xlabel1" x="2160" y="1646">2,000</text>
              <text class="xlabel" id="xlabel2" x="2668" y="1646">3,000</text>
              <text class="xlabel" id="xlabel3" x="3175" y="1646">4,000</text>
              <text class="xlabel" id="xlabel4" x="3683" y="1646">5,000</text>
              <text class="xlabel" id="xlabel5" x="4190" y="1646">6,000</text>
              <text class="xlabel" id="xlabel6" x="4698" y="1646">7,000</text>
              <text class="xlabel" id="xlabel7" x="5205" y="1646">8,000</text>
            </g>
            <desc>Heading, subheading and footnotes =====</desc>
            <desc>Region =====</desc>
            <desc>Y-axis labels</desc>
            <g font-family="Times New Roman" font-size="140" text-anchor="end">
              <text class="unselectedlabel" id="ylabel0" onclick="sendAPLRequest(event)" x="1013" y="1265">Cash-Out</text>
              <text class="selectedlabel" id="ylabel1" onclick="sendAPLRequest(event)" style="font-weight:bold;font-size:larger" x="1013" y="925">Refinance</text>
              <text class="unselectedlabel" id="ylabel2" onclick="sendAPLRequest(event)" x="1013" y="585">Purchase</text>
            </g>
            <desc>X-Axis Ticks =====</desc>
            <desc>X-Axis tickmarks</desc>
            <path d="M1149 1456L1149 1505M1399 1456L1399 1505M1653 1456L1653 1505M1906 1456L1906 1505M2160 1456L2160 1505M2414 1456L2414 1505M2668 1456L2668 1505M2921 1456L2921 1505M3175 1456L3175 1505M3429 1456L3429 1505M3683 1456L3683 1505M3936 1456L3936 1505M4190 1456L4190 1505M4444 1456L4444 1505M4698 1456L4698 1505M4951 1456L4951 1505M5205 1456L5205 1505" fill="none" stroke="DarkGray" stroke-width="8.94"></path>
            <desc>Y-Axis Ticks =====</desc>
            <desc>Y-Axis tickmarks</desc>
            <path d="M1084 1221L1047 1221M1084 885L1047 885M1084 545L1047 545" fill="none" stroke="DarkGray" stroke-width="8.94"></path>
            <desc>Start of Horizontal Barchart ===========</desc>
            <g fill="SteelBlue" stroke="SteelBlue" stroke-width="20">
              <rect class="unselectedbar" height="272" id="point0" onclick="sendAPLRequest(event)" ondblclick="sendAPLRequest(event)" width="508" x="1145" y="1089"></rect>
              <rect class="selectedbar" height="272" id="point1" onclick="sendAPLRequest(event)" ondblclick="sendAPLRequest(event)" style="stroke:orange" width="558" x="1145" y="749"></rect>
              <rect class="unselectedbar" height="272" id="point2" onclick="sendAPLRequest(event)" ondblclick="sendAPLRequest(event)" width="4009" x="1145" y="409"></rect>
            </g>
            <desc>Axes =====</desc>
            <path d="M1084 1395L1084 368M1145 1456L5212 1456" fill="none" stroke="DarkGray" stroke-width="14.9"></path>
            <desc>Data value labels ...</desc>
            <g fill="Gray" font-family="Times New Roman" font-size="140">
              <text class="unselectedlabel" id="value0" onclick="sendAPLRequest(event)" x="1709" y="1281">1,000</text>
              <text class="selectedlabel" id="value1" onclick="sendAPLRequest(event)" style="font-weight:bold ;font-size:larger" x="1760" y="941">1,100</text>
              <text class="unselectedlabel" id="value2" onclick="sendAPLRequest(event)" x="5211" y="601">7,900</text>
            </g>
            <desc>Reset to original origin</desc>
          </g>
        </svg>
        <p>Note that if you inspect the source of this chart, it is not as it would appear in an application. Here, for convenience in a static web site, we simply do the highlighting by using the <code>style</code> attribute. In an application, classes are used with external style sheets. Scrolling up and down will change the class of the bar, for example, from <code>unselected</code> to <code>selected</code>.   </p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2024 Paul S. Mansour</p>
    </footer>
  </body>
</html>
