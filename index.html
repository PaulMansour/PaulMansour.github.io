<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <link href="/default.css" rel="stylesheet" type="text/css"/>
 </head>
 <body>
  <header>
   <div id="logo">
    <span class="logoletterleft logolettergreen">T</span>
    <span class="logoletterright logoletterblue">o</span>
    <span class="logoletterleft logoletterred">o</span>
    <span class="logoletterright logoletteryellow">l</span>
    <span class="logoletterleft logolettergreen">O</span>
    <span class="logoletterright logoletterblue">f</span>
    <span class="logoletterleft logoletterred">T</span>
    <span class="logoletterright logoletteryellow">h</span>
    <span class="logoletterleft logolettergreen">o</span>
    <span class="logoletterright logoletterblue">u</span>
    <span class="logoletterleft logoletterred">g</span>
    <span class="logoletterright logoletteryellow">h</span>
    <span class="logoletterleft logolettergreen">t</span>
    <p><em>APL</em> for the Practical Man</p>
   </div>
   <nav id="mainmenu">
    <a href="/">Home</a>
    <a href="/posts">Posts</a>
    <a href="/projects">Projects</a>
    <a href="/donts">Don'ts</a>
    <a href="/links">Links</a>
    <a href="/about">About</a>
   </nav>
  </header>
  <main>
   <article>
    <h1><a href="/posts/building-namespace-scripts">Building Namespace Scripts</a></h1>
    <h4>March 26, 2021</h4>
    <p>DRAFT!!!!     Keeping source in text files is good. It lets us keep  Maintaining source in large classes or namespace scripts is not so good. When collaborating on a project,  Many small files versus few large files. Having many small files, however, also has problems. Distributing code is not so good, In APL, the function is the most important unit of code.</p>
    <p>The solution to this is the namespace script. Here is a first attempt at  building a single namespace script from an arbitrary namespace residing in a workspace:</p>
    <pre>
     <code>  BuildNSS←{
     ⍝ ⍺ ←→ Named namespace
     ⍺←1
     n←↑⌽{⍵⊆⍨'.'≠⍵}⍕⍵
     '['=↑n:''
     t←{16::'' ⋄ ⎕SRC ⍵}⍵
     0<≢t:t
     r←⊂':Namespace ',⍺/n
     r,←⊂'⎕IO ⎕ML←',⍕⍵.⎕IO ⍵.⎕ML
     q←{(⊂'∇',↑⍵),(1↓⍵),⊂,'∇'}
     r,←↑,/q¨⍵.⎕NR¨⍵.⎕NL-3.1 4.1
     r,←↑,/⍵.⎕NR¨⍵.⎕NL-3.2 4.2
     s←⍵{⍵[⍋⍺.⎕NC ⍵]}⍵.⎕NL-9.1 9.4 9.5
     0=≢s:r,⊂':EndNamespace'
     r,←↑,/∇¨⍵⍎¨s
     r,⊂':EndNamespace'
 }
</code></pre>
    <p>Alternatively, it should be possible to build this script directly from source  files on disk. Will try that later.</p></article>
   <article>
    <h1><a href="/posts/the-constant-operator">The Constant Operator</a></h1>
    <h4>March 21, 2021</h4>
    <p>ngn wrote:</p>
    <pre>
     <code>⍬⍨¨v
</code></pre>
    <pre>
     <code>{⍺⍺}
  
      v←⍳10000000
      cmpx '(≢v)⍴⊂⍬' '⍬⍨¨v' '{⍬}¨v'  '⍬∘⊣¨v' 'v⊢¨⊂⍬'
  (≢v)⍴⊂⍬ → 2.7E¯2 |     0% ⎕⎕                                      
  ⍬⍨¨v    → 2.8E¯2 |    +4% ⎕⎕                                      
  {⍬}¨v   → 4.4E¯1 | +1569% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕
  ⍬∘⊣¨v   → 2.6E¯2 |    -4% ⎕⎕                                      
  v⊢¨⊂⍬   → 2.6E¯2 |    -1% ⎕⎕      
</code></pre>
    <pre>
     <code>~~~    
        v←⍳10000000 ⋄ r←v    
        cmpx '(≢v)⍴⊂⍬' '⍬⍨¨v' 'r⊣r[]←⊂⍬'
  (≢v)⍴⊂⍬  → 2.7E¯2 |   0% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕
  ⍬⍨¨v     → 2.6E¯2 |  -2% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕ 
  r⊣r[]←⊂⍬ → 2.4E¯2 | -11% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕    
~~~    
</code></pre></article>
   <article>
    <h1><a href="/posts/modified-index-assignment-with-catenate">Modified Index Assignment with Catenate</a></h1>
    <h4>March 12, 2021</h4>
    <p>DRAFT!!!!</p>
    <p>xpqz writes:</p>
    <blockquote>
     <p>Can anyone suggest a clever way of achieving the following "left join":</p>
     <p>Given two vectors, the first a vector of char vecs, the second a vector of two-element vectors, group the second based on the first component, returning the second components per group, inserting the empty vectors for groups not present. e.g</p>
     <pre>
      <code>      X←'one' 'two' 'three' 'four'
      Y←('one' 1)('one' 2)('three' 1)('four' 2)('four' 3)
      R←⎕←X f Y
┌───┬┬─┬───┐
│1 2││1│2 3│
└───┴┴─┴───┘
      R≡(1 2)(,⍬)(,1)(2 3)
1
</code></pre></blockquote>
    <p>Adam write:</p>
    <pre>
     <code>(⊃¨{⊂1↓⊢/¨⍵}⌸⊢)(X,⍥⊂¨0),Y
</code></pre>
    <p>ngn writes</p>
    <pre>
     <code>K V←↓⍉↑Y
R←⍬⍨¨X
R[X⍳K],←V
</code></pre>
    <p>This is the second post. Here is an interesting line of code from the inimitable ngn over at the APL Orchard:</p>
    <pre>
     <code>r[x⍳k],←v
</code></pre>
    <p>This bears further study for three reasons. I am always befuddled by modified assignent. I am  furhter befuddled when the fuction is not scalar. I am further befuddled by the indexing, and then even further by the fact there are repeated indices and the function is catenate. Ok that's four reasons.</p></article>
   <h2>
    <a href="/posts">More posts...</a></h2></main>
  <p class="forceclear"/>
  <footer>
   <p>Tool Of Thought - Copyright 2021 Paul S. Mansour</p>
  </footer>
 </body>
</html>
