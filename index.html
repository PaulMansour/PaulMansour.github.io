<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/uncle-bob-and-the-primeagen">Uncle Bob and
            The Primeagen</a>
          </h1>
          <h2>May 7, 2024</h2>
        </header>
        <p>Recently the genial Robert "Uncle Bob" Martin sat down with the always entertaining Primeagen for an <a href="https://www.youtube.com/watch?v=UBXXw2JSloo">interview</a>.  Given The Primeagen's well-known aversion to TDD and short functions, it was bound to be a spirited conversation, and indeed it was.</p>
        <p>I'm fully sympathetic to the idea that it's hard and often counterproductive (if not impossible) to do full TDD on a new project.  What I don't get is The Primeagen's gripe about 100% code coverage. He asks Uncle Bob about testing the summing of the elements of an array. Uncle Bob explains that he would not write a specific test for that, but that the code would be tested indirectly; there would be a test on a method or function that  has the line that sums the array. Or even a test higher up the stack. But the line would get executed in the test suite somewhere. In the interview, the Primeagen doesn't seem to understand that.  </p>
        <p>In response to The Primeagen's repeated questions about "what to test", Uncle Bob brings up Kent Beck: test anything and everything that can break. In APL, that's pretty much every line of every function. I assume a similar situation in any interpreted language.</p>
        <p>Consider the line: </p>
        <pre><code>      c←a+b
</code></pre>
        <p>This can fail in at least 5 different ways, including <code>VALUE ERROR</code>, <code>DOMAIN ERROR</code>, <code>RANK ERROR</code>, and <code>LENGTH ERROR</code>.  Heck, consider:</p>
        <pre><code>      v←1   
</code></pre>
        <p>This line can fail!</p>
        <p>Now, as Uncle Bob points out, it would be silly to write a test for every line of code. But every line of code should be executed in the tests, because every line of code can break. There is no excuse for less than 100% code coverage. </p>
        <p>Please note that I have written a lot of code that has a lot less than 100% coverage, even 0% coverage, and I have no excuse.  </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/modal-dialog-boxes-prompt">Modal Dialog Boxes
            3: Prompt</a>
          </h1>
          <h2>May 6, 2024</h2>
        </header>
        <p>The Abacus <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/PromptBox">PromptBox</a>  component allows the user to enter a string, and then select <code>OK</code> or <code>Cancel</code>. This dialog behaves like the  <code>AlertBox</code> dialog as opposed to the <code>ConfirmBox</code> dialog; it does not suspend or wait. It takes action via a handler function attached to the <code>OK</code> button. Let's go to the code:</p>
        <pre><code>Show←{
     ⍺ ##.ShowModal New ⍵
 }
  New←{
     ⍝ ⍵ ←→ Title, Label, Value, OKHandler
     ⍝ ← ←→ new dialog element
     tv lv iv cb←⍵
     d←A.New'dialog'
     d.class←'prompt-box'
     d.OnOK←cb
     h1←d A.New'h1'tv
     l←d A.New'label'lv
     i←d A.New'input'
     i.id←'Prompt'
     i.value←iv
     i.Oninput←A.FQP'OnInput'
     m←d A.New'menu'
     b←m A.New¨{'button'⍵}¨'OK' 'Cancel'
     b.id←'OK' 'Cancel'
     b.Onclick←A.FQP¨'OnOK' 'OnCancel'
     d
 }
 OnInput←{
     i←⍵.CurrentTarget
     i.value←⍵.Value
     0
 }
 OnOK←{
     t←⍵.CurrentTarget
     d←t A.GetNearest'dialog'
     i←d A.ElementByTag'input'
     v←i.value
     f←⍎d.OnOK
     r←⍵.Document f v
     r:0
     A.DeleteElement d
 }
 OnCancel←{
     d←⍵.CurrentTarget A.GetNearest'dialog'
     ##.DeleteElement d
 }
</code></pre>
        <p>The <code>OnOK</code> function covers the handler supplied as an argument to <code>Show</code>. If the supplied handler returns  a <code>0</code>, it is considered a success, and the prompt box is deleted. If it returns a <code>1</code>, it is considered a failure and the prompt box is left up for the user to interact with.</p>
        <p>The prompt box functionality could be implemented to wait and suspend the calling APL function, just like we do with <code>ConfirmBox</code>, but there is generally no need to maintain state, and suspending the calling function is more complex and makes testing more difficult. The same is true for more general dialog boxes, with many more controls. It is better to have callback or handler functions to take action rather than inspecting the result of a <code>Show</code> function to see what action to take.  </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/modal-dialog-boxes-confirm">Modal Dialog Boxes
            2: Confirm</a>
          </h1>
          <h2>April 30, 2024</h2>
        </header>
        <p>The Abacus <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/ConfirmBox">ConfirmBox</a>  component displays a message and one or more buttons, allowing the user to make a choice and for the programmer to control the flow  of execution of an APL function. To implement this, on the server-side APL, Abacus must be able to wait in a suspended function, while over in the client browser, the user is pondering a modal dialog box with multiple choices. When the user makes a choice, the suspended APL function must be notified of the choice and allowed to continue execution.</p>
        <p>Let's look at some code:</p>
        <pre><code>Show←{
     ⍺ ##.ShowModalAndWait New ⍵
 }
 
 ShowModalAndWait←{
     ⍝ ⍺ ←→ Document
     ⍝ ⍵ ←→ dialog element
     b←GetBody ⍺
     _←⍺ SetDefaultId Elements ⍵
     _←b AppendChild ⍵
     _←⍵ ExecuteOnElement'showModal()'
     ⊃⎕TGET ⎕TID
 }
  New←{
     ⍝ ⍵ ←→ Title Caption [Options]
     ⍝ ← ←→ new dialog element
     t c o←3↑⍵,⊂'Yes' 'No'
     d←A.New'dialog'
     d.class←'confirm-box'
     d.Onclose←A.FQP'OnClose'
     d.Unqueued←1
     d.Tid←⎕TID
     h1←d A.New'h1't
     p←d A.New'p'c
     m←d A.New'menu'
     b←m A.New¨{'button'⍵}¨o
     b.Name←o
     b.Onclick←⊂A.FQP'OnSelect'
     b.Unqueued←1
     d
 }    
 
OnSelect←{
     d←⍵.CurrentTarget ##.GetNearest'dialog'
     _←##.DeleteElement d
     v←⍵.CurrentTarget.Name
     0⊣v ⎕TPUT d.Tid
 }
</code></pre>
        <p>The <code>New</code> function takes a title, caption, and optional list of one or more  button captions, which defaults to <code>Yes</code> and <code>No</code>. The thread ID is noted in the dialog element. This will be used as a token when the user clicks on one of the choices. The button elements are flagged as being <em>Unqueued</em> (as is the parent dialog, which  has an onclose event handler). This is critical. Normally browser events are handled serially  on the APL server side. If <code>Unqueued</code> is not to set to <code>1</code>, then the <code>OnSelect</code> (and <code>OnClose</code>) handler will wait until the handler function that called <code>ShowModalAndWait</code> is complete, which is waiting for token from <code>OnSelect</code>, which is waiting for... well you get the idea, and it's not good. Setting <code>Unqueued</code> to <code>1</code> tells Abacus to execute the APL event handler immediately. This allows it to put the token into the pool that satisfies the <code>⎕TGET</code> in <code>ShowModalAndWait</code>. The token value, the name or caption of the button, is returned by <code>ShowModalAndWait</code>.</p>
        <p>Note the advantage of having an APL DOM that can store all kinds of useful info like  <code>Tid</code>, <code>Unqueued</code>, and <code>Name</code> - none of which are in the browser DOM.   </p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2024 Paul S. Mansour</p>
    </footer>
  </body>
</html>
