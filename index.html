<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <h3>"You don't know how bad your code is until you write about it."</h3>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/modal-dialog-boxes-progressbar-more">Modal
            Dialog Boxes 5: More on ProgressBar</a>
          </h1>
          <h2>May 18, 2024</h2>
        </header>
        <p>The <code>ProgressBar.Run</code> operator, so far, handles iterative processes; we effectively have a loop, whether implemented using the each operator or recursion. This gives us the opportunitiy to check for a <em>Pause</em> click on each iteration, to cleanly pause the process, and clean up if the operation is canceled.</p>
        <p>Sometimes we have a potentially long running process that is not itererative, or it is iterative but we don't want to bother with refactoring it to fit the needs of the <code>Progress.Run</code> operator. We want to put up a spinner or <a href="https://www.w3schools.com/howto/howto_css_loader.asp">loader</a> - and provide a cancel button to kill the process.</p>
        <p>The HTML <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/progress">progress element</a> provides an oscillating bar when no <code>max</code> attribute is set, giving us a JavaScript-free and CSS-free spinner.</p>
        <p>For this case we can wrap our long running code with the <code>Start</code> and <code>Stop</code> functions: </p>
        <pre><code>_←d Progress.Start ''
...
... your code here
...
_←d Progress.Stop ''
</code></pre>
        <p>The <code>Start</code> function puts up a modal dialog, but does not wait:    </p>
        <pre><code>Start←{
     c←⍵,(0=≢⍵)/'Working...'
     e←A.New'dialog'
     e.class←'progress-bar'
     e.id←'progress-bar'
     e.TID←⎕TID
     h1←e A.New'h1'c
     p←e A.New'progress'
     p.id←'progress'
     b←e A.New'button' 'Cancel'
     b.id←'Cancel'
     b.Unqueued←1
     b.Onclick←A.FQP'OnCancel'
     _←⍺ A.ShowModal e
     0
 }
</code></pre>
        <p>And <code>Stop</code> just closes the dialog:</p>
        <pre><code>Stop←{
     d←⍺ A.GetElementById'progress-bar'
     ⍺ A.DeleteElement d
 }
</code></pre>
        <p>In the <code>Start</code> function the thread id of the current process is noted in the component, so when <em>Cancel</em> is pressed, we can kill it:</p>
        <pre><code>OnCancel←{
     d←⍵.CurrentTarget A.GetNearest'dialog'
     _←⎕TKILL d.TID
     ⍵.Document A.DeleteElement d
 }
</code></pre>
        <p>This is a fairly crude technique, but useful in some circumstances.</p>
        <p>There is another progress bar case that we have not handled. Consider a process of N discrete but non-iterative steps. As the code is running through these N steps, we want to provide feedback to the user about where we are in the process, and allow the process to be cancelled. For this we will need something like <code>Begin</code>, <code>Update</code> and <code>End</code> functions to sprinkle throughout our code.  </p>
        <p>In addition we may want to consider what happens if and when these various processes are scripted and have no user interaction. </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/modal-dialog-boxes-progressbar">Modal Dialog
            Boxes 4: ProgressBar</a>
          </h1>
          <h2>May 14, 2024</h2>
        </header>
        <p>Implementing a general purpose, easy-to-use progress bar presents some challenges. Let's look at an attempt. The Abacus <a href="https://github.com/the-carlisle-group/Abacus/tree/master/APLSource/Main/ProgressBar">ProgressBar</a> is designed to handle  iterative processes where the number of iterations may or may not be known ahead of time. In either case, we want to provide some feedback on each iteration as well as the ability to cancel the process.</p>
        <p>Rather than providing a <em>Cancel</em> button on the progess bar element, which would arguably require an "are-you-sure" confirmation, we provide a <em>Pause</em> button, which  pauses the operation between two iterations. This gives us the opportunity to add a bit more functionality, without additional complexity in the UI.  When <em>Pause</em> is clicked, the user is then offered two choices, <em>Cancel</em> and <em>Resume</em>, and optionally a 3rd choice: <em>Truncate</em>.  The <em>Cancel</em> option cancels the entire operation without further ado. The <em>Resume</em> option restarts the process at the next iteration. The <em>Truncate</em> option treats the last completed iteration as the final iteration and continues the operation. It simply ignores and does not process the remaining iterations. This option is only relevant for certain types of operations. For example, when importing a CSV file, the user may decide that reading a few million rows from a large file is sufficient for his purposes.</p>
        <p>The progress bar is implemented with a monadic operator, <code>Run</code>. This operator  puts up a progress element with a <em>Pause</em> button, runs the iterations, allows the user to cancel the operation, and provides a useful result when control returns to the calling function. Here is the syntax:  </p>
        <pre><code>      R←Y F ProgressBar.Run X
</code></pre>
        <p>The left argument <code>Y</code> is the document object. The left operand <code>F</code> is a function that implements the looping task at hand. <code>X</code> is a namespace provided as a right argument to <code>F</code>. </p>
        <p>The namespace <code>X</code> must contain 3 properties: <code>Caption</code>, <code>Iterator</code> and <code>Status</code>. The <code>Caption</code> is a string specifying the title of the progress bar dialog box. The <code>Iterator</code> property is a vector. If the iteration vector is empty, the process is deemed <em>indeterminate</em>. We don't know how many iterations there may be. Otherwise the length of <code>Iterator</code> is the number of iterations, known ahead of time, and the process is deemed <em>determinate</em>. In the determinate case, the <code>Status</code> property is a vector of char vectors the same length as <code>Iterator</code>. In the indeterminate case, <code>Status</code> is a simple vector that should be reset inside <code>F</code> on every iteration.   </p>
        <p>The namespace <code>X</code> may, and often will, contain all sorts of other variables and references that are needed to support the execution of <code>F</code>. </p>
        <p>The iteration vector may be an array of any type of values. Associated with the iteration values are iterations numbers, given by <code>⍳≢X.Iterator</code>. For the determinate case, the iteration <em>number</em> (not the value) is provided as the left argument to <code>F</code>. </p>
        <p>In the indeterminate case the result of <code>F</code> is a return code of <code>0</code> if another iteration is required, or <code>1</code> if it is not. There is no other return value. Data accumulation is accomplished by either writing to file or by accumulating an array inside <code>X</code>. In the determinate case, the result of <code>F</code> may be any useful value. </p>
        <p>The result <code>R</code> (of <code>ProgressBar.Run</code>) is a scaler for the indeterminate case, and a two item vector for the determinate case. In both cases the first element of <code>R</code> is <code>0</code> if all itererations are executed, <code>1</code> if cancelled, and <code>2</code> if truncated. For determinate processes, the second element is an array of the result of each call to <code>F</code>.</p>
        <p>Let's go to the code:</p>
        <pre><code>Run←{
     p←New ⍵.Caption ⍵.Iterator
     _←⍺ A.ShowModal p
     op←⍎(0=≢⍵.Iterator)⊃'Determinate' 'Indeterminate'
     r←p ⍺⍺ op ⍵
     r⊣A.DeleteElement p
 }
</code></pre>
        <p>In the <code>Run</code> operator, the first thing we do is create the dialog element (<code>New</code>) and display it (<code>ShowModal</code>). Next we have to pick the appropriate sub-operator. The techniques are different for the two cases. For the determinate case, we use the <code>each</code> operator (<code>¨</code>) to execute iteration:</p>
        <pre><code>Determinate←{
     b r←↓⍉↑(⊂⍺ ⍵)⍺⍺{
         p w←⍺
         p.Cancel:1 0
         c←p Pause 0
         c≡'Cancel':1 0⊣p.Cancel←1
         c≡'Truncate':2 0⊣p.Cancel←1
         _←p Update ⍵⊃w.Status
         r←⍵ ⍺⍺ w
         0 r
     }¨⍳≢⍺.Iterator
     (⌈/b)(r/⍨b=0)
 }
</code></pre>
        <p>First we check if <em>Cancel</em> has been previously pressed. If so, there is nothing to do, and we get out. (Note that we always run the inner function N times if there are N iterations, even if the user has canceled). Next we run the <code>Pause</code> function to see if the user has pressed <em>Pause</em>:</p>
        <pre><code>Pause←{
     ~⍺.Pause:'Resume'
     ⍺.Pause←0
     t←'Process paused'
     c←''
     b←'Cancel' 'Resume' 'Truncate'
     ⍺.Document A.ConfirmBox.Show t c b
 }
</code></pre>
        <p>If the user has not clicked <em>Pause</em>, we exit, resuming the iterations. If the user has pressed Pause, we put a confirmation box and wait. Back in the <code>Determinate</code> operator we inspect what the user has selected in the confirmation box, exiting if <em>Cancel</em> or <em>Truncate</em>. Otherwise we update the status and execute the iteration function, the left operand of <code>Run</code>.</p>
        <p>The indeterminate operator is a bit simpler (hmm, why is that?):</p>
        <pre><code>Indeterminate←{
     _←⍺ Update ⍵.Status
     c←⍺ Pause ⍵
     c≡'Cancel':1
     c≡'Truncate':2
     ⍺⍺ ⍵:0
     ⍺ ∇ ⍵
 }
</code></pre>
        <p>Here we update the status before checking if the user clicked <em>Pause</em>. This is because in the indeterminate case, the status of an iteration is known after the iteration completes, while in the determinate case the status is known before the iteration is executed - usually. We check for `<em>Pause</em> etc., just as in the determinate case. We then run the iteration function, exiting if it returns a <code>1</code>, and continuing on to the next iteration via recursion otherwise.</p>
        <p>Regardless of the iteration technique, be it looping, recursion, or the each operator, the fact that the argument to <code>F</code> is a namespace allows us to easily maintain and update state, and accumulate results, between iterations.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/uncle-bob-and-the-primeagen">Uncle Bob and
            The Primeagen</a>
          </h1>
          <h2>May 7, 2024</h2>
        </header>
        <p>Recently the genial Robert "Uncle Bob" Martin sat down with the always entertaining Primeagen for an <a href="https://www.youtube.com/watch?v=UBXXw2JSloo">interview</a>.  Given The Primeagen's well-known aversion to TDD and short functions, it was bound to be a spirited conversation, and indeed it was.</p>
        <p>I'm fully sympathetic to the idea that it's hard and often counterproductive (if not impossible) to do full TDD on a new project.  What I don't get is The Primeagen's gripe about 100% code coverage. He asks Uncle Bob about testing the summing of the elements of an array. Uncle Bob explains that he would not write a specific test for that, but that the code would be tested indirectly; there would be a test on a method or function that  has the line that sums the array. Or even a test higher up the stack. But the line would get executed in the test suite somewhere. In the interview, the Primeagen doesn't seem to understand that.  </p>
        <p>In response to The Primeagen's repeated questions about "what to test", Uncle Bob brings up Kent Beck: test anything and everything that can break. In APL, that's pretty much every line of every function. I assume a similar situation in any interpreted language.</p>
        <p>Consider the line: </p>
        <pre><code>      c←a+b
</code></pre>
        <p>This can fail in at least 5 different ways, including <code>VALUE ERROR</code>, <code>DOMAIN ERROR</code>, <code>RANK ERROR</code>, and <code>LENGTH ERROR</code>.  Heck, consider:</p>
        <pre><code>      v←1   
</code></pre>
        <p>This line can fail!</p>
        <p>Now, as Uncle Bob points out, it would be silly to write a test for every line of code. But every line of code should be executed in the tests, because every line of code can break. There is no excuse for less than 100% code coverage. </p>
        <p>Please note that I have written a lot of code that has a lot less than 100% coverage, even 0% coverage, and I have no excuse.  </p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2024 Paul S. Mansour</p>
    </footer>
  </body>
</html>
