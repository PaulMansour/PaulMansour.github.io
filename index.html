<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/testing-guis-wrestling-with-events">Testing
            GUIs: Wrestling with Events</a>
          </h1>
          <h2>August 18, 2023</h2>
        </header>
        <p>GUI applications are complicated. Callbacks are attached to events and processed by <code>⎕DQ</code>. Events can get queued up by their nature. For example, a single user action on a grid can fire a <code>GridKeyPress</code> event, followed by a  <code>CellChange</code> event followed by a <code>CellChanged</code> event. Events can also get queued up because a callback explicity calls <code>⎕NQ</code> adding another event to the queue. During the normal course of using the application, this all just just works (hopefully!). However, the moment we try to write automated tests that exercise the GUI, the complexity manifests itself.</p>
        <p>The first problem that arises is that when testing, we cannot run <code>⎕DQ</code> at all. If we <code>⎕DQ</code> the main form, we cannot then run a test function.</p>
        <blockquote>
          <p>Note that it is possible to either write your tests into the application itself, so that they run under the main <code>⎕DQ</code> of the application, or to run  each test under a temporary invocation of <code>⎕DQ</code> - by using <code>⎕NQ</code> to put a test into the queue. But these techniques are overly complicated and add nothing useful. They make writing and tracing tests more difficult, and they don't solve  a secondary problem of model subforms like dialog boxes.</p>
        </blockquote>
        <p>This is easy to solve. We just use the implicit <code>⎕DQ</code> that runs when the session is wait mode. We should also avoid all uses of <code>⎕DQ</code> to wait on modal forms. A simply <code>TestMode</code>  flag in our application fascilitates this. </p>
        <p>The second and more difficult problem to solve is that in a GUI test function we want to fire events and make assertions, and fire more events and make more assertions, and this must behave exactly as it does in a runtime situation under <code>⎕DQ</code>. But firing a single event can stack up multiple events, and these will not fire in real time during the execution of the test function. This is because when the test function runs, there is no opportunity for queued up callbacks to execute. When the interpreter drops into immediate execution mode, then the queued up events can be processed by the session's implicit <code>⎕DQ</code>. We have the strange situation where an assertion fails and the test stops, and then the assertion can be reexecuted and it passes, as the very fact of failure has allowed the interpreter to pause and process the queued up events. How then is this problem solved? We must have a way of giving the interpreter an opportunity on every line of the test function, or at least on every line that fires an event, to process all of the events that may occur as a result of the primary event that was fired.</p>
        <p>The magic that does this is:</p>
        <pre><code>Fire←{
     _←⎕NQ ⍵
     0⊣{⎕DQ ⍵⊣⎕NQ ⍵ 999}¨⍺.DequeueTimes⍴⍺ 
 }  
</code></pre>
        <p><code>⍺</code> is the primary form.    </p>
        <p>We fire the primary event with <code>⎕NQ</code>. We then enter and exit an explict <code>⎕DQ</code> as many times as necessary to process the queued up events right on the spot. The <code>⎕NQ</code> fires a 999 event which is set to exit <code>⎕DQ</code>.  It is not always clear    how many times we must enter and exit <code>⎕DQ</code> to clear the queue. And of course it is different for different primary events. Luckily it appears we can set it to an arbitrarily high number, say 10, with no performance penalty.</p>
        <p>The sample GUI app in Provanto contains an example of explicitly using <code>⎕NQ</code> in callbacks to create a chain of 7 events. It can be observed that we must enter and exit <code>⎕DQ</code> exactly 7 times to process all the events. In a real-life large GUI application the magic number appeared to be 4. </p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/testing-guis">Testing GUIs</a>
          </h1>
          <h2>August 14, 2023</h2>
        </header>
        <p>I'm currently in the process of extracting a GUI testing framework from a private project  and adding it to <a href="https://github.com/the-carlisle-group/provanto">Provanto</a>.  Writing automated GUI tests for <code>⎕WC</code> applications is somewhat of a dark art. Nowhere is the principle of Test Driven Development (TDD) more important than with GUI programming and <code>⎕WC</code>. Writing GUI code without forethought will invariably yield code that is simply untestable. Of course we don't have forethought until we have written a bunch of GUI code first, and then attempted to write test code,  so we are generally doomed to have untestable GUI code that must be rewritten.</p>
        <p>Future posts will explore the underlying framework code in detail. Here we just take a look at the overall basics, what a test function looks like, and how to write one. Once the dark art is mastered and buried in the framework, and we learn how to write testable GUI apps, the tests themselves are clean, neat, and simple to write, read, and maintain.</p>
        <p>Testing a GUI starts with a reference to the primary form object of an application. The <code>Init</code> function takes this form, instantiates a few properties in it, and then injects a few functions back into the test namespace:</p>
        <pre><code>Init←{
     ⍵.on999←1
     ⍵.DequeueTimes←4
     ⍵.ActionDelay←0
     ⍵.KeyPressDelay←0
     t←⊃⎕RSI
     t.Keys←KeySpace 0
     t.G←⎕THIS
     _←⍵ Fix¨API 0
     0
 }
</code></pre>
        <p>In addition to <code>Assert</code> and <code>Try</code> (the functions that Provanto injects into the test space), we now will have two more reserved words: <code>Enter</code> and <code>Get</code>. Both of these functions are bound with the reference to the form, so it is not needed as an argument.</p>
        <p>The <code>Init</code> function may be called in the <code>Startup</code> function for a suite of tests, or  directly in a test function.  </p>
        <p>Provanto includes a sample GUI application and a few tests to show how it is done. A typical GUI test fires events on objects, then inspects the state of the GUI and the application and makes assertions. Let's take a look at one:</p>
        <pre><code>TestAllowDigitsProperty←{
     s←GetAppState 0
     e←Get'Name'
     Assert~s.AllowDigits:
     Enter'Name' 'A12B345C':
     Assert e.Text≡'ABC':
     Enter'AllowDigits':
     Assert s.AllowDigits:
     Enter'Name' '12345':
     Assert e.Text≡'ABC12345':
     Enter'AllowDigits':
     Assert~s.AllowDigits:
     0
 }
</code></pre>
        <p>This function assumes that <code>Init</code> has already been called. <code>GetAppState</code> is an application specific helper function that returns a namespace with a few variables representing the state of the application.  Of course in a real application, the application state may be represented by a complex object model, or a folder on disk, or both and more. </p>
        <p>The <code>Get</code> function takes the name of a GUI object and returns a reference to it, providing access to the state of the GUI.</p>
        <p>The <code>Enter</code> function allows us to fire events at the GUI.  To click on a push button or menu item, or to change the state of a radio button or check box, we simply call the <code>Enter</code> function with the name of the object. To enter text in an edit box, we call <code>Enter</code> with both the name of the object and the text to enter.</p>
        <p>We can also fire specific events. For example, to double click on the <code>Name</code> edit object:</p>
        <pre><code>Enter 'Name' (⊂'MouseDblClick')
</code></pre>
        <p>A full event message may be provided as well:</p>
        <pre><code>Enter 'Name' ('KeyPress' 'RC' 0 39 0) 
</code></pre>
        <p><code>KeyPress</code> events are very common, so a namespace with <code>KeyPress</code> events is provided, to make it easy to fire specific keys on objects:</p>
        <pre><code>Enter 'Name' Keys.RightCursor  
</code></pre>
        <p>The above test is implement as a dfn, and thus naked guards are necessary to prevent the function from exiting on the lines that lack an assignment, specifically the lines calling <code>Enter</code>. We could of course assign a useless result instead, but it adds a lot of clutter. The naked guard is already used on the lines making assertions, so it's not that much of stretch, but some might find it objectionable. I'm not entirely sure how I feel about it. A trad function works just as well, arguably cleaner if there are not too many local variables:</p>
        <pre><code> z←TestAllowDigitsProperty x;s;e
 s←GetAppState 0
 e←Get'Name'
 Assert~s.AllowDigits
 Enter'Name' 'A12B345C'
 Assert e.Text≡'ABC'
 Enter'AllowDigits'
 Assert s.AllowDigits
 Enter'Name' '12345'
 Assert e.Text≡'ABC12345'
 Enter'AllowDigits'
 Assert~s.AllowDigits
 z←0 
</code></pre>
        <p>The main point is that both of these functions, the dfn and trad fn, have little to no extraneous code. The functions are easy to write and read. The two API functions <code>Enter</code> and <code>Get</code> provide almost all that is needed. The test functions are also easy to trace, and you can see exactly what the GUI is doing while stepping through them.</p>
      </article>
      <article>
        <header>
          <h1>
            <a href="/posts/boolean-techniques">Boolean Techniques</a>
          </h1>
          <h2>May 13, 2023</h2>
        </header>
        <p>In a recent post titled <a href="https://www.sacrideo.us/suggestivity-and-idioms-in-apl/">Suggestivity and Idioms in APL</a> on his blog <a href="https://www.sacrideo.us/tag/apl/">Fastidious Elegance</a> Arron Hsu enumerates all the permutations and combinations of logical pairwise reductions on Boolean vectors. There are 10 scalar dyadic relational functions and Aaron throws in <code>⊣</code> and  <code>⊢</code> as well for total of 12 functions. With the catenation of 1 or 0 on the front or the back, to keep the result the same shape as the input, there are <code>12×2×2</code> or <code>48</code> possible combinations. </p>
        <p>It would be convenient to be able to describe in short terms what each of these Boolean transformations does. If we can't meaningfully name them, we probably cannot effectively use them. If we are going to search for these expressions on, say, <a href="https://aplcart.info">APL Cart</a>, we need to have some way to describe them.</p>
        <p>In his 1987 book <strong>APL - Advanced Techniques and Utilities</strong>, Gary Bergquist uses the terms <em>maps</em> and  <em>poles</em> to facilitate discussion of Boolean vectors and techniques: </p>
        <blockquote>
          <p>A "maps" vector is a Boolean vector which consists of sets of contiguous 1s (1-maps) separated by one or more 0s, (0-maps). For example, the following bit vector contains 3 1-maps and 4 0-maps:</p>
          <pre><code>0 0 1 1 1 1 0 0 0 1 1 0 0 1 1 1 1 1 0 0
</code></pre>
          <p>A "leading" 1-poles vector is a Boolean vector which consists of pairs of 1s  separated by zero or more 0s. The 1's are called "poles".  The left pole in each pair may be viewed as the starting element of a set of contiguous elements.  The right pole in each pair may be viewed as the next element beyond the ending element of the set. For example, the following bit vector contains 3 pairs of leading 1-poles:</p>
          <pre><code>0 0 1 0 0 0 1 0 0 1 0 1 0 1 0 0 0 0 1 0  
</code></pre>
          <p>Notice that 1-maps and leading 1-poles are alternative means of conveying the  same information. Basically they identify spans of contiguous elements. 1-maps do so by using 1s to flag the elements within the spans. Leading 1-poles do so by using 1s to flag the starts of spans and the starts of non-spans (hence the  word "leading").</p>
        </blockquote>
        <p>We can flip the bits and discuss 0-maps and leading 0-poles as well. These terms do not represent any inherent properties of Boolean vectors, but rather an interpretation of what the 1's and 0's mean. The same Boolean vector could be a 1-maps vector in one context and a 1-poles vector in another context.   This, however, does not lessen the usefulness of the terms. With this terminolgy in hand, we can interpret  <code>≠\</code> as converting leading 1-poles to 1-maps, and <code>=\</code> as converting leading 0-poles to 0-maps.</p>
        <p>How many of Aaron's 48 permutations can be succinctly described with this lexicon? Gary defines and names 6 transformations, using shift-and-compare techniques that pre-date the introduction of n-wise reduction. We can find the corresponding 6 transformations in Aaron's 48 by inspection:  </p>
        <table>
          <thead>
            <tr><th class="left">            </th><th class="left">            </th><th class="left">                               </th></tr>
          </thead>
          <tbody>
            <tr><td class="left"> <code>R≠¯1↓0,R</code> </td><td class="left"> <code>{2≠/0,⍵}</code> </td><td class="left"> 1-maps to leading 1-poles     </td></tr>
            <tr><td class="left"> <code>R=¯1↓1,R</code> </td><td class="left"> <code>{2=/1,⍵}</code> </td><td class="left"> 0-maps to leading 0-poles     </td></tr>
            <tr><td class="left"> <code>R&gt;¯1↓0,R</code> </td><td class="left"> <code>{2&lt;/0,⍵}</code> </td><td class="left"> 1-maps to first 1 bits        </td></tr>
            <tr><td class="left"> <code>R≥¯1↓1,R</code> </td><td class="left"> <code>{2≤/1,⍵}</code> </td><td class="left"> 0-maps to first 0 bits        </td></tr>
            <tr><td class="left"> <code>R∨¯1↓0,R</code> </td><td class="left"> <code>{2∨/0,⍵}</code> </td><td class="left"> extend 1-maps to right by 1   </td></tr>
            <tr><td class="left"> <code>R∧¯1↓1,R</code> </td><td class="left"> <code>{2∧/1,⍵}</code> </td><td class="left"> extend 0-maps to right by 1   </td></tr>
          </tbody>
        </table>
        <p>From these, six related ones jump right out:</p>
        <table>
          <thead>
            <tr><th class="left">            </th><th class="left">            </th><th class="left">                                </th></tr>
          </thead>
          <tbody>
            <tr><td class="left"> <code>R≠1↓R,0</code>  </td><td class="left"> <code>{2≠/⍵,0}</code> </td><td class="left"> 1-maps to trailing 1-poles     </td></tr>
            <tr><td class="left"> <code>R=1↓R,1</code>  </td><td class="left"> <code>{2=/⍵,1}</code> </td><td class="left"> 0-maps to trailing 0-poles     </td></tr>
            <tr><td class="left"> <code>R&gt;1↓R,0</code>  </td><td class="left"> <code>{2&gt;/⍵,0}</code> </td><td class="left"> 1-maps to last 1 bits          </td></tr>
            <tr><td class="left"> <code>R≥1↓R,1</code>  </td><td class="left"> <code>{2≥/⍵,1}</code> </td><td class="left"> 0-maps to last 0 bits          </td></tr>
            <tr><td class="left"> <code>R∨1↓R,0</code>  </td><td class="left"> <code>{2∨/⍵,0}</code> </td><td class="left"> extend 1-maps to left by 1     </td></tr>
            <tr><td class="left"> <code>R∧1↓R,1</code>  </td><td class="left"> <code>{2∧/⍵,1}</code> </td><td class="left"> extend 0-maps to left by 1     </td></tr>
          </tbody>
        </table>
        <p>Aaron may be a bit optimistic when he writes that <em>almost all of the binary relations that we can imagine in use here find some meaningful interpretation</em>, but here we have 12 simple, visually suggestive, well-named expressions using the language of maps and poles. That's a good start. Can we find more?</p>
      </article>
      <h2>
        <a href="/posts">More posts...</a>
      </h2>
    </main>
    <footer>
      <p>Copyright 2023 Paul S. Mansour</p>
    </footer>
  </body>
</html>
