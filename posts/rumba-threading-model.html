<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><link href="/ThorntonMelon.css" rel="stylesheet"></link></head><body><header><h1>Tool of Thought</h1><h2>APL for the Practical Man</h2><h3>"Don't chase tech. Chase fun." - Gunpei Yokoi</h3><nav><a href="/">Home</a><a href="/posts">Posts</a><a href="/projects">Projects</a><a href="/donts">Don'ts</a><a href="/links">Links</a><a href="/about">About</a></nav></header><main><article><header><h1><a href="/posts/rumba-threading-model">Rumba Threading Model</a></h1><h2>July 28, 2024</h2></header><p>In this post we   review the current <a href="https://github.com/the-carlisle-group/Rumba">Rumba</a> threading model, consider an alternative, and take a look at how <a href="https://github.com/Dyalog/Jarvis">Jarvis</a> does it.</p><p>Currently in Rumba, the threading model is as follows. The <em>server event loop</em>, calling <code>DRC.Wait</code>, handles all events on the server and all sockets. If the event is a <code>Connect</code> event, a new connection space is established and a thread is spawned. This new <em>connection thread</em> is immediately waiting, in a <em>connection event loop</em>, using <code>⎕TGET</code>, for events passed to it from the server event loop using <code>⎕TPUT</code>.  All other events are either handled immediately in the server event loop, or passed off for handling to the appropriate connection thread. For example, the <code>Error</code> event is handled immediately in the main thread, but an <code>HTTPChunk</code> event is passed to the appropriate connection thread.</p><p>When a connection thread has a complete message, it will service it in the same connection thread (not spawning a new thread). Thus it will respond to multiple messages from the same client,  in proper order, with no additional thread coordination. </p><p>Alternatively, we can use the <code>ConnectionOnly</code> property of Conga, and have the server event loop only handle <code>Connect</code> events. As above, a new connection space is established and  connection thread is spawned. In this case, however, the connection event loop is wrapped around another call to <code>DRC.Wait</code>. There is no need for <code>⎕TGET</code> or <code>⎕TPUT</code>. The connection event loop is now tasked with directly handling events from Conga, via <code>DRC.Wait</code>, but only for the specific connection. We have delegated some logic to Conga itself. </p><p>Let's call the first technique SCW (Single Conga Wait) and the alternative MCW (Multiple Conga Wait) </p><p>What are the pros and cons of these two techniques? Here are a few:</p><p>With SCW, we have the option of handling any event either in the main thread or in the appropriate connection thread. All events are received in the main thread, and we can process them there or chuck them to a waiting connection thread. With MCW the die is cast. All events other than <code>Connect</code> (and <code>Error</code>  and <code>Timeout</code>?) must be handled in connection threads. This may increase thread coordination problems. This might be a major advantage for SCW.</p><p>With SCW, every time around the server event loop, we must retrieve the connection space (if it's not a <code>Connect</code> event) from the connection name as returned from <code>DRC.Wait</code>. With MCW,  we have the connection space in hand on the Connect event, and it is passed  to the connection event loop. So we never need to look it up or retrieve it. This is probably a minor advantage, if any, for MCW in speed, but maybe a major advantage in coding clarity.  </p><p>With SCW we only receive <code>Timeout</code> events on the server as a whole. With MCW we can receive them on the server and on individual connections (I think. I don't know this for a fact.) Currently in Rumba with SCW we track the timestamp on the latest activity on a connection, so we can close idle connections. This could be handled with less fuss with MCW.</p><p>It seems that MCW might lead to simpler APL code. Events are either server events or connection events, and MCW lets Conga sort that part out.    </p><p>Jarvis, like Rumba currently, uses a single call to  <code>DRC.Wait</code>. However, instead of spawning a thread on each connection, it spawns a thread on each (HTTP) event. Then when the message is complete, it handles the request in whatever the current thread is. Thus a typical HTTP request takes 2 threads, one for the header, and one for the body which is then  used to handle the request and prepare the response. A chunked request requires a thread for every single chunk, so a request with 100 chunks will require 102 threads, the extra 2 for the header and trailer) These additional threads have very little to do, and will be very short-lived, so that's not a big downside. However, the additional threads require more thread coordination, including the use of both <code>:Hold</code> and <code>⎕TGET/⎕TPUT</code>. </p><p>It's not at all clear if there are any performance difference between these three models.</p></article></main><footer><p>Copyright 2021-2025 Paul S. Mansour</p></footer></body></html>
