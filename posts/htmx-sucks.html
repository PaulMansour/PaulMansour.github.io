<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><link href="/ThorntonMelon.css" rel="stylesheet"></link></head><body><header><h1>Tool of Thought</h1><h2>APL for the Practical Man</h2><h3>"You don't know how bad your design is until you write about it."</h3><nav><a href="/">Home</a><a href="/posts">Posts</a><a href="/projects">Projects</a><a href="/donts">Don'ts</a><a href="/links">Links</a><a href="/about">About</a></nav></header><main><article><header><h1><a href="/posts/htmx-sucks">It's Very Sucky!</a></h1><h2>January 8, 2025</h2></header><img alt="Very Sucky" src="/images/VerySucky.jpg"></img><blockquote><p>We don't often add a new tool to our development stack, but when we do it's htmx.</p></blockquote><p>Some years back we started a side project to implement a RESTful api and corresponding web application. Knowing virtually nothing of how the web worked, we remember being shocked and outraged that browsers would not, and would probably never, implement PUT and DELETE. There were some reasonable arguments put forth at the time as to why this should be so, and perhaps they are still reasonable. Anyway, we took the  not uncommon path of putting hidden values our html forms for the real method we wanted the server to process. Then one day, around the summer of 2020,  we ran into this mild-mannered, unassuming professor in Bozeman who mentioned he was the developer of a JavaScript project called <a href="https://htmx.org/">htmx</a> that, what do you know, provided a way for the browser to do PUTs and DELETEs. What are the odds!  We immediately investigated htmx and made a branch in our project to start playing around with it. More pressing work soon got in the way, and the effort was abandoned for five years. Now however we are back looking at htmx, which has gone from internet obscurity to Github sensation in the intervening years. And the mild-mannered professor has transformed into a Montana wild man.        </p><p>Deceptively simple, htmx is actually quite complex. There are many ways to do things. We need to extract some principles or techniques and narrow down the number of features, parameters, and options that we are going to use.</p><p>There is this distinction between in-band and out-of-band swaps, which we find not particulary useful. More useful is the distinction between <strong>request-driven</strong> and <strong>response-driven</strong> swaps. The attributes <code>hx-swap</code>, <code>hx-target</code>, and [<code>hx-select-oob</code>](https://htmx.org/attributes/hx-select-oob/) are all request-driven. These sit in the HTML in the DOM in the browser along side <code>hx-post</code> and its companions. They are known to the browser before the request is fired off,  and instruct htmx how to handle the response.</p><p>On the other hand, <code>hx-swap-oob</code> is a response-driven attribute. It has no purpose before the request. This attribute is received in the response body in the HTML, processed by htmx, stripped out of the HTML, and then thrown away never to be seen again. In this sense it functions like a response header. In fact it could easily be implemented as a response header that contained a list of ids.                                                   </p><p>Then there are actual htmx response headers that convert a request-driven swap to a response-driven swap. <code>HX-Reswap</code>, <code>HX-Retarget</code> and <code>HX-Reselect</code> let the server  overide the values of <code>hx-swap</code>, <code>hx-target</code>, and <code>hx-select</code> respectively. </p><p>In addition there is a core htmx extension named <a href="https://htmx.org/extensions/response-targets/">Response Targets</a>. This supports attributes in the form of <code>hx-target-[code]</code> where <code>[code]</code> is a three digit HTTP response code. This provides another way to implement response-driven swaps.</p><p>So response-driven swaps can be implemented either as header-driven overrides or as content-driven HTML, or using  the Response Targets extension or some unholy mixture of the three.                            </p><p>The single most obvious advantage of response-driven swaps is that they are dynamic; the server receives a request and can define what gets swapped where back on the client, depending on whatever is appropriate at the moment. The response can contain zero, one or many HTML fragments to be swapped in. </p><p>The advantage of relying only on <code>hx-swap-oob</code> for swaps is that all the logic is in one place. We know exactly what is going to happen by looking at the content of the response. There is no need to inspect the response headers or the client side HTML. </p><p>Otherwise there is potentially logic in three places: the HTML in the browser, the headers in the response, and the content of the response. All of these directives scattered about can interact and conflict. There are even configuration settings to tweak the default behavior.</p><p>It is possible to use <code>hx-select-oob</code> to somewhat mimic the flexibility of <code>hx-swap-oob</code>. We can specifiy multiple ids, and the server can respond with zero of more fragments with those ids. In this case the client must know ahead of time the set of ids that might be swapped, but the server is free to respond with none, some, or all. </p><p>Now let's say we want to take it up a notch and add a little JavaScript. On the client side  we could use <code>hx-on*</code> to fire off a JavaScript snippet after the request. Or, on the server side, we can use one of the response headers <code>HX-Trigger</code>, <code>HX-Trigger-After-Settle</code>, or <code>HX-Trigger-After-Swap</code> to fire an event when response is received.   Alternatively, we can just include a script element in the response.</p><p>In other words, <code>hx-swap-oob</code> can replace using all of:</p><pre><code>hx-swap
hx-target
hx-select    
hx-select-oob
HX-Reswap
HX-Retarget
HX-Reselect
HX-Trigger*
hx-target-[code]
hx-on*
htmx.config.[various]
</code></pre><p>No doubt there are use cases for all of these attributes and headers, but if one is in total control of the back end, it seems simpler to just use <code>hx-swap-oob</code>.</p><p>Let's make all this a little more concrete. Consider a button that fires off a POST. The basic pattern is a request-driven swap using <code>hx-target</code>:</p><pre><code>b←New 'button'
b.hx_post←'/SomeURL'
b.hx_target←'#MyId'
</code></pre><p>Let the response body be:</p><pre><code>&lt;div&gt;
   This is the response.
&lt;/div&gt;
</code></pre><p>The response body is swapped into the element with id <code>MyId</code>. There is only one target element, and the entire body of the response is swapped in to this target. The target must be known and specified before the request is sent off. </p><p>Multiple elements may be swapped in to different locations by using <code>hx-select-oob</code>:</p><pre><code>b←New 'button'
b.hx_post←'/SomeURL'
b.hx_select_oob←'#MyId1,#MyId2,#MyId3'
</code></pre><p>Let the response body be:</p><pre><code>&lt;div id=MyId1&gt;One&lt;/div&gt;
&lt;div id=MyId2&gt;Two&lt;/div&gt;
&lt;div id=MyId3&gt;Three&lt;/div&gt;
</code></pre><p>These are called out-of-band swaps. The request is again driving the swap. It specifies a list of ids that <strong>may</strong> be swapped. In order to swap an element, the response must have an element with a corresponding id. The response does not need to contain all or indeed any of the ids specified in <code>hx-select-oob</code> If there is no corresponding id in the response, it's a no-op. This allows for a little bit of response-driven swapping. The server decides what it wants to swap, but within the universe of ids explicitly specified by the request. </p><p>A basic in-band swap may be combined with an array of out-of-band swaps, using <code>hx-target</code> and <code>hx-select-oob</code> together. </p><p>We can move the explicit list of ids for out-of-band swaps from the client to the server by using <code>hx-swap-oob</code> in the response:</p><pre><code>b←New 'button'
b.hx_post←'/SomeURL'
</code></pre><p>Let the response body be:</p><pre><code>&lt;div hx-swap-oob='true' id=MyId1&gt;One&lt;/div&gt;
&lt;div hx-swap-oob='true' id=MyId2&gt;Two&lt;/div&gt;
&lt;div hx-swap-oob='true' id=MyId3&gt;Three&lt;/div&gt; 
</code></pre><p>Now the server has complete control over what gets swapped. The server can send any set of ids in the response.                                                               We can combine <code>hx-target</code> and <code>hx-target-oob</code> on the client side, with <code>hx-swap-oob</code> in the response to... confuse ourselves.</p><p>So for now, our strategy is to exclusively use <code>hx-swap-oob</code>, use script tags to execute a little JavaScript if necessary, and to configure htmx to swap on any and all response codes.   </p></article></main><footer><p>Copyright 2021-2025 Paul S. Mansour</p></footer></body></html>
