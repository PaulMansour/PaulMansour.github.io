<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><link href="/ThorntonMelon.css" rel="stylesheet"></link></head><body><header><h1>Tool of Thought</h1><h2>APL for the Practical Man</h2><h3>"Vibe coding since 1987"</h3><nav><a href="/">Home</a><a href="/posts">Posts</a><a href="/projects">Projects</a><a href="/donts">Don'ts</a><a href="/links">Links</a><a href="/about">About</a></nav></header><main><article><header><h1><a href="/posts/input-components">Input Components</a></h1><h2>August 6, 2025</h2></header><p>(Or, How Did We Live Before <code>⎕VSET</code> and <code>⎕VSET</code>?)</p><p>We need some functions to wrap the HTML <code>&lt;input&gt;</code> element. We need inputs for text, numbers, dates check boxes, and pick lists, and thus define the following components:</p><ul><li><code>TextInput</code></li><li><code>NumberInput</code></li><li><code>DateInput</code></li><li><code>CheckBox</code></li><li><code>DropList</code></li></ul><p>Let's look at <code>TextInput.New</code>, as a representative pattern: </p><pre><code>New←{
     d←(⍺ A.New'div')⎕NS(
         'Name' ''
         'Label' ''
         'Value' ''
         'AutocompleteItems' ''
         'OnChange' ''
     )A.InitProps ⍵
     d.class←'TextInput'
     l←d A.New'label'd.Label
     l.for←d.Name
     i←d A.New'input'
     i.value←d.Value
     i.id←d.Name
     d.Onchange←A.FQP'OnChange'
     d
 }
</code></pre><p>Here we have taken advantage of V20's new array notation. This allows us to easily see and modify the allowed properties and their default values, across multiple lines, without repeated catenation, enclosing, etc.' The argument to <code>New</code> may be a namespace, or an array where each  item is either a name/value pair, or just a value. If only a value is provided, then its property name is inferred from its position (like <code>⎕WC</code>). For example, the following two expressions are equivalent:</p><pre><code>      TextEdit.New (Label:'First name:' ⋄ Name:'FirstName' ⋄ Value:'Paul')
      TextEdit.New 'FirstName' ('Value' 'Paul') ('Label' 'FirstName)
</code></pre><p>The <code>InitProps</code> function processes the argument:</p><pre><code>InitProps←{
     ⍝ ⍺ ←→ Default name/value pairs
     ⍝ ⍵ ←→ Given argument
     ⍝ ← ←→ A new space with ⍺ overiddden by ⍵
     d←()⎕VSET ⍺
     9=⎕NC'⍵':d ⎕NS ⍵
     n←⊃¨⍺
     m←n↑⍨≢⍵
     p←m{2∧.=(≢⍵),|≡⍵:⍵ ⋄ ⍺ ⍵}¨⍵
     +d ⎕NS()⎕VSET p/⍨n∊⍨⊃¨p
 }
</code></pre><p>Once we have a namespace with all the user set properties and default properties, all of the property names and values are injected into the root  element of the component. This means that property names must begin with an uppercase letter, to avoid conflict with element attributes like <code>class</code> or <code>onclick</code>, and that the names <code>Tag</code>, <code>Content</code>, and <code>Parent</code> are reserved.  </p><p>If a property is not referenced in the <code>New</code> function, like <code>OnChange</code>, it may also be specified by assignment after the component is created. Setting other properties after the component has been created will generally  require a setter function. For example, to set the <code>Value</code> property requires a call to <code>TextInput.SetValue</code>.    The compondent <code>&lt;div&gt;</code> contains a <code>&lt;label&gt;</code> element and an <code>&lt;input&gt;</code> element. They are tied together explicitly with the <code>for</code> attribute, rather than nesting, in order to provide more options for display purposes, specifically grid and flexbox.    </p><h2>Events</h2><p>For now, each component accepts an <code>OnChange</code> callback function. This is called after Abacus handles the change by synchronizing the browser to the APL DOM, and perhaps formatting the input. In the case of <code>TextInput</code> it's a simple synchronization: </p><pre><code>OnChange←{
     c←⍵.CurrentTarget
     c.Value←⍵.Value
     ⍵ A.Execute'OnChange'
 }
</code></pre><h2>The GetValues and SetValues functions</h2><p>The main Abacus namespace contains <code>GetValues</code> and <code>SetValues</code> for getting and setting multiple values, a typical task given a dialog box with a bunch of inputs. The <code>GetValues</code> function:</p><pre><code> GetValues←{
     ⍝ ⍵ ←→ DOM node
     ⍝ ← ←→ Namespace of Values from ⍵
     e←⍵ GetElementsWith'Name'
     0=≢e:()
     +()⎕VSET(↑e.Name)e.Value
 }
</code></pre><p>...takes an APL DOM node as its argument and returns a namespace containg the values for each input component found within.  The DOM node is searched for elements that have a <code>Name</code> property, and we assume a correpsonding <code>Value</code> property. This search technique could be tightened up if necessary, but for now it's adequate.  </p><p>The <code>SetValues</code> function:</p><pre><code> SetValues←{
     ⍝ ⍺ ←→ Namespace of values
     ⍝ ⍵ ←→ DOM node
     e←⍵ GetElementsWith'Name'
     0=≢e:0
     m←e.Name
     n v←↓⍉↑⍵ ⎕VGET ¯2
     i j←m n⍳¨⊂m∩n
     0=≢i:0
     c←⎕VGET e[i].class
     0⊣e[i]c.SetValue v[j]
 }
~~~   
</code></pre><p>...similarly takes a DOM node as its right argument, but also a namespace of values as its left argment, and populates the inputs in the DOM with the values. <code>SetValues</code> is happy to accept more or fewer values than would be indicated by the DOM, and obly set values that have correpsonding inputs. We must use the  individual <code>SetValue</code> function in each component to set the values.</p></article></main><footer><p>Copyright 2021-2025 Paul S. Mansour</p></footer></body></html>
