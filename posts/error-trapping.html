<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><link href="/ThorntonMelon.css" rel="stylesheet"></link></head><body><header><h1>Tool of Thought</h1><h2>APL for the Practical Man</h2><h3>"We make software the old-fashioned way, we write it."</h3><nav><a href="/">Home</a><a href="/posts">Posts</a><a href="/projects">Projects</a><a href="/donts">Don'ts</a><a href="/links">Links</a><a href="/about">About</a></nav></header><main><article><header><h1><a href="/posts/error-trapping">Error Trapping</a></h1><h2>February 20, 2023</h2></header><p>Once we have written some nice, succinct APL code, it is disheartening to muck it all up with error trapping. There are many techniques, and often we just sling <code>⎕TRAP</code>, <code>:Trap</code>, <code>⎕SIGNAL</code> and error guards willy-nilly. It would be nice have to some tried and true patterns to apply, and extract as much messiness as possible.</p><p>The best error trapping is none at all, or rather, left to functions further up the stack. But if we are providing a package to be used by others, and the API consists of more than utility functions like deleting extraneous blanks, we should provide some minimal distinction between a user error and a bug. This post explores one possible pattern, used in the <a href="https://github.com/the-carlisle-group/Text2Date">Text2Date</a> project.</p><p>For some packages, there is no need to invent new error numbers and  event messages. However, we need a way to distinguish between, say, a length error that we anticipate, and one that we don't.  Two functions will suffice to extract all the needed logic:</p><pre><code>Signal←{
     ⎕SIGNAL⊂('EN'(⍺+500))('Message'⍵)
 }
</code></pre><p>and</p><pre><code>f←ReSignal
f←⎕SIGNAL{
    ⊂('EN'(⍵.EN-500))('Message'⍵.Message)
}
</code></pre><p>The <code>Signal</code> function wraps <code>⎕SIGNAL</code>, and specifies the <strong>error number</strong> and <strong>message</strong> for <code>⎕DMX</code>. The error number is bumped up by an arbitrary multiple of 100 (from 100 to 900), to distinguish it from an unexpected error. So, for example, if the left argument to an API function requires a 1 or 0, to signal a DOMAIN ERROR we might write:</p><pre><code>~⍺∊0 1:11 Signal 'The left argument must be 0 or 1'
</code></pre><p>Note that <code>Signal</code> reverses the arguments of <code>⎕SIGNAL</code>. This is because <code>⎕SIGNAL</code> is more often than not called with <code>⍨</code> as the right argument is almost always a literal scalar, while the left argument is often constructed. </p><p>At the top of any API function we include the error guard:  </p><pre><code>500+⍳100::ReSignal ⎕DMX
</code></pre><p>This traps all errors in our arbitrary block of 100, and using <code>ReSignal</code> propagates expected errors to the calling function. Unexpected errors remain untrapped and fail where they are. <code>ReSignal</code> only specifies the event number <code>EN</code> and <code>Message</code> for <code>⎕DMX</code>. The event message <code>EM</code> is automatically provided. <code>ReSignal</code> is a niladic trad function that returns a function. The reason for this subterfuge is that we want to encapsulate the right side of this error guard:</p><pre><code>300+⍳100::⎕SIGNAL ⊂('EN'(⎕DMX.EN-500))('Message'⎕DMX.Message)
</code></pre><p>as this is far too much code to be copying and pasting all over the place. But <code>⎕SIGNAL</code> itself cannot be wrapped inside a function (trad or dfn) or it will not break out of the main function. It must signal in the scope of the main API function. The code to the right of <code>⎕SIGNAL</code> could easily be wrapped, but it would be nice to include the whole thing. Thus the trad function <code>ReSignal</code> returns a function that includes the whole thing, but keeps the <code>⎕SIGNAL</code> out of the subfunction.  This encapsulation technique is lifted from <a href="https://github.com/abrudz/dyalog_vision/blob/main/%E2%88%86SIGNAL.aplf">Adám Brudzewsky</a>.                                                             </p></article></main><footer><p>Copyright 2021-2025 Paul S. Mansour</p></footer></body></html>
