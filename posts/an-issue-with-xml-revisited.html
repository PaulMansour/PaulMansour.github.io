<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"></meta>
    <meta content="width=device-width, initial-scale=1" name="viewport"></meta>
    <link href="/ThorntonMelon.css" rel="stylesheet"></link>
  </head>
  <body>
    <header>
      <h1>Tool of Thought</h1>
      <h2>APL for the Practical Man</h2>
      <h3>"You don't know how bad your code is until you write about it."</h3>
      <nav>
        <a href="/">Home</a>
        <a href="/posts">Posts</a>
        <a href="/projects">Projects</a>
        <a href="/donts">Don'ts</a>
        <a href="/links">Links</a>
        <a href="/about">About</a>
      </nav>
    </header>
    <main>
      <article>
        <header>
          <h1>
            <a href="/posts/an-issue-with-xml-revisited">An Issue With
            ⎕XML Revisited</a>
          </h1>
          <h2>January 9, 2023</h2>
        </header>
        <p>In a <a href="/posts/two-issues-with-xml">previous post</a> I looked at a couple of issues with <code>⎕XML</code>. One issue was formatting when converting to XML: I wanted indentation and removal of whitespace for most elements, but not all. I dont know how I missed it, but there is a way to do this built into the XML spec and <code>⎕XML</code> supports it. Simply add a special attribute to the elements in question. It's right there <a href="https://help.dyalog.com/latest/index.htm#Language/System%20Functions/xml.htm">in the docs</a>:</p>
        <pre><code>xml:space="preserve"
</code></pre>
        <p>Thus, if the overall variant is <code>'Whitespace' 'Strip'</code>, individual elements will preserve whitespace with this attribute specified.</p>
        <p>This is more than cosmetic given the differences between XML and HTML. A paragraph with in-line markup, like bold, code, etc., must have whitespace preserved when generated using <code>⎕XML</code> otherwise an additional space will be added due to the formatting. Of course <code>pre</code> elements should also have whitespace preserved. So far I apply <code>xml:space="preserve"</code> to the <code>p</code>, <code>pre</code>, and <code>tr</code> elements. The latter formats tables nicely, with each row on its own line.</p>
        <p>Unfortunately the generated XML has <code>xml:space="preserve"</code> littered throughout the character vector which provides no use, and increases the size of the array. Oddly enough, I don't think I have ever written code to remove all the occurrences of a given substring from a string - or at least I can't remember doing it. It seems like it would be a very common task. Let's do it without using regular expressions.</p>
        <p>First, let's find the substrings, easy with the <a href="https://help.dyalog.com/latest/index.htm#Language/Primitive%20Functions/Find.htm">find</a> primitive. This marks the beginning of each substring <code>⍺</code> in the target string <code>⍵</code>:</p>
        <pre><code>     'ere'{⍺⍷⍵}'here there where'
0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0
</code></pre>
        <p>Next lets extend each 1 by the length of the substring, using n-wise or-reduction, fully marking each found substring:</p>
        <pre><code>      'ere'{(≢⍺)∨/⍺⍷⍵}'here there where'
1 1 0 0 0 1 1 1 0 0 0 1 1 1
</code></pre>
        <p>Two related problems arise. First, as always with n-wise reduction, the result is shorter than the right argument. Second, when a substring is found at or near the beginning of the string, we don't get enough 1s. We can fix this by appending the substring to the  target string before searching:</p>
        <pre><code>      'ere'{(≢⍺)∨/⍺⍷⍺,⍵}'here there where'
1 0 1 1 1 0 0 0 1 1 1 0 0 0 1 1 1
</code></pre>
        <p>Note that it is merely a convenience to append the substring itself, as it is, by definition, the proper length. We could also append an appropriate number of zeros to the result of <code>find</code> before applying the reduction. </p>
        <p>Now we have only one problem: the Boolean mask is too long, by 1. So we drop off the first element:</p>
        <pre><code>      'ere'{1↓(≢⍺)∨/⍺⍷⍺,⍵}'here there where'
0 1 1 1 0 0 0 1 1 1 0 0 0 1 1 1
</code></pre>
        <p>The Boolean mask flags what we want to remove, not what we want to keep, so we negate it, flipping 1s to 0s and vice versa: </p>
        <pre><code>      'ere'{~1↓(≢⍺)∨/⍺⍷⍺,⍵}'here there where'
1 0 0 0 1 1 1 0 0 0 1 1 1 0 0 0
</code></pre>
        <p>Finally, we apply <a href="https://help.dyalog.com/latest/index.htm#Language/Primitive%20Functions/Replicate.htm">compress or replicate</a>, with <a href="https://help.dyalog.com/latest/index.htm#Language/Primitive%20Operators/Commute.htm">commute</a> to avoid parentheses, to keep everything but the substrings:</p>
        <pre><code>      'ere'{⍵/⍨~1↓(≢⍺)∨/⍺⍷⍺,⍵}'here there where'
h th wh
</code></pre>
      </article>
    </main>
    <footer>
      <p>Copyright 2024 Paul S. Mansour</p>
    </footer>
  </body>
</html>
