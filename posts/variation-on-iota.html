<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><link href="/ThorntonMelon.css" rel="stylesheet"></link></head><body><header><h1>Tool of Thought</h1><h2>APL for the Practical Man</h2><h3>"Don't chase tech. Chase fun." - Gunpei Yokoi</h3><nav><a href="/">Home</a><a href="/posts">Posts</a><a href="/projects">Projects</a><a href="/donts">Don'ts</a><a href="/links">Links</a><a href="/about">About</a></nav></header><main><article><header><h1><a href="/posts/variation-on-iota">Variation on Iota</a></h1><h2>November 12, 2025</h2></header><p>We just encountered the following real-life problem, which oddly, if memory serves, we have never encountered before: Given a list of items, find the location of each item in a list of lists of items. An example will make it clear:</p><pre><code>      a← 'abc' 'de' '' 'fgha'
      w←'hafxd'
      a {...} w
3 0 3 4 1
</code></pre><p>So, it's just like <a href="https://docs.dyalog.com/20.0/language-reference-guide/primitive-functions/index-of/">Index Of</a> (<code>⍳</code>), only we are looking a level deeper on the left for the  existence of an item on the right. We are not concerned where in the sublist on the left the item on the right is found. It is simply the location of the sublist (where the item is found) within the main list.   </p><p>Our first inclination is to flatten out <code>a</code>, and then lookup items in <code>w</code> in the new flat array:</p><pre><code>      ⊃,/a
abcdefgha
      (⊃,/a)⍳w
7 0 5 9 3
</code></pre><p>Then we need to map these indices, which index into the flattened array, back to indices apropriate for the original nested array, which are given by:</p><pre><code>        ⍳≢a
0 1 2 3
</code></pre><p>We can do this by counting the items in each sublist:</p><pre><code>      ≢¨a
3 2 0 4
</code></pre><p>And then replicating:</p><pre><code>      (≢¨a)/⍳≢a
0 0 0 1 1 3 3 3 3
</code></pre><p>Now we can map the first set of indices into the second set of indices to get the desired indices:</p><pre><code>      (⊂(⊃,/a)⍳w)⌷(≢¨a)/⍳≢a
INDEX ERROR
</code></pre><p>Oops, we need one more index for things not found:</p><pre><code>      (1,⍨≢¨a)/⍳1+≢a
0 0 0 1 1 3 3 3 3 4
</code></pre><p>And now, with a little code golf to remove a set of parentheses:</p><pre><code>     (⊂w⍳⍨⊃,/a)⌷(1,⍨≢¨a)/⍳1+≢a
3 0 3 4 1
</code></pre><p>Bingo, we are done. Let's make it a dfn:</p><pre><code>      liota←{(⊂⍵⍳⍨⊃,/⍺)⌷(1,⍨≢¨⍺)/⍳1+≢⍺}
</code></pre><p>Now let's try a completely different approach. Consider the <a href="https://docs.dyalog.com/20.0/language-reference-guide/primitive-operators/outer-product/">outer product</a>  of <a href="https://docs.dyalog.com/20.0/language-reference-guide/primitive-functions/membership/">membership</a> (<code>∊</code>):</p><pre><code>      w∘.∊a
0 0 0 1
1 0 0 1
0 0 0 1
0 0 0 0
0 1 0 0
</code></pre><p>If we look for the first occurance of a <code>1</code> in each row we get our answer:</p><pre><code>      (↓w∘.∊a)⍳¨1
3 0 3 4 1
</code></pre><p>And a little golf:</p><pre><code>      1⍳⍨¨↓w∘.∊a
3 0 3 4 1
</code></pre><p>For what it is worth, we can get rid of nesting the Boolean matrix and the  <a href="https://docs.dyalog.com/20.0/language-reference-guide/primitive-operators/each/each-with-monadic-operand/">each operator</a> by using the <a href="https://docs.dyalog.com/20.0/language-reference-guide/primitive-operators/rank/">rank operator</a> , un-golfing in the process:  </p><pre><code>      1⍳⍨(⍤1)w∘.∊a
3 0 3 4 1
</code></pre><p>Maybe we can go tacit. It looks like we have a function between <code>a</code> and <code>w</code>, and then a function on the result, that is:</p><pre><code>   g a f w
</code></pre><p>Which can be rewritten as an <a href="https://docs.dyalog.com/20.0/programming-reference-guide/introduction/trains/#forks-and-atops">atop</a>:</p><pre><code>    a (g f) w
</code></pre><p>Where: </p><pre><code>      f←∘.∊⍨
      g←⍳∘1⍤1
</code></pre><p>Let's see if it works:</p><pre><code>      a (g f) w
3 0 3 4 1
</code></pre><p>Oh yeah! Now we can just combine into one function:</p><pre><code>    liota2←⍳∘1⍤1∘.∊⍨ 
    a liota2 w
3 0 3 4 1
</code></pre><p>We can guess that while the tacit version is short and sweet, it's going to be a dog in terms of time and space due to the outer product when both arguments get large, and indeed the flat version is almost infinitely faster. That being said, in our use case, neither argument will ever be very large.</p><h2>Update</h2><p>Josh David provides a much nicer flat array solution using <a href="https://docs.dyalog.com/20.0/language-reference-guide/primitive-functions/interval-index/">interval index</a> that is both shorter and faster:</p><pre><code>      {1+(+\≢¨⍺)⍸⍵⍳⍨⊃,/⍺}
</code></pre><p>It's amazing the various uses of <code>⍸</code>.</p><h2>Another Update</h2><p>Aaron Hsu writes in with another solution using <code>⍸</code>, but in its monadic form <a href="https://docs.dyalog.com/20.0/language-reference-guide/primitive-functions/where/">Where</a>, which we had completely forgotten or maybe never knew can take an argument of non-negative integers, as well as the more typical Boolean: </p><pre><code>      {((⍸≢¨⍺),≢⍺)[(∊⍺)⍳⍵]}
</code></pre><p>The Dyalog docs state that the model for <code>Where</code> can be expressed as <code>{(,⍵)/,⍳⍴⍵}</code>, which is exactly what we where doing in our first solution above.</p><p>We should have mentioned in the original post that our use case is not scaler integer or character items,  but vectors of vectors representing names. So replacing <code>∊</code> with <code>⊃,/</code>, and a little golf yields:</p><pre><code>      {(⍸≢¨⍺,1)[⍵⍳⍨⊃,/⍺]} 
</code></pre><p>I was a little bothered by <code>(⍸≢¨⍺),≢⍺</code> and happy to discover that <code>⍳≢¨⍺,1</code> will do as well.</p><p>Aaron also sent a tacit version (for scaler items only) with the new behind operator which is not even on my keyboard:</p><pre><code>      (⊂∊⍛⍳)⌷((⍸≢¨),≢)⍤⊣
</code></pre><p>I wonder if this can be simplified a bit, given the golf above.</p></article></main><footer><p>Copyright 2021-2025 Paul S. Mansour</p></footer></body></html>
