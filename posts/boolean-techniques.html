<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><link href="/ThorntonMelon.css" rel="stylesheet"></link></head><body><header><h1>Tool of Thought</h1><h2>APL for the Practical Man</h2><h3>"You don't know how bad your design is until you write about it."</h3><nav><a href="/">Home</a><a href="/posts">Posts</a><a href="/projects">Projects</a><a href="/donts">Don'ts</a><a href="/links">Links</a><a href="/about">About</a></nav></header><main><article><header><h1><a href="/posts/boolean-techniques">Boolean Techniques</a></h1><h2>May 13, 2023</h2></header><p>In a recent post titled <a href="https://www.sacrideo.us/suggestivity-and-idioms-in-apl/">Suggestivity and Idioms in APL</a> on his blog <a href="https://www.sacrideo.us/tag/apl/">Fastidious Elegance</a> Arron Hsu enumerates all the permutations and combinations of logical pairwise reductions on Boolean vectors. There are 10 scalar dyadic relational functions and Aaron throws in <code>⊣</code> and  <code>⊢</code> as well for total of 12 functions. With the catenation of 1 or 0 on the front or the back, to keep the result the same shape as the input, there are <code>12×2×2</code> or <code>48</code> possible combinations. </p><p>It would be convenient to be able to describe in short terms what each of these Boolean transformations does. If we can't meaningfully name them, we probably cannot effectively use them. If we are going to search for these expressions on, say, <a href="https://aplcart.info">APL Cart</a>, we need to have some way to describe them.</p><p>In his 1987 book <strong>APL - Advanced Techniques and Utilities</strong>, Gary Bergquist uses the terms <em>maps</em> and  <em>poles</em> to facilitate discussion of Boolean vectors and techniques: </p><blockquote><p>A "maps" vector is a Boolean vector which consists of sets of contiguous 1s (1-maps) separated by one or more 0s, (0-maps). For example, the following bit vector contains 3 1-maps and 4 0-maps:</p><pre><code>0 0 1 1 1 1 0 0 0 1 1 0 0 1 1 1 1 1 0 0
</code></pre><p>A "leading" 1-poles vector is a Boolean vector which consists of pairs of 1s  separated by zero or more 0s. The 1's are called "poles".  The left pole in each pair may be viewed as the starting element of a set of contiguous elements.  The right pole in each pair may be viewed as the next element beyond the ending element of the set. For example, the following bit vector contains 3 pairs of leading 1-poles:</p><pre><code>0 0 1 0 0 0 1 0 0 1 0 1 0 1 0 0 0 0 1 0  
</code></pre><p>Notice that 1-maps and leading 1-poles are alternative means of conveying the  same information. Basically they identify spans of contiguous elements. 1-maps do so by using 1s to flag the elements within the spans. Leading 1-poles do so by using 1s to flag the starts of spans and the starts of non-spans (hence the  word "leading").</p></blockquote><p>We can flip the bits and discuss 0-maps and leading 0-poles as well. These terms do not represent any inherent properties of Boolean vectors, but rather an interpretation of what the 1's and 0's mean. The same Boolean vector could be a 1-maps vector in one context and a 1-poles vector in another context.   This, however, does not lessen the usefulness of the terms. With this terminolgy in hand, we can interpret  <code>≠\</code> as converting leading 1-poles to 1-maps, and <code>=\</code> as converting leading 0-poles to 0-maps.</p><p>How many of Aaron's 48 permutations can be succinctly described with this lexicon? Gary defines and names 6 transformations, using shift-and-compare techniques that pre-date the introduction of n-wise reduction. We can find the corresponding 6 transformations in Aaron's 48 by inspection:  </p><table><thead><tr><th class="left">            </th><th class="left">            </th><th class="left">                               </th></tr></thead><tbody><tr><td class="left"> <code>R≠¯1↓0,R</code> </td><td class="left"> <code>{2≠/0,⍵}</code> </td><td class="left"> 1-maps to leading 1-poles     </td></tr><tr><td class="left"> <code>R=¯1↓1,R</code> </td><td class="left"> <code>{2=/1,⍵}</code> </td><td class="left"> 0-maps to leading 0-poles     </td></tr><tr><td class="left"> <code>R&gt;¯1↓0,R</code> </td><td class="left"> <code>{2&lt;/0,⍵}</code> </td><td class="left"> 1-maps to first 1 bits        </td></tr><tr><td class="left"> <code>R≥¯1↓1,R</code> </td><td class="left"> <code>{2≤/1,⍵}</code> </td><td class="left"> 0-maps to first 0 bits        </td></tr><tr><td class="left"> <code>R∨¯1↓0,R</code> </td><td class="left"> <code>{2∨/0,⍵}</code> </td><td class="left"> extend 1-maps to right by 1   </td></tr><tr><td class="left"> <code>R∧¯1↓1,R</code> </td><td class="left"> <code>{2∧/1,⍵}</code> </td><td class="left"> extend 0-maps to right by 1   </td></tr></tbody></table><p>From these, six related ones jump right out:</p><table><thead><tr><th class="left">            </th><th class="left">            </th><th class="left">                                </th></tr></thead><tbody><tr><td class="left"> <code>R≠1↓R,0</code>  </td><td class="left"> <code>{2≠/⍵,0}</code> </td><td class="left"> 1-maps to trailing 1-poles     </td></tr><tr><td class="left"> <code>R=1↓R,1</code>  </td><td class="left"> <code>{2=/⍵,1}</code> </td><td class="left"> 0-maps to trailing 0-poles     </td></tr><tr><td class="left"> <code>R&gt;1↓R,0</code>  </td><td class="left"> <code>{2&gt;/⍵,0}</code> </td><td class="left"> 1-maps to last 1 bits          </td></tr><tr><td class="left"> <code>R≥1↓R,1</code>  </td><td class="left"> <code>{2≥/⍵,1}</code> </td><td class="left"> 0-maps to last 0 bits          </td></tr><tr><td class="left"> <code>R∨1↓R,0</code>  </td><td class="left"> <code>{2∨/⍵,0}</code> </td><td class="left"> extend 1-maps to left by 1     </td></tr><tr><td class="left"> <code>R∧1↓R,1</code>  </td><td class="left"> <code>{2∧/⍵,1}</code> </td><td class="left"> extend 0-maps to left by 1     </td></tr></tbody></table><p>Aaron may be a bit optimistic when he writes that <em>almost all of the binary relations that we can imagine in use here find some meaningful interpretation</em>, but here we have 12 simple, visually suggestive, well-named expressions using the language of maps and poles. That's a good start. Can we find more?</p></article></main><footer><p>Copyright 2024 Paul S. Mansour</p></footer></body></html>
